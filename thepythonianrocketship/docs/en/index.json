[
{
	"uri": "https://pythonianrocketship.github.io/en/",
	"title": "Learn Python",
	"tags": [],
	"description": "",
	"content": "Learn Python Welcome to Introduction and Intermediate Python, recorded for Frontend Masters.\nCreated by Nina Zakharenko. @Seyamalam1.\nWatch the accompanying screencast via subscription on FrontendMasters.com.\nWatch the course Stay up to date with me on LinkedIn, or to contact me directly, please send me an email at eyamalam41@gmail.como.\nYou can find the content and exercises on the Github repo.\nThe course content is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.\nI\u0026rsquo;d like to encourage learning individuals to learn Python from the course material for free, but if you\u0026rsquo;d like to use the material for your own workshop or for commercial use, please consider supporting my work and watch the screencast instead.\n"
},
{
	"uri": "https://pythonianrocketship.github.io/en/02-introduction-to-python/190-apis/00-what-is-an-api/",
	"title": "What Is an API?",
	"tags": [],
	"description": "",
	"content": "Per the dictionary, an API is:\na set of functions and procedures allowing the creation of applications that access the features or data of an operating system, application, or other service.\nAn API is a standardized way of accessing information across the web, between clients and servers. These days most APIs are RESTful. That means they follow a common set of paradigms and practices.\nThere are many types of APIs, but these days they\u0026rsquo;re commonly known to refer to web APIs.\nAuthentication Some, but not all APIs require you to authenticate. Methods of authentication are out of the scope of this class, but you\u0026rsquo;ll be happy to know that there are plenty of free APIs available that require no authentication at all.\nRate Limiting Some APIs allow unauthenticated requests, but they\u0026rsquo;re usually rate limited. Rate limiting means prevent the same client (usually by IP address) from making too many requests at once and overloading the server. The GitHub API allows 50 unauthenticated requests per hour per IP, or 10 unauthenticated requests to their Search API.\nNote: After the class, you can find a detailed list of APIs in this public-apis repo.\nFree APIs Free APIs are\u0026hellip; free. That means that they may go down if their owner decides to drop their upkeep. If the API used in these examples doesn\u0026rsquo;t work in the future, try a different one listed in the public-apis repo linked to above.\n"
},
{
	"uri": "https://pythonianrocketship.github.io/en/03-intermediate-python/80-web-frameworks/basic-flask/",
	"title": "Basic Flask",
	"tags": [],
	"description": "",
	"content": "Types of Web Frameworks in Python Django Django is a full-featured, high-level framework for building web apps. Django focuses on automating as much as possible, and many large-scale sites run on Django.\nFlask Flask is a \u0026ldquo;microframework\u0026rdquo; for Python, allowing users to make basic backend APIs and webapps with a minimum of code. Flask is easy for beginners and not opinionated, so we\u0026rsquo;ll be focusing on it for today\u0026rsquo;s exercises.\nThere are many more different frameworks for Python. You can find a more detailed list here.\nPyramid Pyramid is a fast, yet advanced framework, and a successor to the older Pylons framework. Pyramid is open-source and actively developed.\nA Basic Flask App Make sure you have Flask installed: python -m pip install flask\nA very basic Flask app looks something like this:\nfrom flask import Flask app = Flask(__name__) @app.route(\u0026#34;/\u0026#34;) def hello(): return \u0026#34;Hello World!\u0026#34; First, we import flask, and create the app object using the name of the file (__name__). We add a route using @app.route(\u0026quot;/\u0026quot;) above our hello() function - this tells Flask to respond to requests for \u0026ldquo;/\u0026rdquo; (the root of your webserver) by running hello() and returning \u0026ldquo;Hello World!\u0026rdquo; to the user.\nTo run this, you could copy this code into a file called hello.py, set the FLASK_APP environment variable, and run it. Then just point your browser to the URL it gives you.\n$ FLASK_APP=hello.py flask run * Running on http://localhost:5000/ Routing Image from Zapier Guide to APIs.\nFlask uses the route() decorator to declare routes. For example, the above code uses app.route(\u0026quot;/\u0026quot;) to declare a route for \u0026ldquo;/\u0026rdquo; that resolves to hello(), but you can use any path, or even accept variables in your routes:\n@app.route(\u0026#34;/my/secret/page\u0026#34;) def secret(): return \u0026#34;Shh!\u0026#34; @app.route(\u0026#34;/user/\u0026lt;username\u0026gt;\u0026#34;) def user_page(username): return f\u0026#34;Welcome, {username}!\u0026#34; @app.route(\u0026#34;/blog/post/\u0026lt;int:post_id\u0026gt;\u0026#34;) def show_post(post_id): return f\u0026#34;This is the page for post # {post_id}\u0026#34; More information about routing can be found in the Flask documentation.\nReturning Data The simplest way to return data is to return a string with return at the end of your function. This pushes the string back to the user, who sees it as plain text in their browser. You\u0026rsquo;ll probably want to make use of HTML in your webapps though, so you\u0026rsquo;ll want to look at template rendering.\nA template is just an HTML file that lives in a folder called templates next to your flask app Python file. To return an HTML file instead of plain text, just return the render_template() function. For example:\nfrom flask import render_template @app.route(\u0026#39;/\u0026#39;) def index(): return render_template(\u0026#39;index.html\u0026#39;) Flask also supports a template language called Jinja that allows you to populate your HTML files with data from your Flask app at render time. A very simple HTML template might look like this:\n\u0026lt;!doctype html\u0026gt; \u0026lt;title\u0026gt;Hello from Flask\u0026lt;/title\u0026gt; {% if name %} \u0026lt;h1\u0026gt;Hello {{ name }}!\u0026lt;/h1\u0026gt; {% else %} \u0026lt;h1\u0026gt;Hello, World!\u0026lt;/h1\u0026gt; {% endif %} Notice the special code in {% brackets %}, this acts as a very simple programming language. Let\u0026rsquo;s add a matching Flask function:\nfrom flask import render_template @app.route(\u0026#39;/hello/\u0026#39;) @app.route(\u0026#39;/hello/\u0026lt;name\u0026gt;\u0026#39;) def hello(name=None): return render_template(\u0026#39;hello.html\u0026#39;, name=name) Now, if we call /hello, we\u0026rsquo;ll see Hello, World!, and if we call /hello/nina, we\u0026rsquo;ll see Hello nina!. This is a very simple example, you can find more details in the Flask documentation and the Jinja documentation.\nStatic Files Serving static files alongside your dynamic Flask code is easy - just create a folder called static next to your Flask code, and any files you put in there will be available at /static/\u0026lt;your filename\u0026gt;.\nDebug Mode Flask has a very handy built-in debugger that makes it very easy to see what went wrong when you have an error in your application. You can activate the debugger by setting the FLASK_ENV variable:\n$ export FLASK_APP=my_application $ export FLASK_ENV=development $ flask run Using a Database Flask provides a useful mechanism for accessing database objects. This makes it easy to use databases to store data for your dynamic webapp. More information is available in the Flask documentation.\nDeploying your Web App Is your app ready for the big time? There are many different options for deploying your Flask app to a real webserver - you can read about some of your options in the Flask documentation.\nMore About Flask We\u0026rsquo;ll be covering just the basics of flask today. To deep dive and learn more, the flask Mega Tutorial is a great resource to check out after class.\n"
},
{
	"uri": "https://pythonianrocketship.github.io/en/03-intermediate-python/70-tests/10-concept/",
	"title": "Concept",
	"tags": [],
	"description": "",
	"content": "Unit testing is a software testing method by which individual functions are tested in an automated fashion to determine if they are fit for use. Automated unit testing not only helps you discover and fix bugs quicker and easier than if you weren\u0026rsquo;t testing, but by writing them alongside or even before your functions, they can help you write cleaner and more bug-free code from the very start.\nTypes of Tests There are several different kinds of automated tests that can be performed at different abstraction levels.\nUnit tests operate on the smallest testable unit of code, usually a function that performs a single action or operation. Integration tests check to see if different units or modules of code work together as a group. Functional tests operate on units of functionality, to make sure a specific function of the software is working, which may involve several units of software or whole systems working together. For this class, we\u0026rsquo;ll just be focusing on unit tests.\nTests in the Real World™ How is this helpful in the real world? Many companies that invest in software development maintain a CI/CD (Continuous Integration or Continuous Deployment) pipeline. This usually involves extensive unit tests, integration tests, and maybe even functional tests, which are set up to run automatically after (and sometimes even before) code is committed. If the tests fail, deployment can be stopped and the developers get notified before broken code ever makes it to production servers. This can be complicated to set up properly, but saves an enormous amount of time in the long run, and helps to keep bugs from ever reaching your users.\n"
},
{
	"uri": "https://pythonianrocketship.github.io/en/03-intermediate-python/30-oop-classes-inheritance/10-concept/",
	"title": "Concept",
	"tags": [],
	"description": "",
	"content": "Object-oriented Programming (OOP) is a language model (or paradigm) in which properties or behaviors are organized into \u0026ldquo;objects\u0026rdquo;. Some languages encourage a more procedural style, like if you were writing a recipe - some popular examples are COBOL and BASIC. Languages that adopt an Object-oriented style organize things into objects, and provide methods for objects to communicate with one another.\nWhat is an object? An object can be a function, a variable, a property, a class\u0026hellip; everything in Python is an object. You can think of an object as a generic container - a list object might contain a sequence of int objects, along with some function objects. The int objects contain integer numbers. The function objects contain code that can be executed on the list object or maybe on the items in the list.\nPython and OOP Python buys heavily into the OOP model - you\u0026rsquo;ll find that everything in Python is an object of some kind, and almost everything has attributes and methods.\nThis doesn\u0026rsquo;t mean you have to use OOP in your programs - Python works perfectly well as a procedural or \u0026ldquo;script\u0026rdquo; language, where one command is executed after another, like a recipe. But getting familiar with OOP will not only help you read other Python code, but it will help you learn to encapsulate your code into objects for better organization and readability, as well as increase efficiency by making your code easily reusable. Objects are center-stage in Python, representing not only the data, but the overall structure of your programs as well.\n"
},
{
	"uri": "https://pythonianrocketship.github.io/en/03-intermediate-python/50-libraries-modules/10-standard-library/",
	"title": "Standard Library",
	"tags": [],
	"description": "",
	"content": "Python has always had a \u0026ldquo;batteries included\u0026rdquo; philosophy - having a rich and versatile standard library which is immediately available, without making the user download separate packages. This is thought to have contributed to Python\u0026rsquo;s early success. No matter what you\u0026rsquo;re trying to accomplish, there\u0026rsquo;s probably a built-in library that can help you do what you want.\nThe downside to this is that the standard libraries need to maintain backwards compatibility. Some were quick hacks, hard to use, poorly designed and now impossible to fix, or have simply been rendered obsolete. Luckily, Python also makes it easy to install and use external libraries - we\u0026rsquo;ll cover this later.\nThe Standard Library There are some great libraries included with Python that you\u0026rsquo;ll probably end up seeing or using frequently. sys provides system-specific parameters and functions, such as exit(). os has miscellaneous operating system interfaces, and provides the excellent os.path submodule for handling file paths on any operating system. math gives you all the advanced math function. json is an easy-to-use json parser and encoder. Python even gives you built-in libraries for database access, logging, internet protocols, multimedia, debugging, and even libraries for extending Python itself. The full list of standard libraries can be found in the Python documentation.\nAs a quick example, let\u0026rsquo;s look at Python\u0026rsquo;s datetime library. You can easily make a datetime object that represents any given point in time. For example:\n\u0026gt;\u0026gt;\u0026gt; import datetime \u0026gt;\u0026gt;\u0026gt; right_now = datetime.datetime.now() \u0026gt;\u0026gt;\u0026gt; print(right_now) 2019-03-17 13:41:10.994700 \u0026gt;\u0026gt;\u0026gt; repr(right_now) \u0026#39;datetime.datetime(2019, 3, 17, 13, 41, 10, 994700)\u0026#39; We can even make a datetime object for an arbitrary date, and subtract it from right now to get a timedelta object:\n\u0026gt;\u0026gt;\u0026gt; new_years = datetime.datetime(2019, 1, 1, 0, 0) \u0026gt;\u0026gt;\u0026gt; print(new_years) 2019-01-01 00:00:00 \u0026gt;\u0026gt;\u0026gt; delta = right_now - new_years \u0026gt;\u0026gt;\u0026gt; print(delta) 75 days, 13:41:10.994700 We can easily see that it\u0026rsquo;s been over 75 days from new_years until right_now. We\u0026rsquo;ll come back to datetime later in this chapter.\n"
},
{
	"uri": "https://pythonianrocketship.github.io/en/03-intermediate-python/40-exceptions/10-all-about-exceptions/",
	"title": "All About Exceptions",
	"tags": [],
	"description": "",
	"content": "Built-in exceptions and easy exception handling is one of the shining features of Python. Technically, errors that happen during parsing are called SyntaxErrors - these will probably be the most common errors you see, and usually happen because of a mistake in whitespace, a syntax misunderstanding, or a simple typo.\nEven if the syntax is correct, errors can still occur when your program is run. We call these Exceptions, and there a many different types (this is a good thing, because the more specifically we know what went wrong, the better we can handle it).\nAn un-handled exception is fatal: it will print debugging information (called a traceback), stop the interpreter, and exit your program. However, once you learn to handle Exceptions, you can cover your bases and write programs that are robust in the face of issues.\nTypes of Exceptions Python has many useful built-in exceptions that you\u0026rsquo;ll probably encounter in your travels. Some of the more common ones that you\u0026rsquo;ll run into are:\nException Cause of Error AttributeError Raised when attribute assignment or reference fails. ImportError Raised when the imported module is not found. IndexError Raised when index of a sequence is out of range. KeyError Raised when a key is not found in a dictionary. KeyboardInterrupt Raised when the user hits interrupt key (Ctrl+c or delete). NameError Raised when a variable is not found in local or global scope. SyntaxError Raised by parser when syntax error is encountered. IndentationError Raised when there is incorrect indentation. ValueError Raised when a function gets argument of correct type but improper value. You can find a more detailed list of built-in exceptions in the Python documentation.\nException Hierarchy An important thing to know is that exceptions, like everything else in Python, are just objects. They follow an inheritance hierarchy, just like classes do. For example, the ZeroDivisionError is a subclass of ArithmeticError, which is a subclass of Exception, itself a subclass of BaseException.\nSo, if you wanted to catch a divide-by-zero error, you could use except ZeroDivisionError. But you could also use except ArithmeticError, which would catch not only ZeroDivisionEror, but also OverflowError and FloatingPointError. You could use except Exception, but this is not a good idea, as it will catch almost every type of error, even ones you weren\u0026rsquo;t expecting. We\u0026rsquo;ll discuss this a bit later. Again, a full chart of the hierarchy for built-in exceptions can be found at the bottom of the (Python documentation)[https://docs.python.org/3/library/exceptions.html#exception-hierarchy].\nExiting your Program As we mentioned, exceptions that are allowed to bubble up to the top level (called unhandled exceptions) will cause your program to exit. This is generally unwanted - even if an error is unrecoverable, we still want to provide more detailed information about the error for later inspection, or a pretty error for the user if our program is user-facing, and in most cases, we want the program to go back to doing what it was doing.\nWhat if we want our program to stop, though? You may already be familiar with ctrl-c, the age-old posix method of sending SIGINT (an interrupt signal) to a program. You may be surprised to know asking your operating system to send SIGINT to Python causes, yes, an exception - KeyboardInterrupt. And yes, you can catch KeyboardInterrupt, but this will make your program a little harder to kill.\nYou can also use sys.exit() from the built-in sys library. It\u0026rsquo;s generally not a good idea to pepper sys.exit() around your code, as it makes it harder to control when your program exits, but this can be a handy function for controlling how and when your program exits. By default, sys.exit() with no parameters will exit with a 0 return code, which, by posix convention, signals success. You can pass an integer to sys.exit() if you\u0026rsquo;d like to exit with a non-zero return code (usually signaling some sort of failure condition). You can also pass a string to sys.exit(), which will get printed to the command line, along with a return code of 1.\nsys.exit() generates a SystemExit exception, which inherits from the master BaseException class, which makes it possible for clean-up handlers (such as finally statements) to run.\n"
},
{
	"uri": "https://pythonianrocketship.github.io/en/03-intermediate-python/20-advanced-looping/10-list-comprehensions/",
	"title": "List Comprehensions",
	"tags": [],
	"description": "",
	"content": "List comprehensions are a unique way to create lists in Python. A list comprehension consists of brackets containing an expression followed by a for clause, then zero or more for or if clauses. The expressions can be any kind of Python object. List comprehensions will commonly take the form of [\u0026lt;value\u0026gt; for \u0026lt;vars\u0026gt; in \u0026lt;iter\u0026gt;].\nA simple case: Say we want to turn a list of strings into a list of string lengths. We could do this with a for loop:\n\u0026gt;\u0026gt;\u0026gt; names = [\u0026#34;Nina\u0026#34;, \u0026#34;Max\u0026#34;, \u0026#34;Rose\u0026#34;, \u0026#34;Jimmy\u0026#34;] \u0026gt;\u0026gt;\u0026gt; my_list = [] # empty list \u0026gt;\u0026gt;\u0026gt; for name in names: ... my_list.append(len(name)) ... \u0026gt;\u0026gt;\u0026gt; print(my_list) [4, 3, 4, 5] We can do this much easier with a list comprehension:\n\u0026gt;\u0026gt;\u0026gt; names = [\u0026#34;Nina\u0026#34;, \u0026#34;Max\u0026#34;, \u0026#34;Rose\u0026#34;, \u0026#34;Jimmy\u0026#34;] \u0026gt;\u0026gt;\u0026gt; my_list = [len(name) for name in names] \u0026gt;\u0026gt;\u0026gt; print(my_list) [4, 3, 4, 5] We can also use comprehensions to perform operations, and the lists we assemble can be composed of any type of Python object. For example:\n\u0026gt;\u0026gt;\u0026gt; names = [\u0026#34;Nina\u0026#34;, \u0026#34;Max\u0026#34;, \u0026#34;Rose\u0026#34;, \u0026#34;Jimmy\u0026#34;] \u0026gt;\u0026gt;\u0026gt; my_list = [(\u0026#34;length\u0026#34;, len(name) * 2) for name in names] \u0026gt;\u0026gt;\u0026gt; print(my_list) [(\u0026#39;length\u0026#39;, 8), (\u0026#39;length\u0026#39;, 6), (\u0026#39;length\u0026#39;, 8), (\u0026#39;length\u0026#39;, 10)] In the above example, we assemble a list of tuples - each tuple contains the element \u0026ldquo;length\u0026rdquo; as well as each number from the len() function multiplied by two.\nConditionals You can also use conditionals (if statements) in your list comprehensions. For example, to quickly make a list of only the even lengths, you could do:\n\u0026gt;\u0026gt;\u0026gt; names = [\u0026#34;Nina\u0026#34;, \u0026#34;Max\u0026#34;, \u0026#34;Rose\u0026#34;, \u0026#34;Jimmy\u0026#34;] \u0026gt;\u0026gt;\u0026gt; my_list = [len(name) for name in names if len(name) % 2 == 0] \u0026gt;\u0026gt;\u0026gt; print(my_list) [4, 4] Here, we check divide every string length by 2, and check to see if the remainder is 0 (using the modulo operator).\nString Joining with a List Comprehension Back in our exercise on converting between types, we introduced the string.join() function. You can call this function on any string, pass it a list, and it will spit out a string with every element from the list \u0026ldquo;joined\u0026rdquo; by the string. For example, to get a comma-delimited list of numbers, you might be tempted to do:\n\u0026gt;\u0026gt;\u0026gt; my_string = \u0026#34;,\u0026#34;.join([0, 1, 2, 3, 4]) Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; TypeError: sequence item 0: expected str instance, int found Unfortunately, you can\u0026rsquo;t join a list of numbers without first converting them to strings. But you can do this easily with a list comprehension:\n\u0026gt;\u0026gt;\u0026gt; my_list = [0, 1, 2, 3, 4] \u0026gt;\u0026gt;\u0026gt; my_string = \u0026#34;,\u0026#34;.join([str(num) for num in my_list]) \u0026gt;\u0026gt;\u0026gt; print(my_string) 0,1,2,3,4 sum, min, max Some mathematical functions, such as sum, min, and max, accept lists of numbers to operate on. For example, to get the sum of numbers between zero and five, you could do:\nmy_sum = sum([0, 1, 2, 3, 4]) print(my_sum) But remember, anywhere you can use a list, you can use a list comprehension. Say you want to get sum, minimum, and maximum of every number between 0 and 100 that is evenly divisible by 3? No sense typing out a whole list in advance, just use a comprehension:\n\u0026gt;\u0026gt;\u0026gt; my_sum = sum([num for num in range(0, 100) if num % 3 == 0]) \u0026gt;\u0026gt;\u0026gt; print(my_sum) 1683 \u0026gt;\u0026gt;\u0026gt; my_min = min([num for num in range(0, 100) if num % 3 == 0]) \u0026gt;\u0026gt;\u0026gt; print(my_min) 0 \u0026gt;\u0026gt;\u0026gt; my_max = max([num for num in range(0, 100) if num % 3 == 0]) \u0026gt;\u0026gt;\u0026gt; print(my_max) 99 "
},
{
	"uri": "https://pythonianrocketship.github.io/en/03-intermediate-python/00-final-project-preview/",
	"title": "Final Project Preview",
	"tags": [],
	"description": "",
	"content": "Final Project Preview Our final project on Day 2 will involve creating a simple Flask web application from our Day 1 final exercise.\n"
},
{
	"uri": "https://pythonianrocketship.github.io/en/03-intermediate-python/10-introduction/00-getting-ready/",
	"title": "Getting Ready",
	"tags": [],
	"description": "",
	"content": "Get Ready For Day 2 - Navigate To Your Project Building on the project structure from Day 1, enter your ~/pyworkshop directory, and start your already existing virtual environment.\nWindows:\n\u0026gt; cd $home \u0026gt; cd pyworkshop \u0026gt; env\\scripts\\activate Mac:\n$ cd ~/pyworkshop $ source env/bin/activate Open VS Code If VS Code isn\u0026rsquo;t already open, type the following in the same PowerShell or Terminal window where you activated your virtual environment.\n$ code . Start The REPL Open the Command Palette in VS Code, and type: \u0026ldquo;Python: Start REPL\u0026rdquo;\nRemember, open the VS Code command palette (cmd + shift + P on Mac, ctrl + shift + P on Windows) and\n"
},
{
	"uri": "https://pythonianrocketship.github.io/en/03-intermediate-python/60-command-line-tools/10-advanced-strings/",
	"title": "Advanced Strings",
	"tags": [],
	"description": "",
	"content": "Advanced f-strings Decimal Formatting Formatting decimal or floating point numbers with f-strings is easy - you can pass in both a field width and a precision. The format is {value:width.precision}. Let\u0026rsquo;s format pi (3.1415926) to two decimal places - we\u0026rsquo;ll set the width to 1 because we don\u0026rsquo;t need padding, and the precision to 3, giving us the one number to the left of the decimal and the two numbers to the right:\n\u0026gt;\u0026gt;\u0026gt; print(f\u0026#34;Pi to two decimal places is {3.1415926:1.3}\u0026#34;) Pi to two decimal places is 3.14 # We\u0026#39;ll break it out into variables to make it clearer: \u0026gt;\u0026gt;\u0026gt; value = 3.1415926 \u0026gt;\u0026gt;\u0026gt; width = 1 \u0026gt;\u0026gt;\u0026gt; precision = 3 \u0026gt;\u0026gt;\u0026gt; print(f\u0026#34;Pi to two decimal places is: {value:{width}.{precision}}\u0026#34;) Pi to two decimal places is: 3.14 # Let\u0026#39;s change the width to 10 \u0026gt;\u0026gt;\u0026gt; value = 3.1415926 \u0026gt;\u0026gt;\u0026gt; width = 10 \u0026gt;\u0026gt;\u0026gt; precision = 3 \u0026gt;\u0026gt;\u0026gt; print(f\u0026#34;Pi to two decimal places is: {value:{width}.{precision}}\u0026#34;) Pi to two decimal places is: 3.14 Note how the second one is padded with extra spaces - the number is four characters long (including the period), so the formatter added six extra spaces to equal the total width of 10.\nMultiline Strings Sometimes it\u0026rsquo;s easier to break up large statements into multiple lines. Just prepend every line with f:\n\u0026gt;\u0026gt;\u0026gt; name = \u0026#39;Nina\u0026#39; \u0026gt;\u0026gt;\u0026gt; pi = 3.14 \u0026gt;\u0026gt;\u0026gt; food = \u0026#39;pie\u0026#39; \u0026gt;\u0026gt;\u0026gt; message = ( ... f\u0026#34;Hello, my name is {name}. \u0026#34; ... f\u0026#34;I can calculate pi to two places: {pi:4.3}. \u0026#34; ... f\u0026#34;But I would rather be eating {food}.\u0026#34; ... ) \u0026gt;\u0026gt;\u0026gt; print(message) Hello, my name is Nina. I can calculate pi to two places: 3.14. But I would rather be eating pie. Trimming a string Python strings have some very useful functions for trimming whitespace. strip() returns a new string after removing any leading and trailing whitespace. rstrip() and does the same but only removes trailing whitespace, and lstrip() only trims leading whitespace. We\u0026rsquo;ll print our string inside \u0026gt;\u0026lt; characters to make it clear:\n\u0026gt;\u0026gt;\u0026gt; my_string = \u0026#34; Hello World! \u0026#34; \u0026gt;\u0026gt;\u0026gt; print(f\u0026#34;\u0026gt;{my_string.lstrip()}\u0026lt;\u0026#34;) \u0026gt;Hello World! \u0026lt; \u0026gt;\u0026gt;\u0026gt; print(f\u0026#34;\u0026gt;{my_string.rstrip()}\u0026lt;\u0026#34;) \u0026gt; Hello World!\u0026lt; \u0026gt;\u0026gt;\u0026gt; print(f\u0026#34;\u0026gt;{my_string.strip()}\u0026lt;\u0026#34;) \u0026gt;Hello World!\u0026lt; Note the different spaces inside of the brackets. These functions also accept an optional argument of characters to remove. Let\u0026rsquo;s remove all leading or trailing commas:\n\u0026gt;\u0026gt;\u0026gt; my_string = \u0026#34;Hello World!,,,\u0026#34; \u0026gt;\u0026gt;\u0026gt; print(my_string.strip(\u0026#34;,\u0026#34;)) Hello World! Replacing Characters Strings have a useful function for replacing characters - just call replace() on any string and pass in what you want replace, and what you want to replace it with:\n\u0026gt;\u0026gt;\u0026gt; my_string = \u0026#34;Hello, world!\u0026#34; \u0026gt;\u0026gt;\u0026gt; my_string.replace(\u0026#34;world\u0026#34;, \u0026#34;Nina\u0026#34;) \u0026#39;Hello, Nina!\u0026#39; str.format() and % formatting Python has two older methods for string formatting that you\u0026rsquo;ll probably come across at some point. str.format() is the more verbose older cousin to f-strings - variables appear in brackets in the string but must be passed in to the format() call. For example:\n\u0026gt;\u0026gt;\u0026gt; name = \u0026#34;Nina\u0026#34; \u0026gt;\u0026gt;\u0026gt; print(\u0026#34;Hello, my name is {name}\u0026#34;.format(name=name)) Hello, my name is Nina Note that the variable name inside the string is local to the string - it must be assigned to an outside variable inside the format() call, hence .format(name=name).\n%-formatting is a much older method of string interpolating and isn\u0026rsquo;t used much anymore. It\u0026rsquo;s very similar to the methods used in C/C++. Here, we\u0026rsquo;ll use %s as our placeholder for a string, and pass the name variable in to the formatter by placing it after the % symbol.\n\u0026gt;\u0026gt;\u0026gt; name = \u0026#34;Nina\u0026#34; \u0026gt;\u0026gt;\u0026gt; print(\u0026#34;Hello, my name is %s\u0026#34; % name) Hello, my name is Nina "
},
{
	"uri": "https://pythonianrocketship.github.io/en/01-introduction/",
	"title": "Course Introduction",
	"tags": [],
	"description": "",
	"content": "Learn Python Welcome to Introduction and Intermediate Python.\nCreated by Touhidul Alam Seyam. @Seyamalam1.\nStay up to date with me on LinkedIn, or to contact me directly, please send me an email at eyamalam41@gmail.como.\nYou can find the content and exercises on the Github repo.\nThe course content is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.\nI\u0026rsquo;d like to encourage learning individuals to learn Python from the course material for free, but if you\u0026rsquo;d like to use the material for your own workshop or for commercial use, please consider supporting my work and give me some credit or toss a coin to your witcher.\n"
},
{
	"uri": "https://pythonianrocketship.github.io/en/02-introduction-to-python/020-basic-data-types/00-variables/",
	"title": "Variables and Types",
	"tags": [],
	"description": "",
	"content": "Naming Variables Python variables can\u0026rsquo;t start with a number. In general, they\u0026rsquo;re named all lower case, separated by underscores. Unlike other languages, that name their variables with camelCase.\nYou don\u0026rsquo;t want to name your variables the same as the types that we\u0026rsquo;ll be working with. For example don\u0026rsquo;t name your variables int, list, dict. Etc.\nOpen The REPL Learn about variables by typing along in the Python REPL with me.\nOpen the REPL from VS Code by opening the command palette (ctrl + shift + P on Windows, or cmd + shift + P on Mac) and selecting Python: Start REPL\nAny Python code that starts with the \u0026gt;\u0026gt;\u0026gt; symbols indicates that it was typed into a REPL.\nYou can then use ctrl + ` (backtick) to open and close the VS Code terminal on Mac, or ctrl + \u0026rsquo; (single quote) on Windows. You won\u0026rsquo;t lose your work in the REPL unless you close VS Code.\nIf you\u0026rsquo;d like to save the contents of your REPL as class goes on, you can right click, select all, and paste it into a new file.\nVariables Variables in Python allow us to store information and give it a label that we can use to retrieve that information later. We can use variables to store numbers, strings (a sequence of characters), or even more complex data types like lists and dictionaries.\nWe assign values to variables by putting the value to the right of an equal sign.\nBecause Python is a dynamic language, we don\u0026rsquo;t need to declare the type of the variables before we store data in them.\nThat means that this is valid Python code:\n\u0026gt;\u0026gt;\u0026gt; x = 42 Unlike typed languages, the type of what\u0026rsquo;s contained in Python variables can change at any time.\nFor example, the below is perfectly valid Python code:\n\u0026gt;\u0026gt;\u0026gt; x = 42 \u0026gt;\u0026gt;\u0026gt; x = \u0026#34;hello\u0026#34; Here, the value of the variable x changed from a number to a string.\nWhen creating variables, there are a few best practices you should follow.\nNaming Variables Convention says that variables should be named in lowercase, with whole words separated by underscores.\nIf you want to learn more about Python naming conventions look at PEP8 during a break.\nBecause Python is a dynamic language and you don\u0026rsquo;t have type hints to explain what\u0026rsquo;s stored inside a variable while reading code, you should do your best naming your variables to describe what is stored inside of them.\nIt\u0026rsquo;s ok to be verbose. For example, n is a poor variable name, while numbers is a better one. If you\u0026rsquo;re storing a collection of items, name your variable as a plural.\nLearn more about great naming practices for dynamic types by watching this 30-minute talk by Brandon Rhodes.\nNaming Gotchas There are some things that you can\u0026rsquo;t name your variables, such as and, if, True, or False. That\u0026rsquo;s because Python uses these names for program control structure.\nYou can\u0026rsquo;t start your variable name with a digit, although your variable name can end in a digit. Your variable name can\u0026rsquo;t contain special characters, such as !, @, #, $, % and more.\n💣 Python will let you override built-in methods and types without a warning so don\u0026rsquo;t name your Python variables things like list, str, or int.\nIf you notice your program behaving oddly and you can\u0026rsquo;t find the source of the bug, double check the list of built-in functions and built-in types to make sure that your variable names don\u0026rsquo;t conflict.\nTypes Python has a very easy way of determining the type of something, with the type() function.\n\u0026gt;\u0026gt;\u0026gt; num = 42 \u0026gt;\u0026gt;\u0026gt; type(num) \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; No-Value, None, or Null Value There\u0026rsquo;s a special type in Python that signifies no value at all. In other languages, it might be called Null. In Python, it\u0026rsquo;s called None.\nIf you try to examine a variable on the REPL that\u0026rsquo;s been set to None, you won\u0026rsquo;t see any output. We\u0026rsquo;ll talk more about the None type later in the class.\n\u0026gt;\u0026gt;\u0026gt; x = None \u0026gt;\u0026gt;\u0026gt; x "
},
{
	"uri": "https://pythonianrocketship.github.io/en/01-introduction/00-who/",
	"title": "About Your Instructor",
	"tags": [],
	"description": "",
	"content": "\u0026lt;a href=\u0026ldquo;https://twitter.com/Seyamalam1\" target=\u0026quot;_blank\u0026rdquo;\u0026quot;\u0026gt; @Seyamalam1 Touhidul Alam Seyam Hi, I\u0026rsquo;m Nina Zakharenko. I\u0026rsquo;m a Senior Cloud Developer Advocate at Microsoft, focusing on Python. Before Microsoft, I wrote code for other cool companies like Reddit, Meetup, and HBO. In my spare time I like drinking scotch and tinkering with wearable electronics. I enjoy hiking and snowboarding from my home base in Portland, Oregon. I change my hair color regularly.\nI\u0026rsquo;ve been involved in the Python community for approximately 6 years. During that time I\u0026rsquo;ve spoken at multiple Python conferences on a variety of topics, including PyCon US, PyParis, DjangoCon, and even PyCon Russia in Moscow.\nStay in touch @Seyamalam1 LinkedIn GitHub where you can find the code for this site and my other projects "
},
{
	"uri": "https://pythonianrocketship.github.io/en/01-introduction/02-requirements/05-vs-code/01-getting-started/",
	"title": "Getting Started",
	"tags": [],
	"description": "",
	"content": "Visual Studio Code (commonly called VS Code) is a free, open source, lightweight cross platform code editor. A fresh installation is bare bones \u0026ndash; the power of VS Code comes via the extensions. There are useful extensions for every programming languages you can think of, but the choice of which ones to install and how to configure your editor is up to you.\nInstallation You should have installed the editor and the Python extension as part of the pre-requisites for the course. If you haven\u0026rsquo;t, please do so now as we\u0026rsquo;ll be using VS Code to edit our Python for the rest of the course.\nDownload Visual Studio Code Python Extension for Visual Studio Code Advantages You\u0026rsquo;ll want to use a code editor for your Python projects as your projects grow in scope. It\u0026rsquo;ll allow you to easily manage projects with multiple files and modules. The Python extension also offers a built-in REPL, so that we can quickly and easily test out snippets of code and instantly see the results.\nCode editors also offer syntax highlighting, syntax checking, auto-completion, and more.\nKeyboard Bindings If you prefer keyboard shortcuts from a different editor, such as sublime, vim, or emacs, you can install a key-map extension to remap your keybindings, preferably at the next break.\nChoices We\u0026rsquo;ll be using VS Code for this course so I can show you the ropes, but after class is over you\u0026rsquo;re free to switch to any editor of your choice.\nNote: For the rest of the course, instructions for Mac/Linux terminal and Windows PowerShell terminal should be the same.\nOpening Your First Project Setting Up a Project Structure Now that VS Code is downloaded and installed, it\u0026rsquo;s time to open our project.\nOn Mac OS and Linux, follow these steps in you terminal application, or follow the steps manually in the program you use to manage files.\nRemember, you can copy all the commands by clicking on the clipboard icon () located in the top right section of a code block.\n# change to our home directory $ cd # enter the directory of the pyworkshop folder from the last step $ cd pyworkshop For Mac / Linux:\n# activate the virtual environment $ source env/bin/activate # make a new empty python file called project.py (env) $ touch project.py For Windows:\n# activate the virtual environment \u0026gt; env\\scripts\\activate # make a new empty python file called project.py (env)\u0026gt; fc \u0026gt; project.py Opening a Project in VS Code From The Command Line First, navigate to your project directory and activate your virtual environment. If you followed the previous steps, you should already be in the right directory.\n# Open VS Code using the current directory as a project. (env) $ code . This will open a project in the current directory. This is the last time we\u0026rsquo;ll be using the terminal outside of VS Code for the duration of the course.\nKeyboard Shortcuts To get started with VS Code, you only need to remember two keyboard shortcuts.\n#1 : Show Command Palette Open the command palette with Ctrl+Shift+P on Windows and Linux, and ⌘⇧P (command + shift + P) on Mac OS.\nThe command palette lets you search and run any of the commands available within VS Code. If you don\u0026rsquo;t know how to do something, the command palette will usually point you in the right direction.\nThe command palette is how you\u0026rsquo;ll navigate VS Code.\n#2 : Quick Open, Go to File Open Quick Open with Ctrl+P on Windows and Linux, and ⌘P(command + P) on Mac OS.\nQuick open is how you\u0026rsquo;ll navigate your codebase and files.\nTo dismiss either dialog, press the Escape key.\nWrite these two shortcuts down, because we\u0026rsquo;ll be using them frequently for the rest of the course.\n"
},
{
	"uri": "https://pythonianrocketship.github.io/en/02-introduction-to-python/190-apis/00-requests-and-responses/",
	"title": "Working with APIs",
	"tags": [],
	"description": "",
	"content": " Zapier has an excellent intro to APIs by by Brian Cooksey. The images and diagrams used on this page is from his post. Please read it here.\nRequests and Responses Working with APIs using HTTP depends on the request and response cycle. You send a request to the server, and it lets you know if your request was successful or by sending an HTTP Status Code with a special meaning, and will optionally send back data.\nHTTP Methods The HTTP Method (or verb) is how you tell the server which type of operation you\u0026rsquo;d like to perform.\nGET - Ask the server to get a resource. POST - Ask the server to create a resources, with the data that you\u0026rsquo;ve provided. PUT - Edit or update a resource. DELETE - Delete a resource. Headers, Body, Parameters We can add additional to our request through headers, a body or URL parameters.\nFor today, we\u0026rsquo;ll only be using URL parameters. They look like https://example.com?var1=foo\u0026amp;var2=bar.\nResponse Types Servers can respond in a variety of file formats, like JSON, XML, and others.\nThese days, JSON is the most common format. For many servers, it\u0026rsquo;s the default if you don\u0026rsquo;t specify a response type.\nJSON is a common format of capturing data, and it\u0026rsquo;s easy to read and generate from a variety of programming languages.\nA JSON example:\n[ { \u0026#34;name\u0026#34;: \u0026#34;New York\u0026#34;, \u0026#34;pop\u0026#34;: 8550405 }, { \u0026#34;name\u0026#34;: \u0026#34;Los Angeles\u0026#34;, \u0026#34;pop\u0026#34;: 3971883 }, { \u0026#34;name\u0026#34;: \u0026#34;Chicago\u0026#34;, \u0026#34;pop\u0026#34;: 2720546 }, { \u0026#34;name\u0026#34;: \u0026#34;Houston\u0026#34;, \u0026#34;pop\u0026#34;: 2296224 }, { \u0026#34;name\u0026#34;: \u0026#34;Philadelphia\u0026#34;, \u0026#34;pop\u0026#34;: 1567442 } ] HTTP Status Codes HTTP Status Codes is a numerical response from the sever, indicating the status of your request.\nThey tend to fall into these categories:\n1xx : Informational Not commonly used. 2xx : Success 200 OK - Standard response for successful HTTP requests. 201 CREATED - A new resource was created successfully. 3xx : Redirection 301 Moved Permanently - This and all future requests should be directed to the new URL. 4xx : A Client Error 404 Not Found - An entry wasn\u0026rsquo;t found based on the information the client gave. 5xx : A Server Error 500 Internal Server Error - Something went wrong with the server.\\ Because HTTP Status Codes are boring, we can try to remember them with cats instead! code cat 200: OK 301 Moved Permanently 404 Not Found 500 Internal Server Error Provided by this awesome API.\nEaster Egg - I\u0026rsquo;m a Teapot One of my favorite bits of internet trivia is that in 1998 as an April fool\u0026rsquo;s joke, HTTP Status Code 418 I'm a teapot, a.k.a the Hyper Text Coffee Pot Control Protocol was implemented. You can pass the BREW command to it, to signal starting brewing a cup of coffee.\nAuthentication There are several ways of authenticating to APIs, but they are out of the scope of this class.\nTo learn more about authentication, visit:\n(Concepts) Zapier - Authentication Part 1 andAuthentication Part 2 by Brian Cooksey Using authentication in the requests library documentation. "
},
{
	"uri": "https://pythonianrocketship.github.io/en/01-introduction/02-navigating-course/",
	"title": "Navigating The Course",
	"tags": [],
	"description": "",
	"content": "The course content is free and open source, and hosted on GitHub. A link will be available after the class so that edits can be suggested via Pull Requests.\nSuggesting Changes to The Course Material If you notice a typo or any other issues with the material after the class, please open a pull request on GitHub by clicking the \u0026ldquo;Edit this page\u0026rdquo; button on the top right corner of every course page.\n\u0026lt;img src=\u0026quot;{{\u0026quot;/images/snake-scaled.png\u0026quot; | relURL }}\u0026quot;\u0026gt;\nClearing History of Read Pages Once a section is completed, a check mark will appear to the right of that section. To clear it, hit the \u0026ldquo;Clear History\u0026rdquo; button at the bottom of the table of contents on the left hand side.\nCopying Code To copy code and commands, click on the clipboard icon (() on the top right of any code box.\nYou can even copy code intended for the Python REPL. The prompt characters won\u0026rsquo;t be copied over.\nTry it now by coping the code below.\ndef greeting(): print(\u0026#34;Hello, World!\u0026#34;) Searching The whole course is searchable via the search bar on the top left.\nNavigation View the course contents in the side bar on the left.\nArrows The course can be navigated sequentially to the page before or after via the left and right arrows on each page.\nYou can also use the left and right keyboard arrows to navigate between pages.\nBreadcrumbs Use the breadcrumb links on the floating header of each page to jump between related sections.\nTable of Contents Click on the \u0026ldquo;Table of Contents\u0026rdquo; Icon in the page header to jump between sections in the page.\nExpanding Sections Sometimes additional instructions or information will be available via the expand section arrow. Keep an eye out for this icon:\nThe course material is heavy in information and links. I suggest that you follow the links after class as a source of additional information, so that you don\u0026rsquo;t get distracted from the important material.\n"
},
{
	"uri": "https://pythonianrocketship.github.io/en/02-introduction-to-python/020-basic-data-types/02-numbers/",
	"title": "Numbers",
	"tags": [],
	"description": "",
	"content": "First, open up the REPL.\nRemember, you\u0026rsquo;ll learn best if you type along with me.\nThere are three different types of numbers in Python: int for Integer, Float, and Complex.\n# These are all integers x = 4 y = -193394 z = 0 # These are all floats x = 5.0 y = -3983.2 z = 0. # This is a complex number x = 42j In Python, Integers and other simple data types are just objects under the hood. That means that you can create new ones by calling methods. You can provide either a number, or a string. This will come in handy later on in the course.\nx = int(4) y = int(\u0026#39;4\u0026#39;) z = float(5.0) Python also provides a decimal library, which has certain benefits over the float datatype. For more information, refer to the Python documentation.\nMathematical Operations Numbers can be added together. If you add a float and an int, the resulting type will be a float.\nIf you divide two ints (integers), the result will be of type float.\nBoolean Types In Python, Booleans are of type bool. Surprisingly, the boolean types True and False are also numbers under the hood.\nTrue is 1 under the hood. False is 0 under the hood. That means you can do silly things, like add two Boolean numbers together, but I\u0026rsquo;ll cover why this is a useful Python feature later in the course.\n"
},
{
	"uri": "https://pythonianrocketship.github.io/en/02-introduction-to-python/010-best-practices/02-brief-history/",
	"title": "About Python 🐍",
	"tags": [],
	"description": "",
	"content": "What is Python? Python is a programming language created by Guido Van Rossum in the late 1980s.\nYou might be surprised to learn that Python is 30 years old!\nWhere is it used? A common misconception is that Python is a scripting language. It\u0026rsquo;s used at companies from Reddit, to Netflix, to Dropbox.\nWhat\u0026rsquo;s all this about Python 2 vs Python 3 This part is a bit of a stain on Python\u0026rsquo;s history. Python 3 was released 2008, and its adoption was slow. First and foremost because it took popular packages a fair amount of time to port over their code.\nThis debate is now over. Python 2 will reach end-of-life in 2020, meaning that important updates - including security updates - will stop being released. That\u0026rsquo;s why this course focuses on Python3 only.\nWhy Python? Python the language is open source.\nPython has a wide variety of applications such as:\nAI/ML SciPi NumPy Pandas PyTorch Hardware \u0026amp; Micro-controllers Raspberry Pi MicroPython CircuitPython Web Development Django Flask Scripting DevOps Configuration scripts Python has an incredibly rich fully featured standard library, as well as the PyPI Package Index for 3rd party packages, which as of February 2019 contains 167,107 packages.\nPython is considered to be a \u0026ldquo;batteries included\u0026rdquo; language, because the standard library contains a majority of the libraries and packages you\u0026rsquo;ll need in a standard application.\nContinuing In The Community The absolute best part about Python is the incredibly supportive community.\nThe biggest yearly conference is PyCon US with approximately 4000 attendees.\nThere are many local user groups worldwide, with many listed on this wiki.\nThere are many supportive groups for women and non-binary developers, such as PyLadies and DjangoGirls. These organizations have chapters in most major cities.\n"
},
{
	"uri": "https://pythonianrocketship.github.io/en/02-introduction-to-python/",
	"title": "Intro to Python",
	"tags": [],
	"description": "",
	"content": "Day 1 An Introduction to Python Let\u0026rsquo;s talk about the anatomy of a Python program, along with Python best practices like naming and commenting.\nToday you\u0026rsquo;ll be learning all the foundational basics of Python. How to work with different data types, the Python control structures, best practices, and lastly an exercise in interacting with APIs.\nDay 1 Overview By coding along with me in this workshop, you\u0026rsquo;ll:\nYou’ll learn about the origins of Python, and how it can help you solve complex problems quickly. Learn about the different data types Python has to offer, including tips on when and how to use each one. Understand the control flow of Python programs - loops, boolean statements, if statements, and return statements. Make your code more concise by writing reusable functions. Learn to use Python packages from the standard library, as well as how to find and install external libraries. Learn how to work with files on your filesystem by reading and writing to them. Write programs that interact with APIs by sending requests and receiving responses. "
},
{
	"uri": "https://pythonianrocketship.github.io/en/02-introduction-to-python/190-apis/00-the-requests-library/",
	"title": "Using The Requests Library",
	"tags": [],
	"description": "",
	"content": "What is The requests Library? Python is \u0026ldquo;batteries included\u0026rdquo;, but sometimes the included libraries available in the standard library can be hard to understand. The standard library focuses on functionality, but not necessarily ease of use.\nThat\u0026rsquo;s where external libraries come in. The external requests library was developed by Kenneth Reitz to make working with APIs in Python a lot easier. He calls it \u0026ldquo;HTTP, for humans.\u0026rdquo; It\u0026rsquo;s become of the (if not the most) popular Python library!\nOur First Request With The requests Library If you didn\u0026rsquo;t install the requests library in the working with libraries chapter, you\u0026rsquo;ll need to do that first before running this code. Use: python -m pip install requests\nLet\u0026rsquo;s make a request to shibe.online to get ourselves some dog pictures. Create a file called shibe.py in our pyworkshop directory and copy this:\n# First thing we\u0026#39;ll do is import the requests library import requests # Define a variable with the URL of the API api_url = \u0026#34;http://shibe.online/api/shibes?count=1\u0026#34; # Call the root of the api with GET, store the answer in a response variable # This call will return a list of URLs that represent dog pictures response = requests.get(api_url) # Get the status code for the response. Should be 200 OK # Which means everything worked as expected print(f\u0026#34;Response status code is: {response.status_code}\u0026#34;) # Get the result as JSON response_json = response.json() # Print it. We should see a list with one image URL. print(response_json) (env) $ python shibe.py Response status code is: 200 [\u0026#39;https://cdn.shibe.online/shibes/28d7c372ea7defdb315ef845285d4ac3906ccea4.jpg\u0026#39;] Dealing with Errors When dealing with HTTP requests, your first indication of error is usually the HTTP status code. You saw some of the common status codes in the last chapter. The most common status codes are probably 200 - Success, and 404 - Not found. You can find the status code in the status_code property of the response object:\n# Passing in a non-existant URL will result in a 404 (not found) bad_response = requests.get(\u0026#34;http://shibe.online/api/german-shepards\u0026#34;) print(f\u0026#34;Bad Response Status Code is: {bad_response.status_code}\u0026#34;) # Status code is 404, meaning that resource doesn’t exist. Passing in Parameters # We\u0026#39;ll store our base URL here and pass in the count parameter later api_url = \u0026#34;http://shibe.online/api/shibes\u0026#34; params = { \u0026#34;count\u0026#34;: 10 } # Pass those params in with the request. api_response = requests.get(api_url, params=params) print(f\u0026#34;Shibe API Response Status Code is: {api_response.status_code}\u0026#34;) # should be 200 OK json_data = api_response.json() print(\u0026#34;Here is a list of URLs for dog pictures:\u0026#34;) for url in json_data: print(f\u0026#34;\\t {url}\u0026#34;) $ shibe.py Shibe API Response Status Code is: 200 Here is a list of URLs for dog pictures: https://cdn.shibe.online/shibes/dfb2af0b2ac1f057750da32f0ea0e154afc160cf.jpg https://cdn.shibe.online/shibes/4989daad2c805ec62b0fb09a80280ba2262f1b08.jpg https://cdn.shibe.online/shibes/a9360b8262c586af2cf53a2d68bb6ec34b87fe25.jpg https://cdn.shibe.online/shibes/a168cc7f2524c73b433afd7c02f698884738daff.jpg https://cdn.shibe.online/shibes/3fbe49908948718c521b756f31dc155ed22941f6.jpg https://cdn.shibe.online/shibes/846bb52389cf9af8a54eb12f48e0e7d0883b17da.jpg https://cdn.shibe.online/shibes/d11ed7f57c5a882f047b921a73f0b95714626bb3.jpg https://cdn.shibe.online/shibes/0fd1dcc9f5866cefaa3040de1be0f8971b0530cd.jpg https://cdn.shibe.online/shibes/cd668ca05d0ec78863f3c30b08b9cd4ff7f5669c.jpg https://cdn.shibe.online/shibes/32bf0797e5a4c5bfb6fc06edc57ddfbf4e08f98f.jpg More about requests To learn more about the requests library after class, look at the quick start.\n"
},
{
	"uri": "https://pythonianrocketship.github.io/en/03-intermediate-python/70-tests/30-assertions/",
	"title": "Assertions",
	"tags": [],
	"description": "",
	"content": "Python comes with a handy-dandy assert keyword that you can use for simple sanity checks. An assertion is simply a boolean expression that checks if its conditions return true or not. If the assertion is true, the program continues. If it\u0026rsquo;s false, it throws an AssertionError, and your program will stop. Assertions are also a great debugging tool, as they can stop your program in exactly the spot where an error has occurred. This is great for rooting out unreliable data or faulty assumptions.\nTo make an assertion, just use the assert keyword followed by a condition that should be True:\n\u0026gt;\u0026gt;\u0026gt; input_value = 25 \u0026gt;\u0026gt;\u0026gt; assert input_value \u0026gt; 0 If our assertion fails, however:\n\u0026gt;\u0026gt;\u0026gt; input_value = 25 \u0026gt;\u0026gt;\u0026gt; assert input_value \u0026gt; 100 Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; AssertionError assert Is For Sanity Checks, Not For Production! Assertions are great for simple self-checks and sanity tests. You shouldn\u0026rsquo;t, however, use assertions for failure cases that can occur because of bad user input or operating system/environment failures, such as a file not being found. These situations are much better suited to an exception or an error message.\nAssertions can be disabled at run time, by starting the program with python -O, so you shouldn\u0026rsquo;t rely on assertions to run in production code. Don\u0026rsquo;t use them for validation!\n"
},
{
	"uri": "https://pythonianrocketship.github.io/en/03-intermediate-python/30-oop-classes-inheritance/30-classes/",
	"title": "Classes",
	"tags": [],
	"description": "",
	"content": "Every thing or object in Python is an instance of a class. The number 42 is an instance of the class int. The string Hello, world is an instance of the str (or string) class. These classes, in turn, are subclasses of the master object class.\nClasses vs Instances The Object-oriented Programming paradigm is structured around Classes and Instances. You can think of a class as a \u0026ldquo;type\u0026rdquo; of something, like \u0026ldquo;Car.\u0026rdquo; You can think of an instance as a specific thing, such as \u0026ldquo;my Subaru,\u0026rdquo; which is a type of \u0026ldquo;Car.\u0026rdquo; Both classes and instances can have variables and methods. Changing a class variable will change what is returned when you get that variable from an instance, however changing an instance variable only applies to that one instance. We\u0026rsquo;ll come back to this in a second.\nself You might have seen the self keyword peppered around in examples of Python objects. self is used inside classes to refer to a bound instance variable or object. For example, let\u0026rsquo;s say we have a class called Car:\nclass Car: runs = True def start(self): if self.runs: print(\u0026#34;Car is started. Vroom vroom!\u0026#34;) else: print(\u0026#34;Car is broken :(\u0026#34;) Now, let\u0026rsquo;s make a specific instance of our Car class and call the start() method on it to see if it starts.\n\u0026gt;\u0026gt;\u0026gt; my_car = Car() \u0026gt;\u0026gt;\u0026gt; my_car.runs True \u0026gt;\u0026gt;\u0026gt; my_car.start() Car is started. Vroom vroom! We can see that the runs variable of our my_car instance is True. Now, what if we set runs to False?\n\u0026gt;\u0026gt;\u0026gt; my_car.runs = False \u0026gt;\u0026gt;\u0026gt; my_car.start() Car is broken :( But if we make a new instance of the Car class\u0026hellip;\n\u0026gt;\u0026gt;\u0026gt; my_other_car = Car() \u0026gt;\u0026gt;\u0026gt; my_other_car.start() Car is started. Vroom vroom! When we run the start() function, the self keyword points to the bound instance of Car - so when we call start() on my_car, self points to my_car and sees an instance variable runs that is False, but when we call my_other_car.start(), it returns True. Why?\nself refers to an instance Back to what we were saying in the last section, runs is a class variable on the Car class, meaning that it exists for all instances of type Car. When we set runs to False, we created an instance variable on my_car, and when we called start(), self told the interpreter to look for an instance variable in my_car called runs.\nWhen we called my_other_car.start(), the interpreter looked for an instance variable called runs, but didn\u0026rsquo;t find it, so it looked at the next level up, the class, and found the class variable Car.runs, which returned True.\nYou may have noticed, but all instance methods within classes take self as their first argument, such as def start(self): above.\nWhat happens if we call start() on the Car class instead of an instance?\n\u0026gt;\u0026gt;\u0026gt; Car.start() Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; TypeError: start() missing 1 required positional argument: \u0026#39;self\u0026#39; If you try to call start() on the Car class, self doesn\u0026rsquo;t have an instance to bind to, so we get an error that the required argument self wasn\u0026rsquo;t passed in to the start() function.\n"
},
{
	"uri": "https://pythonianrocketship.github.io/en/03-intermediate-python/60-command-line-tools/30-accepting-user-input/",
	"title": "Accepting User Input",
	"tags": [],
	"description": "",
	"content": "Accepting Command Line Arguments To accept basic arguments from the command line, we can use sys.argv. argv is a list that gets passed in to your program that contains whatever arguments your program was started with. Start a new Python file called cli_exercise.py and enter the following:\nimport sys args = sys.argv print(args) Now run it:\n(env) $ python cli_exercise.py [\u0026#39;cli_exercise.py\u0026#39;] You should see a list with one item: the name of your program. Pass in additional arguments by adding them after your program name on the command line, separated by spaces:\npython cli_exercise.py argument1 argument2 \u0026#34;hello world\u0026#34; [\u0026#39;cli_exercise.py\u0026#39;, \u0026#39;argument1\u0026#39;, \u0026#39;argument2\u0026#39;, \u0026#39;hello world\u0026#39;] Note that the name of the file you\u0026rsquo;re running is rarely useful, so it\u0026rsquo;s common to see this omitted with using slices, for example sys.argv[1:]\nsys.argv is never empty - the first element in the list will always be the name of the Python file you\u0026rsquo;re running.\nAccepting User Input with input You can also accept user data inside a running program by using input(). Let\u0026rsquo;s make a simple interactive command line program that asks for a user\u0026rsquo;s name and birthday:\nname = input(\u0026#34;Hello, what is your name? \u0026#34;) birthday_string = input(f\u0026#34;Hello {name}. Please enter your birthday in MM/DD/YYYY format: \u0026#34;) print(f\u0026#34;Hello {name}. Your birthday is on {birthday_string}.\u0026#34;) (env) $ python cli_exercise.py Hello, what is your name? Floyd Hello Floyd. Please enter your birthday in MM/DD/YYYY format: 01/20/1990 Hello Floyd. Your birthday is on 01/20/1990. "
},
{
	"uri": "https://pythonianrocketship.github.io/en/03-intermediate-python/50-libraries-modules/30-modules-and-imports/",
	"title": "Modules and Imports",
	"tags": [],
	"description": "",
	"content": "Python has a simple package structure. Any directory with a file named __init__.py can be considered a Python module.\nNote: a __init__.py file is no longer required for Python 3 modules, but it\u0026rsquo;s still supported and can be useful.\nFor example, let\u0026rsquo;s make a basic function and start a new module to house it:\ndef add_numbers(x, y): return x + y Let\u0026rsquo;s put our function in a file called __init__.py and place it in a folder called my_math_functions. Now, as long as the folder my_math_functions is somewhere in our PYTHONPATH, we can import my_math_functions and reach add_numbers(). If we start our REPL from the folder that contains my_math_functions, we can import it:\n\u0026gt;\u0026gt;\u0026gt; import my_math_functions \u0026gt;\u0026gt;\u0026gt; my_math_functions.add_numbers(1, 2) 3 Best Practices There a few different ways to import modules or even just specific objects from modules. You can import everything from a module into the local namespace using *:\n\u0026gt;\u0026gt;\u0026gt; from my_math_functions import * \u0026gt;\u0026gt;\u0026gt; add_numbers(1, 2) 3 This isn\u0026rsquo;t a good practice, because it\u0026rsquo;s hard to tell where a specific function is coming from without the namespace context. Also, function names can conflict, and this can make things very difficult to debug.\nBetter is to import functions specifically:\n\u0026gt;\u0026gt;\u0026gt; from my_math_functions import add_numbers \u0026gt;\u0026gt;\u0026gt; add_numbers(1, 2) 3 This make things a little clearer, as we can look at the top and see where the add_number() function came from. However, an even better way is to just import the module and use it in calls to maintain the namespace context:\n\u0026gt;\u0026gt;\u0026gt; import my_math_functions \u0026gt;\u0026gt;\u0026gt; my_math_functions.add_numbers(1, 2) 3 This can be slightly more verbose, but unless it makes your function calls ridiculously long, it generally makes things much easier to debug.\nYou can use the as keyword to make things a little easier on yourself.\n\u0026gt;\u0026gt;\u0026gt; import my_math_functions as mmf \u0026gt;\u0026gt;\u0026gt; mmf.add_numbers(1, 2) 3 PYTHONPATH What is the PYTHONPATH we mentioned earlier? This is a list of paths on your system where Python will look for packages. Python will always look first in the working directory (the folder you\u0026rsquo;re in when you start the REPL or run your program), so if your module folder is there, you can import it. You can also install your modules just like any other external modules, using a setup.py file. It\u0026rsquo;s also possible to change or add paths to your PYTHONPATH list if you need to store modules elsewhere, but this isn\u0026rsquo;t a very portable solution.\n"
},
{
	"uri": "https://pythonianrocketship.github.io/en/03-intermediate-python/40-exceptions/30-try-except-else-finally/",
	"title": "Try Except",
	"tags": [],
	"description": "",
	"content": "Many languages have the concept of the \u0026ldquo;Try-Catch\u0026rdquo; block. Python uses four keywords: try, except, else, and finally. Code that can possibly throw an exception goes in the try block. except gets the code that runs if an exception is raised. else is an optional block that runs if no exception was raised in the try block, and finally is an optional block of code that will run last, regardless of if an exception was raised. We\u0026rsquo;ll focus on try and except for this chapter.\nA basic example looks like this:\n\u0026gt;\u0026gt;\u0026gt; try: ... x = int(input(\u0026#34;Enter a number: \u0026#34;)) ... except ValueError: ... print(\u0026#34;That number was invalid\u0026#34;) First, the try clause is executed. If no exception occurs, the except clause is skipped and execution of the try statement is finished. If an exception occurs in the try clause, the rest of the clause is skipped. If the exception\u0026rsquo;s type matches the exception named after the except keyword, then the except clause is executed. If the exception doesn\u0026rsquo;t match, then the exception is unhandled and execution stops.\nThe except Clause An except clause may have multiple exceptions, given as a parenthesized tuple:\ntry: # Code to try except (RuntimeError, TypeError, NameError): # Code to run if one of these exceptions is hit A try statement can also have more than one except clause:\ntry: # Code to try except RuntimeError: # Code to run if there\u0026#39;s a RuntimeError except TypeError: # Code to run if there\u0026#39;s a TypeError except NameError: # Code to run if there\u0026#39;s a NameError Finally Finally, we have finally. finally is an optional block that runs after try, except, and else, regardless of if an exception is thrown or not. This is good for doing any cleanup that you want to happen, whether or not an exception is thrown.\n\u0026gt;\u0026gt;\u0026gt; try: ... raise KeyboardInterrupt ... finally: ... print(\u0026#34;Goodbye!\u0026#34;) ... Goodbye! Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 2, in \u0026lt;module\u0026gt; KeyboardInterrupt As you can see, our Goodbye! gets printed just before the unhandled KeyboardInterrupt gets propagated up and triggers the traceback.\n"
},
{
	"uri": "https://pythonianrocketship.github.io/en/03-intermediate-python/20-advanced-looping/30-other-comprehensions/",
	"title": "Other Comprehensions",
	"tags": [],
	"description": "",
	"content": "Dictionary Comprehensions Dictionary comprehensions are a quick and easy way of assembling dictionaries in Python. They work just like list comprehensions, and look almost the same. They use curly braces instead of square brackets, and they contain two variables (for key and value), separated by a colon.\nFor example, to assemble a dict in which the keys are numbers between 0 and 10, and the values are the same number squared, we could do:\n\u0026gt;\u0026gt;\u0026gt; squares = {num:num * num for num in range(10)} \u0026gt;\u0026gt;\u0026gt; print(squares) {0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81} Or we could use f-strings to assemble a dict to keep game scores:\n\u0026gt;\u0026gt;\u0026gt; scores = {f\u0026#34;player-{num}\u0026#34;:0 for num in range(0, 5)} \u0026gt;\u0026gt;\u0026gt; print(scores) {\u0026#39;player-0\u0026#39;: 0, \u0026#39;player-1\u0026#39;: 0, \u0026#39;player-2\u0026#39;: 0, \u0026#39;player-3\u0026#39;: 0, \u0026#39;player-4\u0026#39;: 0} In the above example, the f-string gets turned into the dict keys (player-0, etc.) and each value is set to 0. You can also operate on tuples for setting keys and values. For example, we\u0026rsquo;ll use a list comprehension to create a list of tuples, then turn the tuples into dict keys and values:\n\u0026gt;\u0026gt;\u0026gt; my_list = [(f\u0026#34;player-{num}\u0026#34;, num * 2) for num in range(0, 5)] \u0026gt;\u0026gt;\u0026gt; print(my_list) [(\u0026#39;player-0\u0026#39;, 0), (\u0026#39;player-1\u0026#39;, 2), (\u0026#39;player-2\u0026#39;, 4), (\u0026#39;player-3\u0026#39;, 6), (\u0026#39;player-4\u0026#39;, 8)] \u0026gt;\u0026gt;\u0026gt; scores = {key:value for (key, value) in my_list} \u0026gt;\u0026gt;\u0026gt; print(scores) {\u0026#39;player-0\u0026#39;: 0, \u0026#39;player-1\u0026#39;: 2, \u0026#39;player-2\u0026#39;: 4, \u0026#39;player-3\u0026#39;: 6, \u0026#39;player-4\u0026#39;: 8} Set Comprehensions Set comprehensions are another great operation in Python - they look like a cross between list and dict comprehensions, and they create set objects.\nFor example:\n\u0026gt;\u0026gt;\u0026gt; my_set = {num for num in [1, 2, 1, 0, 3]} \u0026gt;\u0026gt;\u0026gt; print(my_set) {0, 1, 2, 3} Notice that instead of returning the same list of numbers (as num for num would have done in a list comprehension), you instead get a set (note the curly braces) of unique numbers from the list (you only get one 1).\nGenerator Expressions Generator expressions are a little more advanced. A generator is a type of iterable object - like a list, you can iterate through each element - however, unlike a list, generators evaluate elements on demand, instead of assembling them all at once.\nA generator comprehension looks just like a list comprehension, except we use parenthesis instead of brackets. For example, to get a list of the square of every even number between 0 and 10, we could do:\n# List comprehension \u0026gt;\u0026gt;\u0026gt; list_comp = [x ** 2 for x in range(10) if x % 2 == 0] \u0026gt;\u0026gt;\u0026gt; print(list_comp) [0, 4, 16, 36, 64] # Generator expression \u0026gt;\u0026gt;\u0026gt; gen_exp = (x ** 2 for x in range(10) if x % 2 == 0) \u0026gt;\u0026gt;\u0026gt; print(gen_exp) \u0026lt;generator object \u0026lt;genexpr\u0026gt; at 0x10d48cc00\u0026gt; \u0026gt;\u0026gt;\u0026gt; for num in gen_exp: ... print(num) ... 0 4 16 36 64 Generator comprehensions can be beneficial in circumstances where you want to iterate over very large lists without storing the entire list in memory. For example, if you tried to assemble a list of every number between 0 and 10 ** 8 (10 to the 8th power), Python will try to assemble the entire list in memory. Using the timeit library to create this list only once, we can see how long this takes:\n\u0026gt;\u0026gt;\u0026gt; list_comp = \u0026#34;[num for num in range(0, 10 ** 8)]\u0026#34; \u0026gt;\u0026gt;\u0026gt; import timeit \u0026gt;\u0026gt;\u0026gt; timeit.timeit(list_comp, number=1) 7.578090285999998 # Over 7 seconds just to assemble one huge list # Let\u0026#39;s do the same with a generator comprehension instead: \u0026gt;\u0026gt;\u0026gt; gen_comp = \u0026#34;(num for num in range(0, 10 ** 8))\u0026#34; \u0026gt;\u0026gt;\u0026gt; timeit.timeit(gen_comp, number=1) 9.919999996554907e-06 \u0026gt;\u0026gt;\u0026gt; timeit.timeit(gen_comp, number=10000000) 7.211805443999992 As you can see, assembling the generator is almost instantaneous, in fact we can run the generator expression over 10 million times in less time than it takes to assemble the full list once, and the generator will take far less memory.\n"
},
{
	"uri": "https://pythonianrocketship.github.io/en/03-intermediate-python/10-introduction/00-python-philosophy/",
	"title": "Python Philosophy",
	"tags": [],
	"description": "",
	"content": "The Zen of Python is a collection of 19 software principles written in a poem that influences the design of Python Programming Language. It was published on the Python mailing list in June 1999 by Tim Peters. *\nZen of Python in The Python Interpreter The Zen of Python is included as an easter egg in the Python REPL. You can read it by typing import this in our REPL, to learn a little more about the principles and philosophy behind Python.\n\u0026gt;\u0026gt;\u0026gt; import this The Zen of Python, by Tim Peters Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. Flat is better than nested. Sparse is better than dense. Readability counts. Simple is Better Than Complex Generally, Python programmers prefer to be explicit and write simple, understandable, and maintainable code instead of ego flexing and writing unnecessarily complex code.\nReadability Counts Make your code easy to read. Avoid single character variable names. Call your functions with named parameters where applicable. Use good variable names.\nMore Easter Eggs To see another Python easter egg, type the following into your REPL: from __future__ import braces\nYou\u0026#39;ll see the following: 🤣 \u0026gt;\u0026gt;\u0026gt; from __future__ import braces File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1 SyntaxError: not a chance My favorite Easter Egg? Type import antigravity into the REPL.\n"
},
{
	"uri": "https://pythonianrocketship.github.io/en/03-intermediate-python/",
	"title": "Intermediate Python",
	"tags": [],
	"description": "",
	"content": "Day 2 Intermediate Python During day two, we\u0026rsquo;ll start getting more comfortable with some of the more advanced aspects of Python, like classes, list comprehensions, and the standard library. At the end of the day, you\u0026rsquo;ll know enough to build a small interactive API using the Flask web framework.\nTo fully participate in todays class, you must have VS Code set up locally, along with Python version \u0026gt;= 3.7. You must be familiar with all the concepts from Day 1, including running Python programs, simple and complex types, boolean logic, control statements, and looping. If you\u0026rsquo;re not sure, start with Day 1.\nDay 2 Overview By coding along with me in this workshop, you\u0026rsquo;ll:\nUse object-oriented programming to organize your code. Diagnose problems in your Python programs by understanding Exceptions. Work with new features in Python3 that make Python easier than ever, such as f-strings. Learn about generators, a Python feature that allows you to loop over large data sets in a memory efficient way. Learn how to build interactive APIs and websites efficiently using the Flask web framework. "
},
{
	"uri": "https://pythonianrocketship.github.io/en/02-introduction-to-python/010-best-practices/03-conventions/",
	"title": "Conventions",
	"tags": [],
	"description": "",
	"content": "PEP8 PEP8 is a Python coding standard, that sets guidelines for how our Python code should look like.\n"
},
{
	"uri": "https://pythonianrocketship.github.io/en/01-introduction/02-requirements/",
	"title": "Requirements",
	"tags": [],
	"description": "",
	"content": " You\u0026rsquo;ll need a few mandatory prerequisites for successfully participating in the course.\nA Linux, Mac OS, a Windows 10 Machine Python3.7 Visual Studio Code The Python Extension for Visual Studio Code Additional Instructions For Windows Users Note: Always select \u0026ldquo;Allow this app to make changes to your device\u0026rdquo; during the installation process. On the last page of the Python 3 installer, select \u0026ldquo;Disable Path Limit\u0026rdquo; before hitting close. In the start menu, right click on \u0026ldquo;Windows PowerShell\u0026rdquo;. Select \u0026ldquo;Run as an administrator\u0026rdquo; In the PowerShell terminal window, that opens, type: (\u0026gt; means prompt, don\u0026rsquo;t type that in)\n\u0026gt; Set-ExecutionPolicy -ExecutionPolicy RemoteSigned Then, type Y for Yes.\nKeep this window open for the following steps to create a virtual environment!\nDownloads Download Python3 Download Visual Studio Code Python Extension for Visual Studio Code Making sure you\u0026rsquo;re ready To make sure you have all the prerequisites properly installed:\nChecking for Python 3.7 For Windows Using the same PowerShell window from earlier, type:\n\u0026gt; py -3.7 This should open a REPL window with a prompt.\nPress Ctrl + Z followed by Enter to exit this screen and go back to your prompt.\nFor Mac / Linux Type the following on your terminal.\n$ python3 --version You should see\nPython 3.7.2 If you don\u0026rsquo;t see a Python version greater than 3.7, please follow the instructions for installing Python3 again.\nCreating a Virtual Environment and The Project Folder A Virtual Environment in Python is a self-contained directory that contains a Python installation for a particular version of the language.\nIt\u0026rsquo;s a very useful way to make sure that we\u0026rsquo;re using the right Python version when we\u0026rsquo;re working on a particular project.\nLet\u0026rsquo;s create a project directory and a Python 3.7 Virtual Environment.\nFor Windows Using the same PowerShell terminal from earlier, type the following commands in one by one:\n\u0026gt; cd $home \u0026gt; mkdir pyworkshop \u0026gt; cd pyworkshop \u0026gt; py -3 -m venv env \u0026gt; env\\scripts\\activate Your prompt should now look like this, but with your own username.\n(env) PS C:\\Users\\nina\\pyworkshop\u0026gt; env\\scripts\\activate is how you activate your virtual environment in Windows. You\u0026rsquo;ll want to do that each time you enter this Python project directory from a new shell.\nFor Mac / Linux Open a terminal window. Type the following.\n(Do not type the $ character, that signifies a prompt.)\n$ cd $ mkdir pyworkshop $ cd pyworkshop $ python3.7 -m venv env $ source env/bin/activate source env/bin/activate is how you activate your virtual environment on Mac or Linux. You\u0026rsquo;ll want to do that each time you enter this Python project directory from a new shell.\nYour prompt will look like this to indicate that the virtual environment is active.\n(env) $ You are expected to work from this project folder for the duration of the class, with an activated virtual environment.\nChecking VS Code Look for VS Code in your Applications, or type the following in your Mac/Linux or Powershell terminal.\n$ code --version You should see something like:\n1.32.3 a3db5be9b5c6ba46bb7555ec5d60178ecc2eaae4 x64 If you don\u0026rsquo;t see VS Code, please follow the instructions for installing VS Code again.\nNote that after the course you can use the IDE of your choice to continue on your Python adventure.\n"
},
{
	"uri": "https://pythonianrocketship.github.io/en/02-introduction-to-python/020-basic-data-types/03-strings/",
	"title": "Strings",
	"tags": [],
	"description": "",
	"content": "Representing Strings Strings in Python can be enclosed either with single quotes like 'hello' or double quotes, like \u0026quot;hello\u0026quot;.\nStrings can also be concatenated (added together) using the + operator to combine an arbitrary number of Strings. For example:\nsalutation = \u0026#34;Hello \u0026#34; name = \u0026#34;Nina\u0026#34; greeting = salutation + name # The value of greeting will be \u0026#34;Hello Nina\u0026#34; To use the same type of quote within a string, that quote needs to be escaped with a \\ - backwards slash.\ngreeting = \u0026#39;Hello, it\\\u0026#39;s Nina\u0026#39; Alternately, mixed quotes can be present in a Python string without escaping.\n# Notice that the single quote \u0026#39; is surrounded by # double quotes, \u0026#34;\u0026#34; greeting = \u0026#34;Hello, it\u0026#39;s Nina\u0026#34; Long multi-line strings can be represented in between \u0026quot;\u0026quot;\u0026quot; (triple quotes), but the whitespace will be part of the string.\nlong_greeting = \u0026#34;\u0026#34;\u0026#34; Greetings and salutations, dear Nina. I\u0026#39;m superfluous with my words, and require more space to say Hello!\u0026#34; \u0026#34;\u0026#34;\u0026#34; Printing Strings Strings can be printed out using the print() function in Python. While you\u0026rsquo;re working the REPL, you\u0026rsquo;ll see that variables are displayed for you. When you move on to writing standalone Python programs, that will no longer be the case.\nTo use the print() function, call it with a regular or formatted string.\n\u0026gt;\u0026gt;\u0026gt; print(\u0026#34;Hello\u0026#34;) Hello \u0026gt;\u0026gt;\u0026gt; name = \u0026#34;Nina\u0026#34; \u0026gt;\u0026gt;\u0026gt; print(name) Nina String Formatting There are several types of string formatting in Python.\nIf you\u0026rsquo;re using Python 3.7 and above (remember to check with python --version on the command line) you can use my favorite type of string formatting, and the one I\u0026rsquo;ll be using for the course called f-strings.\n\u0026gt;\u0026gt;\u0026gt; name = \u0026#34;Nina\u0026#34; \u0026gt;\u0026gt;\u0026gt; greeting = f\u0026#34;Hello, {name}\u0026#34; \u0026gt;\u0026gt;\u0026gt; print(greeting) Hello, Nina f-strings allow you to simply and easily reference variables in your code, and as a bonus, they\u0026rsquo;re much faster.\n"
},
{
	"uri": "https://pythonianrocketship.github.io/en/01-introduction/02-requirements/05-vs-code/03-working-with-python/",
	"title": "Working With Python",
	"tags": [],
	"description": "",
	"content": " Once we open our first Python file in VS Code, we\u0026rsquo;ll see some configuration pop-ups. For the time being, don\u0026rsquo;t dismiss them.\nConfiguring VS Code for Python Open the project.py file If you haven\u0026rsquo;t created a project.py file in the pyworkshop directory, now is the time to do so. You can make a new file (Ctrl+N or ⌘P) and then save it (Ctrl+S or ⌘S).\nNow that you\u0026rsquo;ve learned the necessary keyboard shortcuts, use Quick Open with Ctrl+P or ⌘P to open the project.py file.\nIf you haven\u0026rsquo;t installed the Python extension at this point, you\u0026rsquo;ll get a pop-up recommending you install it for this type of file. Please install it now, and reload VS Code when prompted to load the extension.\nConfiguring The Interpreter Many operating systems include Python, but unfortunately it\u0026rsquo;s usually a few versions behind.\nWe never want to use Python2 for new Python projects, and we want to make sure we select the latest version of Python3 that we installed in the pre-requisites.\nLuckily, VS Code is smart. If you launch it from a directory with an activated virtual environment, it\u0026rsquo;ll automatically pick up the correct interpreter.\nIn case you need to configure the interpreter manually, follow these (optional) instructions. Click on the Select Python Interpreter button in the popup.\nNote: If dismissed the popup, open the command palette and select Python: Select Interpreter. Expand this section for more details. \u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;expand-content\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt; \u0026lt;p\u0026gt;\u0026lt;img alt=\u0026quot;Interpreter 2\u0026quot; src=\u0026quot;/01-introduction/02-requirements/05-vs-code/images/interpreter.2.png?classes=shadow,border\u0026quot;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; Select the version of Python 3 in your virtual environment env folder as your interpreter. If you open a Python file in a new directory, you may need to select your interpreter again.\nYou can always see what your interpreter is set to on the left side of the status bar at the bottom of the window.\nSetting Up a Linter Per the VS Code documentation, linting highlights syntactical and stylistic problems in your Python source code. A linter will give you code hints about a variety of different types of problems. For example, when you have subtle errors in your code, like trying to use a variable you haven\u0026rsquo;t defined yet. A linter will also show you when you\u0026rsquo;re not following Python style convention called PEP8. PEP8 is a set of defined rules for how Python code should look. We\u0026rsquo;ll cover it in more depth later, but what you need to know right now is that PEP8 warnings are not syntax errors. If your code doesn\u0026rsquo;t adhere to the PEP8 standard, it will still run.\nBy default the linter will run every time you save a file, so it\u0026rsquo;s good practice to save often with (Ctrl+S or ⌘S).\nLet\u0026rsquo;s go ahead and click install on the Linter popup.\nNote: If you accidentally dismissed the popup, open the command palette and search for Python: Select Linter, then select pylint. The popup will now reappear, and you can hit install. Expand this section for more details. "
},
{
	"uri": "https://pythonianrocketship.github.io/en/02-introduction-to-python/010-best-practices/01-anatomy-of-a-python-program/",
	"title": "Anatomy of a Python Program",
	"tags": [],
	"description": "",
	"content": "Let\u0026rsquo;s take a very quick look at a Python program that uses the GitHub Search API to display a list of popular repositories in three different programming languages, sorted by the amount of stars that they have. It may be hard to believe, but by the end of the day, you\u0026rsquo;ll be able to write a program just like this.\nA Python program for using the GitHub search API \u0026#34;\u0026#34;\u0026#34; A small Python program that uses the GitHub search API to list the top projects by language, based on stars. \u0026#34;\u0026#34;\u0026#34; import requests GITHUB_API_URL = \u0026#34;https://api.github.com/search/repositories\u0026#34; def create_query(languages, min_stars=50000): query = f\u0026#34;stars:\u0026gt;{min_stars} \u0026#34; for language in languages: query += f\u0026#34;language:{language} \u0026#34; # a sample query looks like: \u0026#34;stars:\u0026gt;50 language:python language:javascript\u0026#34; return query def repos_with_most_stars(languages, sort=\u0026#34;stars\u0026#34;, order=\u0026#34;desc\u0026#34;): query = create_query(languages) params = {\u0026#34;q\u0026#34;: query, \u0026#34;sort\u0026#34;: sort, \u0026#34;order\u0026#34;: order} response = requests.get(GITHUB_API_URL, params=params) status_code = response.status_code if status_code != 200: raise RuntimeError(f\u0026#34;An error occurred. HTTP Code: {status_code}.\u0026#34;) else: response_json = response.json() return response_json[\u0026#34;items\u0026#34;] if __name__ == \u0026#34;__main__\u0026#34;: languages = [\u0026#34;python\u0026#34;, \u0026#34;javascript\u0026#34;, \u0026#34;ruby\u0026#34;] results = repos_with_most_stars(languages) for result in results: language = result[\u0026#34;language\u0026#34;] stars = result[\u0026#34;stargazers_count\u0026#34;] name = result[\u0026#34;name\u0026#34;] print(f\u0026#34;-\u0026gt; {name} is a {language} repo with {stars} stars.\u0026#34;) Step by step Expand this section to walk through the program step-by-step. There\u0026rsquo;s some helpful information about the program in a comment at the top. The comment is separated with triple quotes \u0026quot;\u0026quot;\u0026quot;.\nThe first thing we\u0026rsquo;re doing is importing the popular requests library. We\u0026rsquo;ll be using it to make API calls.\nimport requests Next, we define the URL for the GitHub search API, which we found in the documentation for that endpoint in a variable called GITHUB_API_URL. This variable is named in all upper case because it\u0026rsquo;s a constant. A value that we don\u0026rsquo;t expect to change over the course of our program.\nGITHUB_API_URL = \u0026#34;https://api.github.com/search/repositories\u0026#34; First, the code in the main method will run. This code defines three different languages we\u0026rsquo;d like to see results for.\nlanguages = [\u0026#34;python\u0026#34;, \u0026#34;javascript\u0026#34;, \u0026#34;ruby\u0026#34;] Then calls the repos_with_most_stars method with that language list, and gets back a list of results.\nresults = repos_with_most_stars(languages) Let\u0026rsquo;s jump to the repos_with_most_stars function. We know it\u0026rsquo;s a function because of the def keyword, followed by a function name, parameters \u0026ndash; both required and optional in parenthesis, and finally, a colon :. It accepts a list of languages to sort by, as well as some optional parameters for how we want to sort the list. By default, we sort it by the number of stars the repo has, in descending order.\ndef repos_with_most_stars(languages, sort=\u0026#34;stars\u0026#34;, order=\u0026#34;desc\u0026#34;): Next, we need to create a query string that this particular API understands. We do that in the create_query function. This function takes the languages as a required parameter, and the minimum number of stars we\u0026rsquo;d like to query for as an optional parameter.\ndef create_query(languages, min_stars=50000): In this function, we create a query string that looks like this `stars:\u0026gt;50000 language:python language:javascript language:ruby\u0026quot;. These parameters of this query string are defined by the expectations of the API that we\u0026rsquo;re working with. We return this value.\nSince the query is a little confusing, there\u0026rsquo;s a comment in the code that explains what it does. The comment starts with # .\nBack in the repos_with_most_stars function, we use our query string as part of the parameters that we\u0026rsquo;ll be passing in to the API, along with the URL that we\u0026rsquo;ll be using.\nWe declare them in a dictionary called params, like this:\n# looks like: q=stars:\u0026gt;50000+language:python+language:javascript+language:ruby+\u0026amp;sort=stars\u0026amp;order=desc\u0026#39; params = {\u0026#34;q\u0026#34;: query, \u0026#34;sort\u0026#34;: sort, \u0026#34;order\u0026#34;: order} These params map to part of a URL that will look like this: q=stars:\u0026gt;50000+language:python+language:javascript+language:ruby+\u0026amp;sort=stars\u0026amp;order=desc\nNext, we use these parameters as well as the URL defined in GITHUB_API_URL to call the API using the requests library.\nresponse = requests.get(\u0026#34;https://api.github.com/search/repositories\u0026#34;, params=params) We\u0026rsquo;re requesting the data at this URL: https://api.github.com/search/repositories?q=stars:\u0026gt;50000+language:python+language:javascript+language:ruby+\u0026amp;sort=stars\u0026amp;order=desc\nWe\u0026rsquo;re using the requests library because it allows us to quickly and easily work with the data returned from an API.\nNext, we quickly check the HTTP status code to make sure that it was 200. If it wasn\u0026rsquo;t, that means that something went wrong with our request and we\u0026rsquo;ll want to throw an exception to quit our program.\nif status_code != 200: raise RuntimeError(f\u0026#34;An error occurred. HTTP Code: {status_code}.\u0026#34;) If everything went OK, we get the JSON from the response as a Python dictionary, using response.json(), next, we return the data in the \u0026ldquo;items\u0026rdquo; key back to the main method. In this case, we don\u0026rsquo;t care about the additional data that the API returned.\nresponse_json = response.json() return response_json[\u0026#34;items\u0026#34;] Next, back in the main method, we go through each result, and print out a line with the name of the repo, the language, and the amount of stars it has.\nprint(f\u0026#34;-\u0026gt; {name} is a {language} repo with {stars} stars.\u0026#34;) End Result The end result looks something like this:\n(env) $ python dayone.py -\u0026gt; freeCodeCamp is a JavaScript repo with 298046 stars. -\u0026gt; bootstrap is a JavaScript repo with 131403 stars. -\u0026gt; vue is a JavaScript repo with 130099 stars. -\u0026gt; react is a JavaScript repo with 123969 stars. -\u0026gt; d3 is a JavaScript repo with 82932 stars. -\u0026gt; javascript is a JavaScript repo with 82514 stars. -\u0026gt; react-native is a JavaScript repo with 74810 stars. -\u0026gt; create-react-app is a JavaScript repo with 64725 stars. -\u0026gt; awesome-python is a Python repo with 63693 stars. ... and more results Don\u0026rsquo;t worry if you didn\u0026rsquo;t understand this code, we\u0026rsquo;ll be building this program in the workshop today.\n"
},
{
	"uri": "https://pythonianrocketship.github.io/en/03-intermediate-python/10-introduction/15-converting-between-types/04-string-operations/",
	"title": "String Operations",
	"tags": [],
	"description": "",
	"content": "Split and Join Strings have two functions for splitting and joining - split() and join(). Calling split() on a string will split the string into a list, creating a new element for every instance of the character(s) you pass in. join() accepts a list of strings, and uses the string you call it on to join the list together into one string. For example:\n\u0026gt;\u0026gt;\u0026gt; my_data = \u0026#34;this,is,comma,separated,data\u0026#34; \u0026gt;\u0026gt;\u0026gt; my_data = my_data.split(\u0026#34;,\u0026#34;) \u0026gt;\u0026gt;\u0026gt; print(my_data) [\u0026#39;this\u0026#39;, \u0026#39;is\u0026#39;, \u0026#39;comma\u0026#39;, \u0026#39;separated\u0026#39;, \u0026#39;data\u0026#39;] \u0026gt;\u0026gt;\u0026gt; \u0026#34;:\u0026#34;.join(my_data) \u0026#39;this:is:comma:separated:data\u0026#39; \u0026gt;\u0026gt;\u0026gt; \u0026#34;, \u0026#34;.join(my_data) \u0026#39;this, is, comma, separated, data\u0026#39; "
},
{
	"uri": "https://pythonianrocketship.github.io/en/01-introduction/02-requirements/05-vs-code/04-the-repl-in-vscode/",
	"title": "Using The REPL",
	"tags": [],
	"description": "",
	"content": "The REPL REPL stands for Read, Evaluate, Print, Loop. The REPL is how you interact with the Python Interpreter.\nUnlike running a file containing Python code, in the REPL you can type commands and instantly see the output printed out. You can also use the REPL to print out help for methods and objects in Python, list out what methods are available, and much more.\nOpen The REPL To start the REPL in VS code, open the command palette and search for and select \u0026ldquo;Start REPL\u0026rdquo;. The advantage to starting the REPL from inside VS Code is that it respects the environment you already set up, that is the version of Python you chose earlier.\nNote: If you\u0026rsquo;d like to start the REPL from the command line outside of the editor, type python in your shell,\nRunning this command should bring up a new pane at the bottom of your editor that you can type into. A great feature of the REPL is that we can instantly see the result of commands being run.\nNote, in the REPL three arrows \u0026raquo;\u0026gt; indicate a line of input given at the prompt. If you see these arrows in example code, don\u0026rsquo;t copy them into your own REPL. Later, when we run out Python code from files, you will no longer see the triple arrows.\nLet\u0026rsquo;s get familiar with the REPL.\n# - comments start with #. They will be ignored. \u0026gt;\u0026gt;\u0026gt; - this is the prompt. In example code, lines starting with \u0026gt;\u0026gt;\u0026gt; means they are input lines that don\u0026rsquo;t start with either of these are output that was produced by running input from the prompt by typing these line of code at the \u0026gt;\u0026gt;\u0026gt; prompt, and press enter after each line.\n# My REPL. Don\u0026#39;t copy the \u0026gt;\u0026gt;\u0026gt; symbols, that means the code was entered # into the prompt. # # If the line does not start with \u0026gt;\u0026gt;\u0026gt;, that means it is output, # not input \u0026gt;\u0026gt;\u0026gt; name = \u0026#34;Nina\u0026#34; \u0026gt;\u0026gt;\u0026gt; name \u0026#39;Nina\u0026#39; In the REPL, we can see the value of any variable just by entering it into the prompt.\nYou can copy and paste code into the REPL, even multiple lines of code at once. Copy the three lines below and paste them into your REPL. What\u0026rsquo;s the result?\nx = 5 y = 33.5 x * y See the result. \u0026gt;\u0026gt;\u0026gt; x = 5 \u0026gt;\u0026gt;\u0026gt; y = 33.5 \u0026gt;\u0026gt;\u0026gt; x * y 167.5 The REPL allows us to gather information in real time about our Python program, which makes it a great learning tool.\nUsing type(), dir(), and help() We can use three very useful methods in the REPL to help us understand our Python programs.\nPass in an object into the type() Use type to find the type of an object in Python.\nIf you\u0026rsquo;re not sure what a variable or an object is, don\u0026rsquo;t worry. We\u0026rsquo;ll cover it later in the day.\nFor example, in the REPL, let\u0026rsquo;s make a new variable name, and check its type.\n\u0026gt;\u0026gt;\u0026gt; name = \u0026#34;Nina\u0026#34; \u0026gt;\u0026gt;\u0026gt; type(name) \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; We\u0026rsquo;ll see that the type is str, Python\u0026rsquo;s version of a string. Now that we know this object\u0026rsquo;s type, we can pass the type into other methods.\nThe first one is dir() which stands for directory. If we check the directory of str (notice, no quotes here)) in the REPL, we\u0026rsquo;ll see all the methods available on strings in Python. Don\u0026rsquo;t worry about these for now, we\u0026rsquo;ll use them later in the day.\n\u0026gt;\u0026gt;\u0026gt; dir(str) [\u0026#39;__add__\u0026#39;, \u0026#39;__class__\u0026#39;, \u0026#39;__contains__\u0026#39;, \u0026#39;__delattr__\u0026#39;, \u0026#39;__dir__\u0026#39;, \u0026#39;__doc__\u0026#39;, \u0026#39;__eq__\u0026#39;, \u0026#39;__format__\u0026#39;, \u0026#39;__ge__\u0026#39;, \u0026#39;__getattribute__\u0026#39;, \u0026#39;__getitem__\u0026#39;, \u0026#39;__getnewargs__\u0026#39;, \u0026#39;__gt__\u0026#39;, \u0026#39;__hash__\u0026#39;, \u0026#39;__init__\u0026#39;, \u0026#39;__init_subclass__\u0026#39;, \u0026#39;__iter__\u0026#39;, \u0026#39;__le__\u0026#39;, \u0026#39;__len__\u0026#39;, \u0026#39;__lt__\u0026#39;, \u0026#39;__mod__\u0026#39;, \u0026#39;__mul__\u0026#39;, \u0026#39;__ne__\u0026#39;, \u0026#39;__new__\u0026#39;, \u0026#39;__reduce__\u0026#39;, \u0026#39;__reduce_ex__\u0026#39;, \u0026#39;__repr__\u0026#39;, \u0026#39;__rmod__\u0026#39;, \u0026#39;__rmul__\u0026#39;, \u0026#39;__setattr__\u0026#39;, \u0026#39;__sizeof__\u0026#39;, \u0026#39;__str__\u0026#39;, \u0026#39;__subclasshook__\u0026#39;, \u0026#39;capitalize\u0026#39;, \u0026#39;casefold\u0026#39;, \u0026#39;center\u0026#39;, \u0026#39;count\u0026#39;, \u0026#39;encode\u0026#39;, \u0026#39;endswith\u0026#39;, \u0026#39;expandtabs\u0026#39;, \u0026#39;find\u0026#39;, \u0026#39;format\u0026#39;, \u0026#39;format_map\u0026#39;, \u0026#39;index\u0026#39;, \u0026#39;isalnum\u0026#39;, \u0026#39;isalpha\u0026#39;, \u0026#39;isascii\u0026#39;, \u0026#39;isdecimal\u0026#39;, \u0026#39;isdigit\u0026#39;, \u0026#39;isidentifier\u0026#39;, \u0026#39;islower\u0026#39;, \u0026#39;isnumeric\u0026#39;, \u0026#39;isprintable\u0026#39;, \u0026#39;isspace\u0026#39;, \u0026#39;istitle\u0026#39;, \u0026#39;isupper\u0026#39;, \u0026#39;join\u0026#39;, \u0026#39;ljust\u0026#39;, \u0026#39;lower\u0026#39;, \u0026#39;lstrip\u0026#39;, \u0026#39;maketrans\u0026#39;, \u0026#39;partition\u0026#39;, \u0026#39;replace\u0026#39;, \u0026#39;rfind\u0026#39;, \u0026#39;rindex\u0026#39;, \u0026#39;rjust\u0026#39;, \u0026#39;rpartition\u0026#39;, \u0026#39;rsplit\u0026#39;, \u0026#39;rstrip\u0026#39;, \u0026#39;split\u0026#39;, \u0026#39;splitlines\u0026#39;, \u0026#39;startswith\u0026#39;, \u0026#39;strip\u0026#39;, \u0026#39;swapcase\u0026#39;, \u0026#39;title\u0026#39;, \u0026#39;translate\u0026#39;, \u0026#39;upper\u0026#39;, \u0026#39;zfill\u0026#39;] The next useful method is help(). You can pass a type, method, or other object to help to instantly see available documentation about the method, the parameters it expects, and what it returns.\nLet\u0026rsquo;s try this in the REPL, and look up the documentation for the isupper method in String. We access it with the period symbol (.). This is called dot-notation.\n\u0026gt;\u0026gt;\u0026gt; help(str.isupper) Will show:\nisupper(self, /) Return True if the string is an uppercase string, False otherwise. A string is uppercase if all cased characters in the string are uppercase and there is at least one cased character in the string. Press the \u0026lsquo;q\u0026rsquo; key to exit this screen.\nKeep note of these three helpful methods, and don\u0026rsquo;t be afraid to use them throughout class.\nWhy Use The REPL? In this class, we\u0026rsquo;ll be working with a mix of the REPL and running code in files, like we\u0026rsquo;ll see in the next section. You\u0026rsquo;ll want to store code for reuse in files, while you can consider the REPL more of a scratch area. It\u0026rsquo;s the place where you can instantly play around and try out Python code. The REPL is a handy tool for both beginner and advanced Python programmers.\nWe\u0026rsquo;ll use the REPL for the majority of Day 1, and move on to running Python files in Day 2.\n"
},
{
	"uri": "https://pythonianrocketship.github.io/en/03-intermediate-python/10-introduction/15-converting-between-types/",
	"title": "Converting Between Types",
	"tags": [],
	"description": "",
	"content": "Easily converting between different datatypes is one of Python\u0026rsquo;s superpowers! Let\u0026rsquo;s see how\u0026hellip;\n"
},
{
	"uri": "https://pythonianrocketship.github.io/en/03-intermediate-python/70-tests/50-writing-tests/",
	"title": "Writing Tests",
	"tags": [],
	"description": "",
	"content": "There are a few different frameworks for writing unit tests in Python, but they\u0026rsquo;re all very similar. We\u0026rsquo;ll focus on the built-in unittest library. unittest is both a framework for writing tests, as well as a test runner, meaning it can execute your tests and return the results. In order to write unittest tests, you must:\nWrite your tests as methods within classes Use a series of built-in assertion methods Let\u0026rsquo;s start with a simple function to test, multiply(), which takes two numbers and multiplies them.\ndef multiply(x, y): return x * y Easy enough. Let\u0026rsquo;s write a test case for it. Usually this will be broken out into a separate file, but we\u0026rsquo;ll combine them for this contrived example. We\u0026rsquo;ll create a TestMultiply class that derives from unittest.TestCase, with a method inside that does the actual testing. Lastly, we\u0026rsquo;ll call unittest.main() to tell unittest to find and run our TestCase. We\u0026rsquo;ll put all this in a file called test_multiply.py and run it from the command line:\nimport unittest def multiply(x, y): return x * y class TestMultiply(unittest.TestCase): def test_multiply(self): test_x = 5 test_y = 10 self.assertEqual(multiply(test_x, test_y), 50, \u0026#34;Should be 50\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: unittest.main() (env) $ python test_multiply.py . ---------------------------------------------------------------------- Ran 1 test in 0.000s OK Failing Tests Let\u0026rsquo;s introduce a bug into our multiply() function and see what happens when we run the test:\nimport unittest def multiply(x, y): return x * x class TestMultiply(unittest.TestCase): def test_multiply(self): test_x = 5 test_y = 10 self.assertEqual(multiply(test_x, test_y), 50, \u0026#34;Should be 50\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: unittest.main() (env) $ python test_multiply.py F ====================================================================== FAIL: test_multiply (__main__.TestMultiply) ---------------------------------------------------------------------- Traceback (most recent call last): File \u0026#34;test_multiply.py\u0026#34;, line 11, in test_multiply self.assertEqual(multiply(test_x, test_y), 50, \u0026#34;Should be 50\u0026#34;) AssertionError: 25 != 50 : Should be 50 ---------------------------------------------------------------------- Ran 1 test in 0.001s FAILED (failures=1) Important Concepts TestCase class must subclass unittest.TestCase Names of test functions must begin with test_ Import the code to be tested Your TestCase class can be called whatever you want, but you must subclass unittest.TestCase in order for it to work.\nYour test functions in your TestCase must begin with test_, otherwise they won\u0026rsquo;t be run as tests.\nThis can be useful if you need to include utility functions inside your TestCase.\nLastly, your test code will need access to your code to be tested. For a small project, this is easily done by putting your tests in a test.py file alongside your code. For larger projects, you usually want to have multiple test files inside a test folder. In this case, you\u0026rsquo;ll need to make sure your code to be tested is available on your PYTHONPATH.\nRunning your Tests As we saw, one common way of running your tests is by calling unittest.main():\nif __name__ == \u0026#34;__main__\u0026#34;: unittest.main() Add this to your test file, run it, and you\u0026rsquo;re off to the races. You can also skip this bit, and call unittest directly from the command line:\n(env) $ python -m unittest test_module Here, you don\u0026rsquo;t need to make your test file runnable (by using unittest.main()), instead you\u0026rsquo;re running unittest directly and telling it where to find your tests.\nUse the -v (or --verbose) flag can give you more information about which tests were run\n(env) $ python -m unittest test_multiply -v test_multiply (test_multiply.TestMultiply) ... FAIL ====================================================================== FAIL: test_multiply (test_multiply.TestMultiply) ---------------------------------------------------------------------- Traceback (most recent call last): File \u0026#34;/Users/nina/Desktop/test_multiply.py\u0026#34;, line 11, in test_multiply self.assertEqual(multiply(test_x, test_y), 50, \u0026#34;Should be 50\u0026#34;) AssertionError: 25 != 50 : Should be 50 ---------------------------------------------------------------------- Ran 1 test in 0.001s FAILED (failures=1) TestCase Assertions Subclassing the TestCase class gives you a bunch of useful assertions that you can use to check the validity of your code. Here\u0026rsquo;s the list from the Python documentation:\nMethod Checks that assertEqual(a, b) a == b assertNotEqual(a, b) a != b assertTrue(x) bool(x) is True assertFalse(x) bool(x) is False assertIs(a, b) a is b assertIsNot(a, b) a is not b assertIsNone(x) x is None assertIsNotNone(x) x is not None assertIn(a, b) a in b assertNotIn(a, b) a not in b assertIsInstance(a, b) isinstance(a, b) assertNotIsInstance(a, b) not isinstance(a, b) Growing your Tests Standard unittest tests are fine for most projects. As your programs grow and organization becomes more complex, you might want to consider an alternative testing framework or test runner. The 3rd party nose2 and pytest modules are compatible with unittest but do things slightly differently. You can find more information in the nose2 documentation and pytest documentation.\n"
},
{
	"uri": "https://pythonianrocketship.github.io/en/03-intermediate-python/30-oop-classes-inheritance/50-methods/",
	"title": "Methods",
	"tags": [],
	"description": "",
	"content": "You\u0026rsquo;ve just seen the difference between class and instance variables. Classes can also have class methods - methods that are shared among all instances of a certain type. As with variables, they can be overriden in a specific instance or subclass.\nLet\u0026rsquo;s add a class method to our Car class:\nclass Car: runs = True number_of_wheels = 4 @classmethod def get_number_of_wheels(cls): return cls.number_of_wheels def start(self): if self.runs: print(\u0026#34;Car is started. Vroom vroom!\u0026#34;) else: print(\u0026#34;Car is broken :(\u0026#34;) And call it:\n\u0026gt;\u0026gt;\u0026gt; my_car = Car() \u0026gt;\u0026gt;\u0026gt; print(f\u0026#34;Cars have {Car.get_number_of_wheels()} wheels.\u0026#34;) Cars have 4 wheels. # Of course, we can override this in our instance: \u0026gt;\u0026gt;\u0026gt; my_car.number_of_wheels = 6 # And when we access our new instance variable: \u0026gt;\u0026gt;\u0026gt; print(f\u0026#34;My car has {my_car.number_of_wheels} wheels.\u0026#34;) My car has 6 wheels. # But, when we call our class method on our instance: \u0026gt;\u0026gt;\u0026gt; print(f\u0026#34;My car has {my_car.get_number_of_wheels()} wheels.\u0026#34;) My car has 4 wheels. Why? Because get_number_of_wheels() is a class method, and when it\u0026rsquo;s called, the class (Car) gets passed in, and the value of Car.number_of_wheels is returned. Although we can access the instance variable (with a value of 6), the get_number_of_wheels() class method still returns the class variable, which is 4.\ntype, isinstance, and issubclass Python comes with some built-in functions for inspecting classes and types:\nAs we\u0026rsquo;ve seen throughout the workshop, the type() function returns the type of the object you pass it, or it\u0026rsquo;s class. For example:\n\u0026gt;\u0026gt;\u0026gt; type(42) \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt; type(\u0026#34;Hello world!\u0026#34;) \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt; type(my_car) \u0026lt;class \u0026#39;__main__.Car\u0026#39;\u0026gt; The isinstance() function takes an object and a class, and returns True if the object you pass it is an instance of the class. For example:\n\u0026gt;\u0026gt;\u0026gt; isinstance(42, int) True \u0026gt;\u0026gt;\u0026gt; isinstance(\u0026#34;Hello world!\u0026#34;, str) True \u0026gt;\u0026gt;\u0026gt; isinstance(my_car, float) False \u0026gt;\u0026gt;\u0026gt; isinstance(my_car, Car) True The issubclass function takes two classes, and returns True if the first class is a subclass of the second. For example:\n# bool is a subclass of int \u0026gt;\u0026gt;\u0026gt; issubclass(bool, int) True # int is a subclass of object \u0026gt;\u0026gt;\u0026gt; issubclass(int, object) True # technically, everything is a subclass of object \u0026gt;\u0026gt;\u0026gt; issubclass(bool, object) True __init__ Classes can have an optional magic method called __init__() that gets run when you instantiate an instance of a class. You can use the __init__() method to do any special thing you want to happen when your instance is instantiated, including setting instance variables. __init__ can take arguments, too.\nMethods that are bracketed by underscores are sometimes called \u0026ldquo;magic methods.\u0026rdquo; We won\u0026rsquo;t be covering magic methods in this class, but we will point out a few of the interesting ones.\nFor example:\nclass Car: runs = True def __init__(self, make, model): self.make = make self.model = model def start(self): if self.runs: print(f\u0026#34;Your {self.make} {self.model} is started. Vroom vroom!\u0026#34;) else: print(f\u0026#34;Your {self.make} {self.model} is broken :(\u0026#34; \u0026gt;\u0026gt;\u0026gt; my_car = Car(\u0026#34;Ford\u0026#34;, \u0026#34;Thunderbird\u0026#34;) \u0026gt;\u0026gt;\u0026gt; my_car.start() Your Ford Thunderbird is started. Vroom vroom! Here, we accept two required variables, make and model in our __init__() method, and set instance variables of the same names using self. Later, when we call start(), we can grab self.make and self.model from the bound instance and use them in our string.\n__str__ and __repr__ Classes have two other magic methods that come in handy for debugging, __str__() and __repr__(). Both functions return a string representation of an object. __str__() should return readable end-user output, and __repr__() should return the Python code necessary to rebuild the object. __str__() maps to the built-in function str() and __repr__() maps to the built-in function repr().\nFor example, we\u0026rsquo;ll use the datetime library to generate a datetime object for right now:\n\u0026gt;\u0026gt;\u0026gt; import datetime \u0026gt;\u0026gt;\u0026gt; now = datetime.datetime.now() \u0026gt;\u0026gt;\u0026gt; str(now) \u0026#39;2019-03-16 21:04:01.396256\u0026#39; \u0026gt;\u0026gt;\u0026gt; repr(now) \u0026#39;datetime.datetime(2019, 3, 16, 21, 4, 1, 396256)\u0026#39; You can see that str() has returned a human-readable date/time, and repr() has returned a string that represents the Python code we would need to run to recreate this object.\nWe can, of course, set our own __str__() and __repr__() methods in our custom classes:\nclass Car: def __init__(self, make, model): self.make = make self.model = model def __str__(self): return f\u0026#34;\u0026lt;\u0026lt;Car object: {self.make} {self.model}\u0026gt;\u0026gt;\u0026#34; def __repr__(self): return f\u0026#34;Car(\u0026#39;{self.make}\u0026#39;, \u0026#39;{self.model}\u0026#39;)\u0026#34; \u0026gt;\u0026gt;\u0026gt; my_car = Car(\u0026#34;Ford\u0026#34;, \u0026#34;Thunderbird\u0026#34;) \u0026gt;\u0026gt;\u0026gt; print(f\u0026#34;This object is a {str(my_car)}\u0026#34;) This object is a \u0026lt;\u0026lt;Car object: Ford Thunderbird\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; print(f\u0026#34;To reproduce it, type: {repr(my_car)}\u0026#34;) To reproduce it, type: Car(\u0026#39;Ford\u0026#39;, \u0026#39;Thunderbird\u0026#39;) Bonus You don\u0026rsquo;t have to instantiate everything by hand, you can instantiate objects in for loops or even comprehensions. This is useful for running a function on a list of objects. For example, to convert a list of number-strings into a list of integers, you could do:\n\u0026gt;\u0026gt;\u0026gt; my_ints = [int(str_num) for str_num in [\u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;, \u0026#34;3\u0026#34;]] \u0026gt;\u0026gt;\u0026gt; print(my_ints) [1, 2, 3] "
},
{
	"uri": "https://pythonianrocketship.github.io/en/03-intermediate-python/50-libraries-modules/50-pypi/",
	"title": "PyPI",
	"tags": [],
	"description": "",
	"content": "PyPI (the Python Package Index) is an awesome service that helps you find and install software developed and shared by the Python community. Almost every user-contributed Python package has been published to PyPI. You can browse the site at pypi.org but most of the time you will probably interact with it through Python\u0026rsquo;s pip tool.\nBasic Usage You can use the pip tool to install the latest version of a module and its dependencies from the Python Packaging Index:\n(env) $ python -m pip install SomePackage Know your Packages There are a lot of packages on PyPI, and they\u0026rsquo;re not always up-to-date. Sometimes it helps to look at a package before installing it. Simply search for a package name on PyPI.org - for example, here\u0026rsquo;s the page for the redis package. If you follow the Homepage link, you\u0026rsquo;ll be taken to the project\u0026rsquo;s GitHub page, where you can see that the latest commit was very recently. So you know this package is actively maintained, and will probably work in your up-to-date version of Python.\nWhen you\u0026rsquo;re first starting out, it\u0026rsquo;s a good idea to copy the pip install text from the website, otherwise bad actors could take advantage of your typos.\nWe\u0026rsquo;ll practice installing a package in the exercise for this chapter.\n"
},
{
	"uri": "https://pythonianrocketship.github.io/en/03-intermediate-python/20-advanced-looping/50-slicing/",
	"title": "Slicing",
	"tags": [],
	"description": "",
	"content": "Slicing is a easy way to create sub-lists from larger lists. If you remember back to our exercise on data types, we can use a slice to obtain a subset of items from a list. Remember that a string is just a list of characters. For example:\n\u0026gt;\u0026gt;\u0026gt; my_string = \u0026#34;Hello, world!\u0026#34; \u0026gt;\u0026gt;\u0026gt; my_string[7:12] # from 7 to 12 \u0026#39;world\u0026#39; Lopsided Slicing You can also leave out one of the numbers in the slice. Leaving out the first number is equivalent to using a zero - you can think of this as \u0026ldquo;from the beginning.\u0026rdquo; Leaving out the last number is equivalent to using the length of the list you\u0026rsquo;re slicing - you can think of this as \u0026ldquo;until the end.\u0026rdquo; For example:\n\u0026gt;\u0026gt;\u0026gt; my_string = \u0026#34;Hello, world!\u0026#34; \u0026gt;\u0026gt;\u0026gt; my_string[:5] # from zero to 5 \u0026#39;Hello\u0026#39; \u0026gt;\u0026gt;\u0026gt; my_string[7:] # from 7 to the end \u0026#39;world!\u0026#39; You can also leave out both sides of the slice! You can think of this as \u0026ldquo;from the beginning, until the end.\u0026rdquo; Why? This is an easy way to copy a list!\n\u0026gt;\u0026gt;\u0026gt; my_new_string = my_string[:] \u0026gt;\u0026gt;\u0026gt; my_new_string \u0026#39;Hello, world!\u0026#39; Negative Indexing You aren\u0026rsquo;t limited to positive numbers for your slicing, either. A negative number on the left side will wrap around to the other side of your list. A negative number on the right side is equivalent to the length of the list minus your number. For example:\n\u0026gt;\u0026gt;\u0026gt; my_string = \u0026#34;Hello, world!\u0026#34; \u0026gt;\u0026gt;\u0026gt; my_string[-6:] # from the end - 6 to the end \u0026#39;world!\u0026#39; \u0026gt;\u0026gt;\u0026gt; my_string[-10:-4] # from the end - 10 to the end - 4 \u0026#39;lo, wo\u0026#39; You can also use just a single negative number to get an item counting backwards from the end of a list. For example, to get the last item from a list:\n\u0026gt;\u0026gt;\u0026gt; my_list = [1, 3, 3, 7] \u0026gt;\u0026gt;\u0026gt; my_list[-1] 7 Stride or Step Python slices also have a third, optional argument, called \u0026ldquo;step\u0026rdquo; or \u0026ldquo;stride\u0026rdquo;, separated by a second colon. This lets you skip elements of a list or even reverse them. For example:\n\u0026gt;\u0026gt;\u0026gt; my_list = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] \u0026gt;\u0026gt;\u0026gt; my_list[::2] # move forward by 2, or skip every other index [0, 2, 4, 6, 8] \u0026gt;\u0026gt;\u0026gt; my_list[::-1] # move backward by 1, and easy way to reverse a list [9, 8, 7, 6, 5, 4, 3, 2, 1, 0] \u0026gt;\u0026gt;\u0026gt; my_list[1:7:2] # get every other index between 1 and 7 [1, 3, 5] You can use a slice to get a subset of items from any data type that maintains an order, such as a list or tuple, but not from any non-ordered data types, such as dict or set.\n"
},
{
	"uri": "https://pythonianrocketship.github.io/en/02-introduction-to-python/020-basic-data-types/05-common-string-and-number-errors/",
	"title": "Common Mistakes",
	"tags": [],
	"description": "",
	"content": "There are a few common errors that you\u0026rsquo;ll encounter when working with Strings and numbers. Remember, in Python program errors are called Exceptions. By going over what they are, you\u0026rsquo;ll be able to recognize them immediately.\nScenario 1: Mismatched string quotes Mismatched string quotes will result in a SyntaxError\nWhen we try to start a String with one type of quote, and end with another, we\u0026rsquo;ll see a syntax error.\nFor example, starting the string Hello with a double quote, and ending in a single quote, like this:\nInput: \u0026quot;Hello\u0026rsquo; For example, in the REPL:\n\u0026gt;\u0026gt;\u0026gt; name = \u0026#39;Hello\u0026#34; File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1 name = \u0026#34;Hello\u0026#39; ^ SyntaxError: EOL while scanning string literal Solution: use matching quote types for defining your strings. Either single quotes 'Hello' or double quotes \u0026quot;Hello\u0026quot;.\nScenario 2: Trying to print a String and a number with concatenation using the \u0026ldquo;+\u0026rdquo; symbol. Trying to add or concatenate a String and a number will result in a TypeError\nIf you add try to add (or concatenate) a String and a number, you\u0026rsquo;ll get an error saying that adding the two types together isn\u0026rsquo;t possible.\nInput: 3 + \u0026ldquo;Three\u0026rdquo; In the REPL:\n\u0026gt;\u0026gt;\u0026gt; print(3 + \u0026#34; Three\u0026#34;) Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; TypeError: unsupported operand type(s) for +: \u0026#39;int\u0026#39; and \u0026#39;str\u0026#39; Solutions:\nThere are two possible solutions here, for two different scenarios.\nIn the first scenario, you\u0026rsquo;d like to add a number to a string via concatenation. In order to do that, you must first convert the number to a string via the str() method.\nIn the REPL:\n\u0026gt;\u0026gt;\u0026gt; my_num = 3 \u0026gt;\u0026gt;\u0026gt; print(str(my_num) + \u0026#34; Three\u0026#34;) 3 Three In the second scenario, you\u0026rsquo;d like to a convert a number that\u0026rsquo;s contained in a string (ex: \u0026quot;3\u0026quot;) into an Integer, so you can use it like any other number. In this case, you\u0026rsquo;d like to convert it to an Integer, with the int() method.\nIn the REPL:\n\u0026gt;\u0026gt;\u0026gt; str_num = \u0026#34;3\u0026#34; \u0026gt;\u0026gt;\u0026gt; print(int(str_num) + 5) 8 "
},
{
	"uri": "https://pythonianrocketship.github.io/en/02-introduction-to-python/110-control-statements-looping/05-looping-in-python/",
	"title": "Looping in Python",
	"tags": [],
	"description": "",
	"content": "for Loop Cheat Sheet Looping in Python doesn\u0026rsquo;t look like looping in other languages.\nIf you write JavaScript, Java, or other languages, you might have seen code that looks something like this code, that keeps track of 3 things: the starting index, the condition the loop will run until, and which action to take (in this case, incrementing the variable i by 1) until the condition is met.\nfor (i = 0; i \u0026lt; 5; i++) { text += \u0026#34;The number is \u0026#34; + i + \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; } In fact, before these languages introduced something called a for each loop, that was also the clunky way you\u0026rsquo;d loop through items in a sequence.\nLooping in Python Looping in Python is a simpler, cleaner process because the Python language prides itself on readability.\nRemember you used the in keyword to test if an item was in a sequence? When combined with the for keyword, in can be used to indicate looping over each item in the sequence. The syntax is: for single_item in items, followed by a colon :, followed by a new line, a level of indentation, and the code you\u0026rsquo;d like to consider as the body of the loop. That is, the code that\u0026rsquo;ll run multiple times, until there are no more items in the collection.\nLet\u0026rsquo;s see it in action.\n\u0026gt;\u0026gt;\u0026gt; colors = [\u0026#34;Red\u0026#34;, \u0026#34;Green\u0026#34;, \u0026#34;Blue\u0026#34;, \u0026#34;Orange\u0026#34;] \u0026gt;\u0026gt;\u0026gt; for color in colors: ... print(f\u0026#34;The color is: {color}\u0026#34;) The color is: Red The color is: Green The color is: Blue The color is: Orange Looping over a range of numbers Let\u0026rsquo;s say we wanted to duplicate the code in the example JavaScript above, that prints out the numbers from 0 to 4.\nIn order to do this, we\u0026rsquo;ll need to use a built-in function called range(). The range function in python produces a sequence of integers from an optional and inclusive start, to a defined and exclusive finish.\nIn Python2, this function created a list of each number in that sequence. As you can imagine, it was horribly inefficient for large ranges. In Python3, the range() function returns a new optimized data type. It\u0026rsquo;s great for optimization, but it\u0026rsquo;s harder for debugging.\nIf you want to explicitly see what a call to range() produces for debugging purposes, you can pass the result into the list() method to see all the values at once. For example: list(range(5)). Remember that this is inefficient, so use it for testing, not in production code.\nIf we wanted to loop over all the values from 0 to 4, we\u0026rsquo;d use the range function like this:\n\u0026gt;\u0026gt;\u0026gt; for num in range(5): ... print(f\u0026#34;The number is: {num}\u0026#34;) ... The number is: 0 The number is: 1 The number is: 2 The number is: 3 The number is: 4 You\u0026rsquo;ll notice that this call didn\u0026rsquo;t include the number 5.\nWhat if we wanted the range from 1 to 4, instead of 0 to 4? range() can be called with start and stop parameters, and the range will start from start.\n\u0026gt;\u0026gt;\u0026gt; for num in range(1, 5): ... print(f\u0026#34;The number is: {num}\u0026#34;) ... The number is: 1 The number is: 2 The number is: 3 The number is: 4 You can also pass an a third optional step parameter in. Let\u0026rsquo;s say I quickly wanted to print out all the even numbers from 2 to 10. I would call range(2, 11, 2). Remember, 2 is where we\u0026rsquo;re starting, 11 is one higher than where we\u0026rsquo;re ending (10), and 2 is the step, or the amount to jump between numbers.\n\u0026gt;\u0026gt;\u0026gt; for num in range(2, 11, 2): ... print(f\u0026#34;The number is: {num}\u0026#34;) ... The number is: 2 The number is: 4 The number is: 6 The number is: 8 The number is: 10 What do inclusive and exclusive mean in this context? Exclusive means that the end result will not include that number. If you\u0026rsquo;d like the numbers from 0 to 4, you would call range(5). Consider 5 to the stopping point. Inclusive means the range will include the number. The start parameter is inclusive, meaning if you\u0026rsquo;d like the range of numbers from 1 to 4, you\u0026rsquo;d call range(1, 5).\nIf you can\u0026rsquo;t remember how to use range, don\u0026rsquo;t forget to call help(range) from the command line.\nLooping over items with the index using enumerate. In Python, we avoid writing code like the JavaScript for loop at the top, but sometimes it\u0026rsquo;s unavoidable, and we need a way to access the index of the items we\u0026rsquo;re looping through. To do that we use a special function called enumerate(). The function takes a sequence, like a list, and it returns a list of tuples, containing the index of the item in the sequence, and the sequence itself.\nDon\u0026rsquo;t worry about the list of tuples for now, but remember our tuple unpacking from earlier?\n\u0026gt;\u0026gt;\u0026gt; point = (2, 5, 11) \u0026gt;\u0026gt;\u0026gt; x, y, z = point \u0026gt;\u0026gt;\u0026gt; x 2 \u0026gt;\u0026gt;\u0026gt; y 5 \u0026gt;\u0026gt;\u0026gt; z 11 Because enumerate() returns a structure that looks like a list of tuples under the hood, we can take advantage of tuple unpacking in the for loop.\n\u0026gt;\u0026gt;\u0026gt; for index, item in enumerate(colors): ... print(f\u0026#34;Item: {item} is at index: {index}.\u0026#34;) ... Item: Red is at index: 0. Item: Green is at index: 1. Item: Blue is at index: 2. Item: Orange is at index: 3. Remember, indicies in Python start at zero.\nLooping over a dictionary Now that we know we can use tuple unpacking in a for loop, let\u0026rsquo;s go over how to loop over a dictionary.\nLet\u0026rsquo;s say we have a dictionary of colors to their hex color code used for HTML in websites.\n\u0026gt;\u0026gt;\u0026gt; hex_colors = { ... \u0026#34;Red\u0026#34;: \u0026#34;#FF\u0026#34;, ... \u0026#34;Green\u0026#34;: \u0026#34;#008\u0026#34;, ... \u0026#34;Blue\u0026#34;: \u0026#34;#0000FF\u0026#34;, ... } Remember, a dictionary is composed of key, value pairs. When we loop over a dictionary with the for item in my_dict syntax, we\u0026rsquo;ll end up looping over just the keys.\nIn this example, notice how we\u0026rsquo;re looping over the wrong thing:\n\u0026gt;\u0026gt;\u0026gt; for color in hex_colors: ... print(f\u0026#34;The value of color is actually: {color}\u0026#34;) ... The value of color is actually: Red The value of color is actually: Green The value of color is actually: Blue If we want to loop over the key, value pairs in a dictionary, we\u0026rsquo;ll want to call my_dict.items().\nWe can use tuple unpacking along with the my_dict.items() list to loop over both the keys and the values at the same time.\n\u0026gt;\u0026gt;\u0026gt; for color, hex_value in hex_colors.items(): ... print(f\u0026#34;For color {color}, the hex value is: {hex_value}\u0026#34;) ... For color Red, the hex value is: #FF0000 For color Green, the hex value is: #008000 For color Blue, the hex value is: #0000FF Common Errors What if you try to loop over key, value pairs, and forget to use my_dict.items()?\n\u0026gt;\u0026gt;\u0026gt; for color, hex_value in hex_colors: ... print(f\u0026#34;For color {color}, the hex value is: {hex_value}\u0026#34;) ... Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; ValueError: too many values to unpack (expected 2) You\u0026rsquo;ll see ValueError: too many values to unpack (expected 2) if you forget to call my_dict.items(), and try to loop over what you\u0026rsquo;d expect to be key, value pairs.\nAdditional Resources If you really want to be a pro at looping in a Pythonic way, I recommend watching Raymond Hettinger\u0026rsquo;s talk - Transforming Code into Beautiful, Idiomatic Python after the course.\n"
},
{
	"uri": "https://pythonianrocketship.github.io/en/01-introduction/02-requirements/05-vs-code/05-running-code/",
	"title": "Running Code",
	"tags": [],
	"description": "",
	"content": "VS Code provides a built in terminal that allows us to easily run our programs. We\u0026rsquo;ll mostly be working with Python program files at the end of Day 1, and for most of Day 2.\nCreating Python Files with the *.py extension You know a file is a Python program when it ends with a .py extension.\nCreating New Python Files To create a new file in VS Code, hit Ctrl+N on Windows and Linux, and ⌘N (command + N) on Mac OS.\nThis will open a new file. Next, save the file with a .py extension.\nCreate a new simple Python program in a file called hello.py in your pyworkshop directory with the following contents:\n# in file: hello.py greetings = [\u0026#34;Hello\u0026#34;, \u0026#34;Bonjour\u0026#34;, \u0026#34;Hola\u0026#34;] for greeting in greetings: print(f\u0026#34;{greeting}, World!\u0026#34;) Opening The VS Code Terminal Window Next, you\u0026rsquo;ll need to open your terminal if you don\u0026rsquo;t have it open already. The quick keyboard shortcut to do that is Ctrl - `\nIf you already had your Python REPL open, you\u0026rsquo;ll need to select a terminal with a shell in it (generally, the one labeled with 1:).\nRunning The File Once you\u0026rsquo;ve opened your hello.py file and selected your new terminal window, open the VS Code command palette.\nOpen the command palette with Ctrl+Shift+P on Windows and Linux, and ⌘⇧P (command + shift + P) on Mac OS.\nSelect Python: Run Python File in Terminal\nYou should see:\nHello, World! Bonjour, World! Hola, World! How easy was that? 🎉\n"
},
{
	"uri": "https://pythonianrocketship.github.io/en/03-intermediate-python/30-oop-classes-inheritance/70-inheritance/",
	"title": "Inheritance",
	"tags": [],
	"description": "",
	"content": "Class inheritance is a very useful Object-oriented Programming construct for sharing and reusing code. Inheritance makes it possible to break up and organize your code into a hierarchy, from generic to specific. Objects that belong to classes that are higher up in the hierarchy (more generic) are accessible by subclasses, but not vice versa.\nEarlier, we saw that bool is a subclass of int, thus, it inherited the properties and methods of the int class, and then extended it to be more specific to booleans.\nWe can do the same with our own classes, too. In a file called vehicle.py, let\u0026rsquo;s create a parent Vehicle class, and have our Car class be a subclass.\nclass Vehicle: def __init__(self, make, model, fuel=\u0026#34;gas\u0026#34;): self.make = make self.model = model self.fuel = fuel class Car(Vehicle): def __init__(self, make, model, fuel=\u0026#34;gas\u0026#34;): super().__init__(make, model, fuel) When we instantiate a Car instance, the interpreter calls __init__(), where we pass in two arguments (make and model) and an optional 3rd (fuel, which defaults to \u0026ldquo;gas\u0026rdquo;). In __init__(), we call super().__init__(), which resolves to our parent class, Vehicle, and runs its __init__ function, where the variables are stored. Note that even though the variables are stored at the Vehicle level, they are instance variables because self is bound to my_car, which is a Car, which is a Vehicle. Don\u0026rsquo;t forget to import your Vehicle and Car classes. Behold:\n\u0026gt;\u0026gt;\u0026gt; from vehicle import Vehicle, Car \u0026gt;\u0026gt;\u0026gt; my_car = Car(\u0026#34;Ford\u0026#34;, \u0026#34;Thunderbird\u0026#34;) \u0026gt;\u0026gt;\u0026gt; print(type(my_car)) \u0026lt;class \u0026#39;__main__.Car\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt; print(my_car.fuel) gas \u0026gt;\u0026gt;\u0026gt; print(isinstance(my_car, Car)) True \u0026gt;\u0026gt;\u0026gt; print(isinstance(my_car, Vehicle)) True \u0026gt;\u0026gt;\u0026gt; print(issubclass(Car, Vehicle)) True Overriding Variables in a Subclass We can, of course, use a subclass to override variables that belong to a parent class. Let\u0026rsquo;s update our vehicle.py file:\nclass Vehicle: number_of_wheels = 4 def __init__(self, make, model, fuel=\u0026#34;gas\u0026#34;): self.make = make self.model = model self.fuel = fuel class Car(Vehicle): def __init__(self, make, model, fuel=\u0026#34;gas\u0026#34;): super().__init__(make, model, fuel) class Truck(Vehicle): number_of_wheels = 6 def __init__(self, make, model, fuel=\u0026#34;diesel\u0026#34;): super().__init__(make, model, fuel) class Motorcycle(Vehicle): number_of_wheels = 2 \u0026gt;\u0026gt;\u0026gt; my_truck = Truck(\u0026#34;Ford\u0026#34;, \u0026#34;F350\u0026#34;) \u0026gt;\u0026gt;\u0026gt; print(type(my_truck)) \u0026lt;class \u0026#39;__main__.Truck\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt; print(my_truck.fuel) diesel \u0026gt;\u0026gt;\u0026gt; print(my_truck.number_of_wheels) 6 Note how our Truck\u0026rsquo;s class variable number_of_wheels overrode the parent class Vehicle\u0026rsquo;s number_of_wheels (or, to be more specific, the interpreter found number_of_wheels in a closer scope, the Truck class, and did not need to continue searching up the hierarchy). Likewise, Motorcycle overrides just the number_of_wheels variable to equal 2. Notice there is no __init__() function in Motorcycle - the number_of_wheels variable is overridden but instantiating a Motorcycle just goes straight to the Vehicle.__init__() method.\nMultiple Inheritance in Python Can Python classes inherit from multiple parent classes? Yes, this is called multiple inheritance. It\u0026rsquo;s not as commonly used for simple programs, but you\u0026rsquo;ll see it more often as you start using libraries.\nOne common use case for multiple inheritance in Python is for a type of class called a Mixin. Mixin classes tend to be used to quickly and easily add additional properties and methods into a class. This type of design pattern encourages code with composable architecture.\nUnfortunately, we won\u0026rsquo;t have time to cover the topic of Multiple inheritance in this workshop\u0026hellip; because it\u0026rsquo;s out of scope. 🤣\n"
},
{
	"uri": "https://pythonianrocketship.github.io/en/03-intermediate-python/40-exceptions/70-best-practices/",
	"title": "Best Practices",
	"tags": [],
	"description": "",
	"content": "Catch More Specific Exceptions First Remember, your except handlers are evaluated in order, so be sure to put more specific exceptions first. For example:\n\u0026gt;\u0026gt;\u0026gt; try: ... my_value = 3.14 / 0 ... except ArithmeticError: ... print(\u0026#34;We had a general math error\u0026#34;) ... except ZeroDivisionEror: ... print(\u0026#34;We had a divide-by-zero error\u0026#34;) ... We had a general math error When we tried to divide by zero, we inadvertently raised a ZeroDivisionError. However, because ZeroDivisionError is a subclass of ArithmeticError, and except ArithemticError came first, the information about our specific error was swallowed by the except ArithemticError handler, and we lost more detailed information about our error.\nDon\u0026rsquo;t Catch Exception It\u0026rsquo;s bad form to catch the general Exception class. This will catch every type of exception that subclasses the Exception class, which is almost all of them. You may have errors that you don\u0026rsquo;t care about, and don\u0026rsquo;t affect the operation of your program, or maybe you\u0026rsquo;re dealing with a flaky API and want to swallow errors and retry. By catching Exception, you run the risk of hitting an unexpected exception that your program actually can\u0026rsquo;t recover from, or worse, swallowing an important exception without properly logging it - a huge headache when trying to debug programs that are failing in weird ways.\nDefinitely don\u0026rsquo;t catch BaseException Catching BaseException is a really bad idea, because you\u0026rsquo;ll swallow every type of Exception, including KeyboardInterrupt, the exception that causes your program to exit when you send a SIGINT (Ctrl-C). Don\u0026rsquo;t do it.\n"
},
{
	"uri": "https://pythonianrocketship.github.io/en/03-intermediate-python/20-advanced-looping/70-zip/",
	"title": "The zip function",
	"tags": [],
	"description": "",
	"content": "It\u0026rsquo;s often necessary to iterate over multiple lists simultaneously. Suppose we\u0026rsquo;re keeping score of a game and we have two lists, one for names and one for scores:\n\u0026gt;\u0026gt;\u0026gt; names = [\u0026#34;Bob\u0026#34;, \u0026#34;Alice\u0026#34;, \u0026#34;Eve\u0026#34;] \u0026gt;\u0026gt;\u0026gt; scores = [42, 97, 68] The zip function takes any number of iterable arguments and steps through all of them at the same time until the end of the shortest iterable has been reached:\n\u0026gt;\u0026gt;\u0026gt; for name, score in zip(names, scores): \u0026gt;\u0026gt;\u0026gt; print(f\u0026#34;{name} had a score of {score}.\u0026#34;) ... Bob had a score of 42. Alice had a score of 97. Eve had a score of 68. What will the above loop print after removing the last element from scores?\n\u0026gt;\u0026gt;\u0026gt; scores.pop(-1) 68 \u0026gt;\u0026gt;\u0026gt; for name, score in zip(names, scores): \u0026gt;\u0026gt;\u0026gt; print(f\u0026#34;{name} had a score of {score}.\u0026#34;) ... Bob had a score of 42. Alice had a score of 97. The loop terminates even though there are more values in names. Here, Eve isn\u0026rsquo;t included because scores only has two elements.\nWe can also use zip() to quickly and easily create a dict from two lists. For example:\n\u0026gt;\u0026gt;\u0026gt; scores = [42, 97, 68] \u0026gt;\u0026gt;\u0026gt; score_dict = dict(zip(names, scores)) \u0026gt;\u0026gt;\u0026gt; print(score_dict) {\u0026#39;Bob\u0026#39;: 42, \u0026#39;Alice\u0026#39;: 97, \u0026#39;Eve\u0026#39;: 68} "
},
{
	"uri": "https://pythonianrocketship.github.io/en/03-intermediate-python/40-exceptions/90-custom-exceptions/",
	"title": "Custom Exceptions",
	"tags": [],
	"description": "",
	"content": "As we mentioned, exceptions are just regular classes that inherit from the Exception class. This makes it super easy to create our own custom exceptions, which can make our programs easier to follow and more readable. An exception need not be complicated, just inherit from Exception:\n\u0026gt;\u0026gt;\u0026gt; class MyCustomException(Exception): ... pass ... \u0026gt;\u0026gt;\u0026gt; raise MyCustomException() Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; __main__.MyCustomException It\u0026rsquo;s OK to have a custom Exception subclass that only pass-es - your exception doesn\u0026rsquo;t need to do anything fancy to be useful. Having custom exceptions - tailored to your specific use cases and that you can raise and catch in specific circumstances - can make your code much more readable and robust, and reduce the amount of code you write later to try and figure out what exactly went wrong.\nOf course, you can get as fancy as you want. You can send additional information, like messages, to your exceptions. Just add an __init__() method to your exception class, with whatever arguments you want.\nclass IncorrectValueError(Exception): ... def __init__(self, value): ... message = f\u0026#34;Got an incorrect value of {value}\u0026#34; ... super().__init__(message) ... \u0026gt;\u0026gt;\u0026gt; my_value = 9999 \u0026gt;\u0026gt;\u0026gt; if my_value \u0026gt; 100: ... raise IncorrectValueError(my_value) ... Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 2, in \u0026lt;module\u0026gt; __main__.IncorrectValueError: Got an incorrect value of 9999 Exception takes an optional string argument message that gets printed with your exception. We pass our erroneous value to our IncorrectValueError object, which constructs a special message and passes it its parent class, Exception, via super().__init__(). The custom message string, along with the value for context, gets printed along with our error traceback.\nA Custom Exception for our GitHub API app If we wanted to write a custom Exception for our GitHub API app, it might look something like this.\nclass GitHubApiException(Exception): def __init__(self, status_code): if status_code == 403: message = \u0026#34;Rate limit reached. Please wait a minute and try again.\u0026#34; else: message = f\u0026#34;HTTP Status Code was: {status_code}.\u0026#34; super().__init__(message) Notice how it takes the HTTP status code into account, and displays a custom error message for the 403, rate limited reached status code.\n"
},
{
	"uri": "https://pythonianrocketship.github.io/en/03-intermediate-python/20-advanced-looping/90-exercise/",
	"title": "Practice",
	"tags": [],
	"description": "",
	"content": "Comprehensions Let\u0026rsquo;s practice our comprehensions. Create a list of only odd numbers between 0 and 100 using a list comprehension. Then, use a comprehension to create a dictionary where the keys are the even numbers from your list, and the values are random integers between 0 and 100 (hint: try random.randint(min, max)). Finally, use a comprehension to create a set of every unique value from the above dictionary.\n\u0026gt;\u0026gt;\u0026gt; my_list = [num for num in range(0, 100) if num % 2 == 0] \u0026gt;\u0026gt;\u0026gt; print(my_list) \u0026gt;\u0026gt;\u0026gt; import random \u0026gt;\u0026gt;\u0026gt; my_dict = {num:random.randint(0, 100) for num in my_list} \u0026gt;\u0026gt;\u0026gt; print(my_dict) \u0026gt;\u0026gt;\u0026gt; my_set = {num for num in my_dict.values()} \u0026gt;\u0026gt;\u0026gt; print(my_set) Here\u0026#39;s what you should have seen in your REPL: \u0026gt;\u0026gt;\u0026gt; my_list = [num for num in range(0, 100) if num % 2 == 0] \u0026gt;\u0026gt;\u0026gt; print(my_list) [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98] \u0026gt;\u0026gt;\u0026gt; import random \u0026gt;\u0026gt;\u0026gt; my_dict = {num:random.randint(0, 100) for num in my_list} \u0026gt;\u0026gt;\u0026gt; print(my_dict) {0: 37, 2: 84, 4: 56, 6: 45, 8: 63, 10: 57, 12: 39, 14: 25, 16: 18, 18: 10, 20: 52, 22: 95, 24: 93, 26: 89, 28: 96, 30: 77, 32: 16, 34: 91, 36: 19, 38: 14, 40: 92, 42: 35, 44: 85, 46: 86, 48: 44, 50: 32, 52: 38, 54: 34, 56: 23, 58: 71, 60: 37, 62: 100, 64: 98, 66: 15, 68: 84, 70: 40, 72: 47, 74: 30, 76: 42, 78: 36, 80: 62, 82: 49, 84: 11, 86: 58, 88: 60, 90: 6, 92: 41, 94: 28, 96: 16, 98: 93} \u0026gt;\u0026gt;\u0026gt; my_set = {num for num in my_dict.values()} \u0026gt;\u0026gt;\u0026gt; print(my_set) {6, 10, 11, 14, 15, 16, 18, 19, 23, 25, 28, 30, 32, 34, 35, 36, 37, 38, 39, 40, 41, 42, 44, 45, 47, 49, 52, 56, 57, 58, 60, 62, 63, 71, 77, 84, 85, 86, 89, 91, 92, 93, 95, 96, 98, 100} Slicing You know how to create a list of even or odd numbers with a list comprehension. Make a list of numbers between 0 and 100, then try making a list of even numbers between 30 and 70, by taking a slice from the first list. Then, make a new list in the reverse order.\n\u0026gt;\u0026gt;\u0026gt; my_list = [num for num in range(0, 100)] \u0026gt;\u0026gt;\u0026gt; my_slice = my_list[30:70:2] \u0026gt;\u0026gt;\u0026gt; print(my_slice) \u0026gt;\u0026gt;\u0026gt; my_backwards_slice = my_slice[::-1] \u0026gt;\u0026gt;\u0026gt; print(my_backwards_slice) Here\u0026#39;s what you should have seen in your REPL: \u0026gt;\u0026gt;\u0026gt; my_list = [num for num in range(0, 100)] \u0026gt;\u0026gt;\u0026gt; my_slice = my_list[30:70:2] \u0026gt;\u0026gt;\u0026gt; print(my_slice) [30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68] \u0026gt;\u0026gt;\u0026gt; my_backwards_slice = my_slice[::-1] \u0026gt;\u0026gt;\u0026gt; print(my_backwards_slice) [68, 66, 64, 62, 60, 58, 56, 54, 52, 50, 48, 46, 44, 42, 40, 38, 36, 34, 32, 30] zip Make a list of all the names you can think of, called \u0026ldquo;names\u0026rdquo;. Make a second list of numbers, called \u0026ldquo;scores\u0026rdquo;, using a list comprehension and random.randint(min, max) as before. Use the first list in your comprehension to make it the same length. Then, use zip() to output a simple scoreboard of one score per name.\n\u0026gt;\u0026gt;\u0026gt; names = [\u0026#34;Nina\u0026#34;, \u0026#34;Max\u0026#34;, \u0026#34;Floyd\u0026#34;, \u0026#34;Lloyd\u0026#34;] \u0026gt;\u0026gt;\u0026gt; scores = [random.randint(0, 100) for name in names] \u0026gt;\u0026gt;\u0026gt; scores [41, 38, 96, 81] \u0026gt;\u0026gt;\u0026gt; for name, score in zip(names, scores): ... print(f\u0026#34;{name} got a score of {score}\u0026#34;) ... Here\u0026#39;s what you should have seen in your REPL: \u0026gt;\u0026gt;\u0026gt; names = [\u0026#34;Nina\u0026#34;, \u0026#34;Max\u0026#34;, \u0026#34;Floyd\u0026#34;, \u0026#34;Lloyd\u0026#34;] \u0026gt;\u0026gt;\u0026gt; scores = [random.randint(0, 100) for name in names] \u0026gt;\u0026gt;\u0026gt; scores [41, 38, 96, 81] \u0026gt;\u0026gt;\u0026gt; for name, score in zip(names, scores): ... print(f\u0026#34;{name} got a score of {score}\u0026#34;) ... Nina got a score of 41 Max got a score of 38 Floyd got a score of 96 Lloyd got a score of 81 "
},
{
	"uri": "https://pythonianrocketship.github.io/en/03-intermediate-python/40-exceptions/99-exercise/",
	"title": "Practice",
	"tags": [],
	"description": "",
	"content": "Syntax Errors Let\u0026rsquo;s get more comfortable with exceptions. First, you\u0026rsquo;ve probably seen this one already: The IndentationError.\n\u0026gt;\u0026gt;\u0026gt; def my_function(): ... print(\u0026#34;Hello!\u0026#34;) File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 2 print(\u0026#34;Hello!\u0026#34;) ^ IndentationError: expected an indented block Notice that we started a new function scope with the def keyword, but didn\u0026rsquo;t indent the next line of the function, the print() argument.\nYou\u0026rsquo;ve probably also seen the more general SyntaxError. This one\u0026rsquo;s probably obvious - something is misspelled, or the syntax is otherwise wrong. Python gives us a helpful little caret ^ under the earliest point where the error was detected, however you\u0026rsquo;ll have to learn to read this with a critical eye as sometimes the actual mistake precedes the invalid syntax. For example:\n\u0026gt;\u0026gt;\u0026gt; a = [4, ... x = 5 File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 2 x = 5 ^ SyntaxError: invalid syntax Here, the invalid syntax is x = 5, because assignment statements aren\u0026rsquo;t valid list elements, however the actual error is the missing right bracket ] on the line above.\nCommon Exceptions You\u0026rsquo;ll get plenty of practice triggering syntax errors on your own. Let\u0026rsquo;s practice triggering some exceptions. Type this perfectly valid code into your REPL and see what happens:\n\u0026gt;\u0026gt;\u0026gt; a = 1 / 0 Here\u0026#39;s what you should have seen in your REPL: \u0026gt;\u0026gt;\u0026gt; a = 1 / 0 Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; ZeroDivisionError: division by zero Of course, you\u0026rsquo;ll get a divide-by-zero error, or as Python calls it, ZeroDivisionError. Some other common errors are TypeError when trying to perform an action on two unrelated types, KeyError when trying to access a dictionary key that doesn\u0026rsquo;t exist, and AttributeError when trying to access a variable or call a function that doesn\u0026rsquo;t exist on an object.\n\u0026gt;\u0026gt;\u0026gt; 2 + \u0026#34;3\u0026#34; \u0026gt;\u0026gt;\u0026gt; my_dict = {\u0026#34;hello\u0026#34;: \u0026#34;world\u0026#34;} \u0026gt;\u0026gt;\u0026gt; my_dict[\u0026#34;foo\u0026#34;] \u0026gt;\u0026gt;\u0026gt; my_dict.append(\u0026#34;foo\u0026#34;) Here\u0026#39;s what you should have seen in your REPL: \u0026gt;\u0026gt;\u0026gt; 2 + \u0026#34;3\u0026#34; Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; TypeError: unsupported operand type(s) for +: \u0026#39;int\u0026#39; and \u0026#39;str\u0026#39; \u0026gt;\u0026gt;\u0026gt; my_dict = {\u0026#34;hello\u0026#34;: \u0026#34;world\u0026#34;} \u0026gt;\u0026gt;\u0026gt; my_dict[\u0026#34;foo\u0026#34;] Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; KeyError: \u0026#39;foo\u0026#39; \u0026gt;\u0026gt;\u0026gt; my_dict.append(\u0026#34;foo\u0026#34;) Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; AttributeError: \u0026#39;dict\u0026#39; object has no attribute \u0026#39;append\u0026#39; Raising our own Exceptions Making our own Exceptions is cheap and easy, and useful for keeping track of various error states that are specific to your application. Simply inherit from the general Exception class:\n\u0026gt;\u0026gt;\u0026gt; class MyException(Exception): ... pass \u0026gt;\u0026gt;\u0026gt; raise MyException() Here\u0026#39;s what you should have seen in your REPL: \u0026gt;\u0026gt;\u0026gt; class MyException(Exception): ... pass \u0026gt;\u0026gt;\u0026gt; raise MyException() Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; __main__.MyException It\u0026rsquo;s also sometimes helpful to change the default behavior for your custom Exceptions. In this case, you can simply provide your own __init__() method inside your Exception subclass:\nclass MyException(Exception): ... def __init__(self, message): ... new_message = f\u0026#34;!!!ERROR!!! {message}\u0026#34; ... super().__init__(new_message) ... \u0026gt;\u0026gt;\u0026gt; raise MyException(\u0026#34;Something went wrong!\u0026#34;) Here\u0026#39;s what you should have seen in your REPL: class MyException(Exception): ... def __init__(self, message): ... new_message = f\u0026#34;!!!ERROR!!! {message}\u0026#34; ... super().__init__(new_message) ... \u0026gt;\u0026gt;\u0026gt; raise MyException(\u0026#34;Something went wrong!\u0026#34;) Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; __main__.MyException: !!!ERROR!!! Something went wrong! try, except In Python, the \u0026ldquo;try-catch\u0026rdquo; statements use try and except. As we discussed, try is the code that could possibly throw an Exception, and except is the code that runs if the error is raised. Practice catching a KeyError by trying to access a fake dictionary key:\n\u0026gt;\u0026gt;\u0026gt; try: ... my_dict = {\u0026#34;hello\u0026#34;: \u0026#34;world\u0026#34;} ... print(my_dict[\u0026#34;foo\u0026#34;]) ... except KeyError: ... print(\u0026#34;Oh no! That key doesn\u0026#39;t exist\u0026#34;) ... Here\u0026#39;s what you should have seen in your REPL: \u0026gt;\u0026gt;\u0026gt; try: ... my_dict = {\u0026#34;hello\u0026#34;: \u0026#34;world\u0026#34;} ... print(my_dict[\u0026#34;foo\u0026#34;]) ... except KeyError: ... print(\u0026#34;Oh no! That key doesn\u0026#39;t exist\u0026#34;) ... Oh no! That key doesn\u0026#39;t exist Let\u0026rsquo;s add in catching the specific KeyError object so that we can access it during the except block:\n\u0026gt;\u0026gt;\u0026gt; try: ... my_dict = {\u0026#34;hello\u0026#34;: \u0026#34;world\u0026#34;} ... print(my_dict[\u0026#34;foo\u0026#34;]) ... except KeyError as key_error: ... print(f\u0026#34;Oh no! The key {key_error} doesn\u0026#39;t exist!\u0026#34;) ... Here\u0026#39;s what you should have seen in your REPL: \u0026gt;\u0026gt;\u0026gt; try: ... my_dict = {\u0026#34;hello\u0026#34;: \u0026#34;world\u0026#34;} ... print(my_dict[\u0026#34;foo\u0026#34;]) ... except KeyError as key_error: ... print(f\u0026#34;Oh no! The key {key_error} doesn\u0026#39;t exist!\u0026#34;) ... Oh no! The key \u0026#39;foo\u0026#39; doesn\u0026#39;t exist! Re-Raising Sometimes it\u0026rsquo;s helpful to catch an error, perform an action, and then pass the error on rather than swallowing it. This is useful when, for example, something goes wrong deep inside your code and you need to perform a special action, but also let code further up the chain know that something is wrong and the program can\u0026rsquo;t continue. Let\u0026rsquo;s divide one number by other, decrementing until we hit zero. Catch that error and immediately raise a RuntimeError:\n\u0026gt;\u0026gt;\u0026gt; while True: ... for divisor in range(5, -1, -1): ... try: ... quotient = 10 / divisor ... print(f\u0026#34;10 / {divisor} = {quotient}\u0026#34;) ... except ZeroDivisionError: ... print(\u0026#34;Oops! We tried to divide by zero!\u0026#34;) ... raise RuntimeError ... Here\u0026#39;s what you should have seen in your REPL: \u0026gt;\u0026gt;\u0026gt; while True: ... for divisor in range(5, -1, -1): ... try: ... quotient = 10 / divisor ... print(f\u0026#34;10 / {divisor} = {quotient}\u0026#34;) ... except ZeroDivisionError: ... print(\u0026#34;Oops! We tried to divide by zero!\u0026#34;) ... raise RuntimeError ... 10 / 5 = 2.0 10 / 4 = 2.5 10 / 3 = 3.3333333333333335 10 / 2 = 5.0 10 / 1 = 10.0 Oops! We tried to divide by zero! Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 4, in \u0026lt;module\u0026gt; ZeroDivisionError: division by zero During handling of the above exception, another exception occurred: Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 8, in \u0026lt;module\u0026gt; RuntimeError What happened here? We got two exceptions! First, our code hit the ZeroDivisionError, which we caught, and printed our \u0026ldquo;Oops!\u0026rdquo; message. Then, the interpreter saw that we raised a RuntimeError, which we didn\u0026rsquo;t catch, so it broke us out of our while True loop and ended the program with a Traceback.\n"
},
{
	"uri": "https://pythonianrocketship.github.io/en/03-intermediate-python/10-introduction/15-converting-between-types/10-exercise/",
	"title": "Practice",
	"tags": [],
	"description": "",
	"content": "Converting Between Types Converting between types in Python is one of the most powerful language features.\nYou can quickly convert between strings, numbers, and various data-types to supercharge quickly solving problems. You can even use powerful data structures like sets to your advantage.\nConverting Between Numbers and Strings Converting between numbers and strings is easy with str() and int():\n\u0026gt;\u0026gt;\u0026gt; my_string = str(100) \u0026gt;\u0026gt;\u0026gt; my_string \u0026gt;\u0026gt;\u0026gt; type(my_string) \u0026gt;\u0026gt;\u0026gt; my_int = int(my_string) \u0026gt;\u0026gt;\u0026gt; my_int \u0026gt;\u0026gt;\u0026gt; type(my_int) You can also use float() to convert strings into floating point numbers:\n\u0026gt;\u0026gt;\u0026gt; float(\u0026#34;3.1415\u0026#34;) 3.1415 Bonus tip: int() works great for converting floats as well, as long as you don\u0026rsquo;t care about the mantissa (the part after the decimal point):\n\u0026gt;\u0026gt;\u0026gt; int(3.1415) Here\u0026#39;s what you should have seen in your REPL: \u0026gt;\u0026gt;\u0026gt; my_string = str(100) \u0026gt;\u0026gt;\u0026gt; my_string \u0026#39;100\u0026#39; \u0026gt;\u0026gt;\u0026gt; type(my_string) \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt; my_int = int(my_string) \u0026gt;\u0026gt;\u0026gt; my_int 100 \u0026gt;\u0026gt;\u0026gt; type(my_int) \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt; float(\u0026#34;3.1415\u0026#34;) 3.1415 \u0026gt;\u0026gt;\u0026gt; int(3.1415) 3 Converting Between Lists and Strings A string can be considered as just a list of characters, so converting back and forth is easy:\n\u0026gt;\u0026gt;\u0026gt; my_list = list(\u0026#34;hello\u0026#34;) \u0026gt;\u0026gt;\u0026gt; my_list \u0026gt;\u0026gt;\u0026gt; str(my_list) Oops, that wasn\u0026rsquo;t quite what we wanted. Running any object through str() will usually return a literal string of that object. What we want is to join the elements of the list (into a string). We can do that using string\u0026rsquo;s built-in join() method. In this case, we\u0026rsquo;ll use an empty string:\n\u0026gt;\u0026gt;\u0026gt; \u0026#39;\u0026#39;.join(my_list) # Note: we can use any string we want to join the characters! \u0026gt;\u0026gt;\u0026gt; \u0026#39;,\u0026#39;.join(my_list) \u0026gt;\u0026gt;\u0026gt; \u0026#39;-\u0026#39;.join(my_list) Another common way of converting a string into a list is with the string\u0026rsquo;s split() method. This is useful for lightweight parsing of, for example, CSV (comma separated value) data.\n\u0026gt;\u0026gt;\u0026gt; my_string = \u0026#34;the,quick,brown,fox\u0026#34; \u0026gt;\u0026gt;\u0026gt; my_string.split(\u0026#34;,\u0026#34;) Here\u0026#39;s what you should have seen in your REPL: \u0026gt;\u0026gt;\u0026gt; my_list = list(\u0026#34;hello\u0026#34;) \u0026gt;\u0026gt;\u0026gt; my_list [\u0026#39;h\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;o\u0026#39;] \u0026gt;\u0026gt;\u0026gt; str(my_list) \u0026#34;[\u0026#39;h\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;o\u0026#39;]\u0026#34; \u0026gt;\u0026gt;\u0026gt; \u0026#39;\u0026#39;.join(my_list) \u0026#39;hello\u0026#39; \u0026gt;\u0026gt;\u0026gt; \u0026#39;,\u0026#39;.join(my_list) \u0026#39;h,e,l,l,o\u0026#39; \u0026gt;\u0026gt;\u0026gt; \u0026#39;-\u0026#39;.join(my_list) \u0026#39;h-e-l-l-o\u0026#39; \u0026gt;\u0026gt;\u0026gt; my_string = \u0026#34;the,quick,brown,fox\u0026#34; \u0026gt;\u0026gt;\u0026gt; my_string.split(\u0026#34;,\u0026#34;) [\u0026#39;the\u0026#39;, \u0026#39;quick\u0026#39;, \u0026#39;brown\u0026#39;, \u0026#39;fox\u0026#39;] "
},
{
	"uri": "https://pythonianrocketship.github.io/en/02-introduction-to-python/080-advanced-datatypes/10-lists/",
	"title": "Lists, Part 1",
	"tags": [],
	"description": "",
	"content": "Lists are one of the most powerful data types in Python. Generally, they\u0026rsquo;re container objects used to store related items together.\nlist cheat sheet type list use Used for storing similar items, and in cases where items need to be added or removed. creation [] or list() for empty list, or [1, 2, 3] for a list with items. search methods my_list.index(item) or item in my_list search speed Searching in an item in a large list is slow. Each item must be checked. common methods len(my_list), append(item) to add, insert(index, item) to insert in the middle, pop() to remove. order preserved? Yes. Items can be accessed by index. mutable? Yes in-place sortable? Yes. my_list.sort() will sort the list in-place. my_list.sort(reverse=True) will sort the list in-place in descending order. my_list.reverse() will reverse the items in my_list in-place. In Practice Let\u0026rsquo;s create a few lists to see how they work.\nAn empty list can be created in two ways. The first, by calling the list() method. More commonly, it\u0026rsquo;s created with two empty brackets []. Don\u0026rsquo;t forget to check the type of the list with the type built-in function.\n\u0026gt;\u0026gt;\u0026gt; list() [] \u0026gt;\u0026gt;\u0026gt; [] [] \u0026gt;\u0026gt;\u0026gt; type(list()) \u0026lt;class \u0026#39;list\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt; type([]) \u0026lt;class \u0026#39;list\u0026#39;\u0026gt; Let\u0026rsquo;s create our list with a few items in it. Let\u0026rsquo;s say we want to keep track of a list of names. We add items to our list, and separate them with commas ,.\n\u0026gt;\u0026gt;\u0026gt; names = [\u0026#34;Nina\u0026#34;, \u0026#34;Max\u0026#34;, \u0026#34;Jane\u0026#34;] We can check its length with the built-in len() method, like so:\n\u0026gt;\u0026gt;\u0026gt; len(names) 3 Indexes and Indices Lists retain the order of the items in them. In the next section, you\u0026rsquo;ll learn about some data structures that don\u0026rsquo;t.\nIn order to access items in a list, we\u0026rsquo;ll need to use an index. (Multiple indexes are sometimes also called indices). The index for the item you want to access is an integer put in square brackets after the list.\nIndexes start at 0 in Python and most other programming languages.\n\u0026gt;\u0026gt;\u0026gt; names = [\u0026#34;Nina\u0026#34;, \u0026#34;Max\u0026#34;, \u0026#34;Jane\u0026#34;] \u0026gt;\u0026gt;\u0026gt; names[0] \u0026#39;Nina\u0026#39; \u0026gt;\u0026gt;\u0026gt; names[1] \u0026#39;Max\u0026#39; \u0026gt;\u0026gt;\u0026gt; names[2] \u0026#39;Jane\u0026#39; Updating an item in a list To update a particular item in a list use square-bracket notion and assign a new value. my_list[pos] = new_value\n\u0026gt;\u0026gt;\u0026gt; names = [\u0026#34;Nina\u0026#34;, \u0026#34;Max\u0026#34;, \u0026#34;Jane\u0026#34;] \u0026gt;\u0026gt;\u0026gt; names[2] = \u0026#34;Floyd\u0026#34; \u0026gt;\u0026gt;\u0026gt; names [\u0026#39;Nina\u0026#39;, \u0026#39;Max\u0026#39;, \u0026#39;Floyd\u0026#39;] If you try to access an index that is greater than or equal to (\u0026gt;=) the length of the list, you\u0026rsquo;ll get an IndexError.\n\u0026gt;\u0026gt;\u0026gt; names = [\u0026#34;Nina\u0026#34;, \u0026#34;Max\u0026#34;, \u0026#34;Jane\u0026#34;] \u0026gt;\u0026gt;\u0026gt; len(names) 3 \u0026gt;\u0026gt;\u0026gt; names[3] Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; IndexError: list index out of range Formatting We can optionally add new lines after the commas. This helps with readability for more complex list items.\nNotice that we can also optionally add a trailing comma after the last item. A trailing comma isn\u0026rsquo;t required to create a valid list, but it does help minimize version control differences when working on a Python codebase with a team.\n\u0026gt;\u0026gt;\u0026gt; names = [ ... \u0026#34;Nina\u0026#34;, ... \u0026#34;Max\u0026#34;, ... \u0026#34;Jane\u0026#34;, ... ] Common Gotchas If you forget to include commas between your items, you\u0026rsquo;ll get a SyntaxError.\n\u0026gt;\u0026gt;\u0026gt; numbers = [1, 2 3] File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1 numbers = [1, 2 3] ^ SyntaxError: invalid syntax The REPL makes it difficult to forget the closing bracket, but if you forget it while writing code in a Python file, you\u0026rsquo;ll see a SyntaxError with a different name. It\u0026rsquo;ll say: SyntaxError: unexpected EOF while parsing or SyntaxError: invalid syntax.\nFor example:\n# Python file: program.py names = [\u0026#34;Nina\u0026#34;, x = 5 Notice how the SyntaxError points to a completely valid line of Python code. In these cases, you also need to check the line of code before the line with the SyntaxError. There, we\u0026rsquo;ll notice that we forgot the closing bracket of our names list.\n# In a shell (env) $ python program.py File \u0026#34;/Users/nina/Desktop/program.py\u0026#34;, line 2 x = 5 ^ SyntaxError: invalid syntax Sorting Sorting sounds complicated, but in practice, it\u0026rsquo;s just one method call away!\nSorting a Copy Of Your List If you\u0026rsquo;d like sort to return a brand new copy of your list, instead of modifying your original copy, you can use the built-in sorted(my_list) function on your list to return a new list, sorted in increasing (ascending) order. Or use sorted(my_list, reverse=True) to create a new list sorted backwards, in decreasing (or descending) order. This operation will not modify the underlying list.\nEither of these operations will return a new list.\n\u0026gt;\u0026gt;\u0026gt; lottery_numbers = [1, 4, 32423, 2, 45, 11] \u0026gt;\u0026gt;\u0026gt; sorted(lottery_numbers) [1, 2, 4, 11, 45, 32423] \u0026gt;\u0026gt;\u0026gt; lottery_numbers [1, 4, 32423, 2, 45, 11] \u0026gt;\u0026gt;\u0026gt; sorted(lottery_numbers, reverse=True) [32423, 45, 11, 4, 2, 1] \u0026gt;\u0026gt;\u0026gt; lottery_numbers [1, 4, 32423, 2, 45, 11] Sorting the list in-place You can call my_list.sort() on your list to sort it in increasing (ascending) order, or my_list.sort(reverse=True) on the list to sort it backwards, in decreasing (or descending) order. This operation will modify the underlying list, and doesn\u0026rsquo;t return a value.\n\u0026gt;\u0026gt;\u0026gt; lottery_numbers = [1, 4, 32423, 2, 45, 11] \u0026gt;\u0026gt;\u0026gt; lottery_numbers.sort() \u0026gt;\u0026gt;\u0026gt; lottery_numbers [1, 2, 4, 11, 45, 32423] \u0026gt;\u0026gt;\u0026gt; lottery_numbers.sort(reverse=True) \u0026gt;\u0026gt;\u0026gt; lottery_numbers [32423, 45, 11, 4, 2, 1] \u0026gt;\u0026gt;\u0026gt; words = [\u0026#34;Umbrella\u0026#34;, \u0026#34;Fox\u0026#34;, \u0026#34;Apple\u0026#34;] \u0026gt;\u0026gt;\u0026gt; words.sort() \u0026gt;\u0026gt;\u0026gt; words [\u0026#39;Apple\u0026#39;, \u0026#39;Fox\u0026#39;, \u0026#39;Umbrella\u0026#39;] Reverse the list in-place To reverse the items of a list in-place, call my_list.reverse() on it.\n\u0026gt;\u0026gt;\u0026gt; lottery_numbers = [1, 4, 32423, 2, 45, 11] \u0026gt;\u0026gt;\u0026gt; lottery_numbers.reverse() \u0026gt;\u0026gt;\u0026gt; lottery_numbers [11, 45, 2, 32423, 4, 1] Finding Methods Remember, if you ever forget which methods are available on list, just call dir on it. Ignore the methods that start with underscores. If you need help remembering what a method does, you can call help() on it. For example, for append, call help(list.append).\n"
},
{
	"uri": "https://pythonianrocketship.github.io/en/02-introduction-to-python/110-control-statements-looping/10-if-else-elif/",
	"title": "if, else, elif",
	"tags": [],
	"description": "",
	"content": "The if Statement and Conditionals if in Python means: only run the rest of this code once, if the condition evaluates to True. Don\u0026rsquo;t run the rest of the code at all if it\u0026rsquo;s not.\nAnatomy of an if statement: Start with the if keyword, followed by a boolean value, an expression that evaluates to True, or a value with \u0026ldquo;Truthiness\u0026rdquo;. Add a colon :, a new line, and write the code that will run if the statement is True under a level of indentation.\nRemember, just like with functions, we know that code is associated with an if statement by it\u0026rsquo;s level of indentation. All the lines indented under the if statement will run if it evaluates to True.\n\u0026gt;\u0026gt;\u0026gt; if 3 \u0026lt; 5: ... print(\u0026#34;Hello, World!\u0026#34;) ... Hello, World! Remember, your if statements only run if the expression in them evaluates to True and just like with functions, you\u0026rsquo;ll need to enter an extra space in the REPL to run it.\nUsing not With if Statements If you only want your code to run if the expression is False, use the not keyword.\n\u0026gt;\u0026gt;\u0026gt; b = False \u0026gt;\u0026gt;\u0026gt; if not b: ... print(\u0026#34;Negation in action!\u0026#34;) ... Negation in action! if Statements and Truthiness if statements also work with items that have a \u0026ldquo;truthiness\u0026rdquo; to them.\nFor example:\nThe number 0 is False-y, any other number (including negatives) is Truth-y An empty list, set, tuple or dict is False-y Any of those structures with items in it is Truth-y \u0026gt;\u0026gt;\u0026gt; message = \u0026#34;Hi there.\u0026#34; \u0026gt;\u0026gt;\u0026gt; a = 0 \u0026gt;\u0026gt;\u0026gt; if a: # 0 is False-y ... print(message) ... \u0026gt;\u0026gt;\u0026gt; b = -1 \u0026gt;\u0026gt;\u0026gt; if b: # -1 is Truth-y ... print(message) ... Hi there. \u0026gt;\u0026gt;\u0026gt; c = [] \u0026gt;\u0026gt;\u0026gt; if c: # Empty list is False-y ... print(message) ... \u0026gt;\u0026gt;\u0026gt; d = [1, 2, 3] \u0026gt;\u0026gt;\u0026gt; if d: # List with items is Truth-y ... print(message) ... Hi there. if Statements and Functions You can easily declare if statements in your functions, you just need to mindful of the level of indentation. Notice how the code belonging to the if statement is indented at two levels.\n\u0026gt;\u0026gt;\u0026gt; def modify_name(name): ... if len(name) \u0026lt; 5: ... return name.upper() ... else: ... return name.lower() ... \u0026gt;\u0026gt;\u0026gt; name = \u0026#34;Nina\u0026#34; \u0026gt;\u0026gt;\u0026gt; modify_name(name) \u0026#39;NINA\u0026#39; Nested if Statements Using the same technique, you can also nest your if statements.\n\u0026gt;\u0026gt;\u0026gt; def num_info(num): ... if num \u0026gt; 0: ... print(\u0026#34;Greater than zero\u0026#34;) ... if num \u0026gt; 10: ... print(\u0026#34;Also greater than 10.\u0026#34;) ... \u0026gt;\u0026gt;\u0026gt; num_info(1) Greater than zero \u0026gt;\u0026gt;\u0026gt; num_info(15) Greater than zero Also greater than 10. How Not To Use if Statements Remember, comparisons in Python evaluate to True or False. With conditional statements, we check for that value implicitly. In Python, we do not want to compare to True or False with ==.\nWarning - pay attention, because the code below shows what you shouldn\u0026rsquo;t do.\n# Warning: Don\u0026#39;t do this! \u0026gt;\u0026gt;\u0026gt; if (3 \u0026lt; 5) == True: # Warning: Don\u0026#39;t do this! ... print(\u0026#34;Hello\u0026#34;) ... Hello # Warning: Don\u0026#39;t do this! \u0026gt;\u0026gt;\u0026gt; if (3 \u0026lt; 5) is True: # Warning: Don\u0026#39;t do this! ... print(\u0026#34;Hello\u0026#34;) ... Hello Do this instead:\n\u0026gt;\u0026gt;\u0026gt; if 3 \u0026lt; 5: ... print(\u0026#34;Hello\u0026#34;) ... Hello If we want to explicitly check if the value is explicitly set to True or False, we can use the is keyword.\n\u0026gt;\u0026gt;\u0026gt; a = True # a is set to True \u0026gt;\u0026gt;\u0026gt; b = [1, 2, 3] # b is a list with items, is \u0026#34;truthy\u0026#34; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; if a and b: # this is True, a is True, b is \u0026#34;truthy\u0026#34; ... print(\u0026#34;Hello\u0026#34;) ... Hello \u0026gt;\u0026gt;\u0026gt; if a is True: # we can explicitly check if a is True ... print(\u0026#34;Hello\u0026#34;) ... Hello \u0026gt;\u0026gt;\u0026gt; if b is True: # b does not contain the actual value of True. ... print(\u0026#34;Hello\u0026#34;) ... \u0026gt;\u0026gt;\u0026gt; else The else statement is what you want to run if and only if your if statement wasn\u0026rsquo;t triggered.\nAn else statement is part of an if statement. If your if statement ran, your else statement will never run.\n\u0026gt;\u0026gt;\u0026gt; a = True \u0026gt;\u0026gt;\u0026gt; if a: ... print(\u0026#34;Hello\u0026#34;) ... else: ... print(\u0026#34;Goodbye\u0026#34;) ... Hello And vice-versa.\n\u0026gt;\u0026gt;\u0026gt; a = False \u0026gt;\u0026gt;\u0026gt; if a: ... print(\u0026#34;Hello\u0026#34;) ... else: ... print(\u0026#34;Goodbye\u0026#34;) ... Goodbye In the REPL it must be written on the line after your last line of indented code. In Python code in a file, there can\u0026rsquo;t be any other code between the if and the else.\nYou\u0026rsquo;ll see SyntaxError: invalid syntax if you try to write an else statement on its own, or put extra code between the if and the else in a Python file.\n\u0026gt;\u0026gt;\u0026gt; if a: ... print(\u0026#34;Hello\u0026#34;) ... Hello \u0026gt;\u0026gt;\u0026gt; else: File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1 else: ^ SyntaxError: invalid syntax elif Means Else, If. elif means else if. It means, if this if statement isn\u0026rsquo;t considered True, try this instead.\nYou can have as many elif statements in your code as you want. They get evaluated in the order that they\u0026rsquo;re declared until Python finds one that\u0026rsquo;s True. That runs the code defined in that elif, and skips the rest.\n\u0026gt;\u0026gt;\u0026gt; a = 5 \u0026gt;\u0026gt;\u0026gt; if a \u0026gt; 10: ... print(\u0026#34;Greater than 10\u0026#34;) ... elif a \u0026lt; 10: ... print(\u0026#34;Less than 10\u0026#34;) ... elif a \u0026lt; 20: ... print(\u0026#34;Less than 20\u0026#34;) ... else: ... print(\u0026#34;Dunno\u0026#34;) ... Less than 10 "
},
{
	"uri": "https://pythonianrocketship.github.io/en/02-introduction-to-python/090-boolean-logic/10-truthiness/",
	"title": "Truthiness",
	"tags": [],
	"description": "",
	"content": "Evaluating expression to be True or False will help us control the flow of our program.\ncheat sheet type truthiness int 0 is False, all other numbers are True (including negative) containers - list, tuple, set, dict empty container evaluates to False, container with items evaluates to True) None False We talked about boolean types, True and False earlier. True and False are keywords in Python, so make sure you don\u0026rsquo;t name your variables the same thing.\n\u0026gt;\u0026gt;\u0026gt; True True \u0026gt;\u0026gt;\u0026gt; False False Sometimes the truth is obvious. For example 3 \u0026lt; 5 is always True. Other times, in Python, the truth value might surprise you. Let\u0026rsquo;s review. First, let\u0026rsquo;s start with an expression we know is always True.\n\u0026gt;\u0026gt;\u0026gt; 3 \u0026lt; 5 True Tip: If you want to test your assumptions about an expression that returns True or False, you can pass it into the constructor for booleans: bool(expression).\nNumbers In Python, the integer 0 is always False, while every other number, including negative numbers, are True. In fact, under the hood, booleans inherit from integers.\n\u0026gt;\u0026gt;\u0026gt; bool(0) False \u0026gt;\u0026gt;\u0026gt; bool(1) True \u0026gt;\u0026gt;\u0026gt; bool(-1) True Sequences Empty sequences in Python always evaluate to False, including empty strings.\n\u0026gt;\u0026gt;\u0026gt; bool(\u0026#34;\u0026#34;) # String False \u0026gt;\u0026gt;\u0026gt; bool([]) # Empty List False \u0026gt;\u0026gt;\u0026gt; bool(set()) # Empty Set False \u0026gt;\u0026gt;\u0026gt; bool({}) # Empty Dictionary False \u0026gt;\u0026gt;\u0026gt; bool(()) # Empty Tuple False Sequences with at least one value will evaluate to True.\n\u0026gt;\u0026gt;\u0026gt; bool(\u0026#34;Hello\u0026#34;) # String True \u0026gt;\u0026gt;\u0026gt; bool([1]) # List True \u0026gt;\u0026gt;\u0026gt; bool({1}) # Set True \u0026gt;\u0026gt;\u0026gt; bool({1: 1}) # Dictionary True \u0026gt;\u0026gt;\u0026gt; bool((1,)) # Tuple True None The None type in Python represents nothing. No returned value. It shouldn\u0026rsquo;t come as a surprise that the truthiness of None is False.\n\u0026gt;\u0026gt;\u0026gt; bool(None) False None is commonly used as a placeholder to mean \u0026ldquo;I haven\u0026rsquo;t set this value yet.\u0026rdquo; Since empty strings and sequence evaluate to False, we need to be very careful when we\u0026rsquo;re checking if a sequence has been declared or not, or if it\u0026rsquo;s empty. We\u0026rsquo;ll review this concept again when talking about if statements later in the day.\n\u0026gt;\u0026gt;\u0026gt; my_name = None \u0026gt;\u0026gt;\u0026gt; bool(my_name) False \u0026gt;\u0026gt;\u0026gt; my_name = \u0026#34;\u0026#34; \u0026gt;\u0026gt;\u0026gt; bool(my_name) False \u0026gt;\u0026gt;\u0026gt; my_list = None \u0026gt;\u0026gt;\u0026gt; bool(my_list) False \u0026gt;\u0026gt;\u0026gt; my_list = [] \u0026gt;\u0026gt;\u0026gt; bool(my_list) False "
},
{
	"uri": "https://pythonianrocketship.github.io/en/02-introduction-to-python/175-running-code/10-running-python-programs/",
	"title": "How To Run Them",
	"tags": [],
	"description": "",
	"content": "Creating Python Files with the *.py extension You know a file is a Python program when it ends with a .py extension.\nNaming Tips Just like with formatting, Python\u0026rsquo;s PEP8 guidelines give us a few helpful tips about how to name our Python program files.\nℹ️ In Python:\nFilenames should be *all lowercase Words should be separated with underscores _ Filenames should be short ✅ Some good example filenames:\napis.py exceptions.py personal_blog.py ⛔️ Some bad example filenames:\nMYFILE.PY CamelCaseFile.py really_long_over_descriptive_project_file_name.py What are *.pyc files? For optimization and other reasons, Python code can be compiled to intermediary .pyc files. The good news is you don\u0026rsquo;t have to worry about them. The bad news is, very occasionally stale versions of these compiled files can cause problems. To safely delete them from the current project directory, run find . -name \u0026quot;*.pyc\u0026quot; -delete (on linux or macOS).\ngit tip: use a .gitignore for Python If you use git for source control, you\u0026rsquo;ll want to make sure that these compiled *.pyc files are ignored, and not added to your repository.\nThe best way to do this is to add the standard .gitignore file for Python to your project.\nRunning Python Files From VS Code Running Python files from VS Code is really quick and easy.\nCreating New Python Files To create a new file in VS Code, hit Ctrl+N on Windows and Linux, and ⌘N (command + N) on Mac OS.\nThis will open a new file. Next, save the file with a .py extension.\nCreate a new simple Python program in a file called hello.py in our pyworkshop direc tory with the following contents:\n# in file: hello.py greetings = [\u0026#34;Hello\u0026#34;, \u0026#34;Bonjour\u0026#34;, \u0026#34;Hola\u0026#34;] for greeting in greetings: print(f\u0026#34;{greeting}, World!\u0026#34;) Opening The VS Code Terminal Window Next, you\u0026rsquo;ll need to open your terminal if you don\u0026rsquo;t have it open already. The quick keyboard shortcut to do that is Ctrl - `\nIf you already had your Python REPL open, you\u0026rsquo;ll need to select a terminal with a shell in it (generally, the one labeled with 1:).\nRunning The File Once you\u0026rsquo;ve opened your hello.py file and selected your new terminal window, open the VS Code command palette.\nOpen the command palette with Ctrl+Shift+P on Windows and Linux, and ⌘⇧P (command + shift + P) on Mac OS.\nSelect Python: Run Python File in Terminal\nYou should see:\nHello, World! Bonjour, World! Hola, World! How easy was that? 🎉\nRunning Python Files From a Non-VS Code Terminal If you want to run a Python file without using the command palette, just open your terminal of choice, cd into the directory with your code, and type in the command python followed by a space, and the name of your Python program.\n(env) $ python hello.py Hello, World! Bonjour, World! Hola, World! This also works in the VS Code terminal.\n"
},
{
	"uri": "https://pythonianrocketship.github.io/en/02-introduction-to-python/060-functions/10-defining-functions/",
	"title": "Defining Functions",
	"tags": [],
	"description": "",
	"content": "The purpose of functions in Python are to create reusable code. If we find ourselves copying and pasting the same code multiple times, that\u0026rsquo;s a good sign that a function might help!\nAnatomy of a function This is the recipe for defining a Python function:\ndef: the def keyword, telling Python we\u0026rsquo;re about to start a function definition a name for the function (: opening parenthesis (optional) the names of one or more arguments, separated with , (optional) the names and values of one or more default arguments, separated with (,) note: we\u0026rsquo;ll see these in the next section ) closing parenthesis : a colon A function in Python is defined with the def keyword, followed by the function names, zero or more argument names contained in parenthesis (), and a colon : to indicate the start of the function.\nThe contents of the function then follow.\nThen, an optional return statement can follow, if the function plans on passing data back to the caller.\n# A Basic Function that accepts no arguments and returns nothing. def hello_world(): print(\u0026#34;Hello, World!\u0026#34;) # A Function that accepts two arguments, and returns the value of # those numbers added together. def add_numbers(x, y): return x + y If you forget the recipe while trying to create a function, Python will help you remember with a SyntaxError.\nFor example, trying to create a function without the colon ::\n\u0026gt;\u0026gt;\u0026gt; def hello_world() File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1 def hello_world() ^ SyntaxError: invalid syntax And trying to create a function without the parenthesis ():\n\u0026gt;\u0026gt;\u0026gt; def hello_world: File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1 def hello_world: ^ SyntaxError: invalid syntax Function Contents The recipe for function contents:\na new line indentation (press tab on your keyboard) one or more lines (optional) a return statement return statement A return statement is a way to \u0026ldquo;short-circuit\u0026rdquo; the function.\nUsing a return statement, you can optionally pass back data to the caller of your function.\nwith no return statement If a function doesn\u0026rsquo;t have a return statement, it implicitly returns None.\n\u0026gt;\u0026gt;\u0026gt; def foo(): ... x = 5 ... \u0026gt;\u0026gt;\u0026gt; val = foo() \u0026gt;\u0026gt;\u0026gt; type(val) \u0026lt;type \u0026#39;NoneType\u0026#39;\u0026gt; with a return statement, but no value If a function has a return statement, but no value, it also returns None. This is typically used to control the flow of a program.\n\u0026gt;\u0026gt;\u0026gt; def foo(): ... x = 5 ... return ... \u0026gt;\u0026gt;\u0026gt; val = foo() \u0026gt;\u0026gt;\u0026gt; type(val) \u0026lt;type \u0026#39;NoneType\u0026#39;\u0026gt; with a return statement and a value To return a value from a function, just type it after the return statement. You can return anything from a Python function, including other functions! For today, we\u0026rsquo;ll focus on simple and complex data types.\n\u0026gt;\u0026gt;\u0026gt; def foo(): ... x = 5 ... return x ... \u0026gt;\u0026gt;\u0026gt; val = foo() \u0026gt;\u0026gt;\u0026gt; val 5 As we explore simple functions, our return statements will usually be at the end of the function, but that\u0026rsquo;s not the only way they can be used. A function can have multiple return statements, and those return statements can be used to help control the flow of the program.\nNote: Because it\u0026rsquo;s syntactically correct to have multiple return statements in a function, it\u0026rsquo;s up to you to use them correctly. If you use a linter for your code files and you place additional code in a function after a return statement, the linter will give you a helpful hint about the rest of the code being unreachable.\nIndentation One of the most important aspects of functions is indentation. Remember, Python doesn\u0026rsquo;t use curly braces to figure out what\u0026rsquo;s inside a function like other languages you\u0026rsquo;ve seen like JavaScript or Java.\nPython knows what code is related to a function by how it\u0026rsquo;s indented. Anything that\u0026rsquo;s indented one level deep under the function declaration is part of the function, no matter how many spaces there are between lines.\nTo add a level of indentation, just press the Tab key on your keyboard after entering a new line.\nIf you\u0026rsquo;re using the REPL, once you\u0026rsquo;re done entering your function, you\u0026rsquo;ll need to press enter an additional time, to mark the end of the function. You know you\u0026rsquo;re done defining your function when you see the 3 input arrows \u0026gt;\u0026gt;\u0026gt; again.\nLet\u0026rsquo;s try it together. Type the following code in your REPL. Note that the 3 dots \u0026lsquo;\u0026hellip;\u0026rsquo; indicate that those lines are indented in the REPL. If you type your code in a Python file, you won\u0026rsquo;t see the ... dots.\n\u0026gt;\u0026gt;\u0026gt; def add_numbers(x, y): ... return x + y ... See an error? Expand this section. Note: If you get an IndentationError, that means that you didn\u0026rsquo;t correctly indent your code after your function definition. Try typing your function into the REPL one more time.\n# The error you\u0026#39;ll see if you didn\u0026#39;t indent your function correctly. \u0026gt;\u0026gt;\u0026gt; def add_numbers(x, y): ... return x + y File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 2 return x + y ^ IndentationError: expected an indented block Calling Functions With no arguments Once you\u0026rsquo;ve defined a function, you can call it from your Python code as many times as you\u0026rsquo;d like.\nTo call a Python function, type in it\u0026rsquo;s name, along with parenthesis, and any required arguments to the function. Let\u0026rsquo;s try it now, with a function that doesn\u0026rsquo;t require arguments.\n\u0026gt;\u0026gt;\u0026gt; def hello_world(): ... print(\u0026#34;Hello, World!\u0026#34;) ... \u0026gt;\u0026gt;\u0026gt; hello_world() Hello, World! With arguments Let\u0026rsquo;s try it again, this time with a function that does accept arguments.\nHere, note that the function accepts names for the arguments. But, when we call the function, we\u0026rsquo;re passing in values.\n\u0026gt;\u0026gt;\u0026gt; def add_numbers(x, y): ... return x + y ... \u0026gt;\u0026gt;\u0026gt; add_numbers(3, 5) 8 \u0026gt;\u0026gt;\u0026gt; Storing the returned value of a function. Storing the returned value of a function is easy. All you need to do is assign it to a variable.\nLet\u0026rsquo;s try it now.\n\u0026gt;\u0026gt;\u0026gt; def add_numbers(x, y): ... return x + y ... \u0026gt;\u0026gt;\u0026gt; new_number = add_numbers(3, 5) \u0026gt;\u0026gt;\u0026gt; new_number 8 The variable new_number now contains the result of running our add_numbers function with our arguments 3 and 5.\n"
},
{
	"uri": "https://pythonianrocketship.github.io/en/02-introduction-to-python/020-basic-data-types/10-exercise/",
	"title": "Practice",
	"tags": [],
	"description": "",
	"content": "Basic Data Types, Strings and Numbers Types List the type of the following variables using the type() function.\n\u0026gt;\u0026gt;\u0026gt; x = 42 \u0026gt;\u0026gt;\u0026gt; y = 3 / 4 \u0026gt;\u0026gt;\u0026gt; z = int(\u0026#39;7\u0026#39;) \u0026gt;\u0026gt;\u0026gt; a = float(5) \u0026gt;\u0026gt;\u0026gt; name = \u0026#34;Nina\u0026#34; Numbers Calculate the amount of rent you pay daily, by taking your monthly rent and diving it by 30.\n\u0026gt;\u0026gt;\u0026gt; rent = 480 \u0026gt;\u0026gt;\u0026gt; per_day = rent / 30 \u0026gt;\u0026gt;\u0026gt; print(per_day) 16.0 Strings Try printing some things to your REPL:\n\u0026gt;\u0026gt;\u0026gt; print(\u0026#34;Hello world\u0026#34;) Hello world \u0026gt;\u0026gt;\u0026gt; name = \u0026#34;Nina\u0026#34; \u0026gt;\u0026gt;\u0026gt; print(\u0026#34;My name is\u0026#34;, name) My name is Nina There are three different ways to format strings in Python3. You may run into %-formatting and str.format() in older code. These are still common in Python but no longer recommended, due to readability concerns.\n\u0026gt;\u0026gt;\u0026gt; name = \u0026#34;Nina\u0026#34; \u0026gt;\u0026gt;\u0026gt; print(\u0026#34;Hello, my name is %s\u0026#34; % name) Hello, my name is Nina The current recommended way to format string is with f-Strings. f-Strings are much more readable and easier to maintain than the previous methods. With f-Strings, your string is prepended with the letter f and your variables or expressions to interpret are placed in {brackets}.\n\u0026gt;\u0026gt;\u0026gt; name = \u0026#34;Nina\u0026#34; \u0026gt;\u0026gt;\u0026gt; print(f\u0026#34;Hello, my name is {name} and I pay ${rent / 30} in rent per day\u0026#34;) Hello, my name is Nina and I pay $16.0 in rent per day Helper Functions Python has a few built-in functions to help you if you get stuck. type() tells you what an object\u0026rsquo;s type is, for example a string (str) or integer (int). dir() returns a list of valid attributes for an object, so you can quickly see what variables an object has or what functions you can call on it. help() brings up helpful documentation on any object. You can also type help() on its own to bring an interactive help console.\n\u0026gt;\u0026gt;\u0026gt; x = 42 \u0026gt;\u0026gt;\u0026gt; y = 3 / 4 \u0026gt;\u0026gt;\u0026gt; name = \u0026#34;Nina\u0026#34; \u0026gt;\u0026gt;\u0026gt; type(x) \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt; type(y) \u0026lt;class \u0026#39;float\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt; type(name) \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; "
},
{
	"uri": "https://pythonianrocketship.github.io/en/03-intermediate-python/10-introduction/",
	"title": "More Python Ideas",
	"tags": [],
	"description": "",
	"content": "Chapter 1 More Python Ideas Let\u0026rsquo;s learn a little more about Python, and talk about more best practices, to help you get an idea of what \u0026ldquo;good\u0026rdquo; Python code should look like.\n"
},
{
	"uri": "https://pythonianrocketship.github.io/en/02-introduction-to-python/010-best-practices/",
	"title": "Why Choose Python",
	"tags": [],
	"description": "",
	"content": "Chapter 1 Why Python? Let\u0026rsquo;s talk about the anatomy of a Python program, what makes Python unique, and cover some best practices.\n"
},
{
	"uri": "https://pythonianrocketship.github.io/en/03-intermediate-python/30-oop-classes-inheritance/90-exercise/",
	"title": "Practice",
	"tags": [],
	"description": "",
	"content": "classes and self Let\u0026rsquo;s practice making a simple class. Open a new file and save it as class_example.py, we\u0026rsquo;ll be running this from the command line rather than the REPL. Pass in several variables and save them to the instance by using self:\nclass Vehicle: def __init__(self, make, model, fuel=\u0026#34;gas\u0026#34;): self.make = make self.model = model self.fuel = fuel daily_driver = Vehicle(\u0026#34;Subaru\u0026#34;, \u0026#34;Crosstrek\u0026#34;) # By default, this is how python represents our object: print(daily_driver) # The variables we saved to the instance are available like this: print(f\u0026#34;I drive a {daily_driver.make} {daily_driver.model}. It runs on {daily_driver.fuel}.\u0026#34;) Here\u0026#39;s what you should have seen on your command line: (env) $ python class_example.py \u0026lt;__main__.Vehicle object at 0x10555c780\u0026gt; I drive a Subaru Crosstrek. It runs on gas. class Variables We can also add class variables - variables that exist for all instances of a class. Let\u0026rsquo;s add a variable called number_of_wheels to the class scope:\nclass Vehicle: number_of_wheels = 4 def __init__(self, make, model, fuel=\u0026#34;gas\u0026#34;): self.make = make self.model = model self.fuel = fuel Let\u0026rsquo;s query both the instance and class variables. Note that we set the instance variable to 3, but the higher-level class variable is still set to 4.\ndaily_driver = Vehicle(\u0026#34;Subaru\u0026#34;, \u0026#34;Crosstrek\u0026#34;) daily_driver.number_of_wheels = 3 # Instance variables print(f\u0026#34;I drive a {daily_driver.make} {daily_driver.model}. It runs on {daily_driver.fuel}.\u0026#34;) print(f\u0026#34;My {daily_driver.model} has {daily_driver.number_of_wheels} wheels.\u0026#34;) # Class variable print(f\u0026#34;Most vehicles have {Vehicle.number_of_wheels} wheels.\u0026#34;) Here\u0026#39;s what you should have seen on your command line: (env) $ python class_example.py I drive a Subaru Crosstrek. It runs on gas. My Crosstrek has 3 wheels. Most vehicles have 4 wheels. Inheritance Class inheritance in Python is super useful - you can easily create a hierarchy of classes to make your life easier and maximize code reuse. Let\u0026rsquo;s subclass our Vehicle class and extend it by breaking out Cars and Trucks.\nclass Vehicle: def __init__(self, make, model, fuel=\u0026#34;gas\u0026#34;): self.make = make self.model = model self.fuel = fuel class Car(Vehicle): number_of_wheels = 4 class Truck(Vehicle): number_of_wheels = 6 def __init__(self, make, model, fuel=\u0026#34;diesel\u0026#34;): super().__init__(make, model, fuel) Note: we\u0026rsquo;ve moved the number_of_wheels variable to the subclasses. Our Car subclass sets this variable but instantiating a Car just passes through to Vehicle.__init__(). We do, however, provide a __init__() for Truck, which changes the default fuel to diesel and then calls super().__init__() which redirects to Vehicle.__init__(). This lets us make changes that are specific to Truck instances (but we can still call them Vehicles). Let\u0026rsquo;s instantiate our subclasses:\ndaily_driver = Car(\u0026#34;Subaru\u0026#34;, \u0026#34;Crosstrek\u0026#34;) print(f\u0026#34;I drive a {daily_driver.make} {daily_driver.model}. \u0026#34; f\u0026#34;It uses {daily_driver.fuel} and has {daily_driver.number_of_wheels} wheels.\u0026#34;) truck = Truck(\u0026#34;Ford\u0026#34;, \u0026#34;F350\u0026#34;) print(f\u0026#34;I also have a {truck.make} {truck.model}. \u0026#34; f\u0026#34;It uses {truck.fuel} and has {truck.number_of_wheels} wheels.\u0026#34;) Here\u0026#39;s what you should have seen on your command line: (env) $ python class_example.py I drive a Subaru Crosstrek. It uses gas and has 4 wheels. I also have a Ford F350. It uses diesel and has 6 wheels. type, isinstance, and issubclass The type() command tells us the type of an object - for example, a Truck or a Car. Note that it doesn\u0026rsquo;t know anything about inheritance, so you can\u0026rsquo;t use type() to check if a Car is a Vehicle. For that, we can use isinstance(). issubclass() is another useful function that we can use to see if a class (rather than an instance) is a subclass of another class. Add this to your code:\nprint(f\u0026#34;My daily driver is a {type(daily_driver)} and my truck is a {type(truck)}\u0026#34;) print(f\u0026#34;Is my daily driver a car? {isinstance(daily_driver, Car)}\u0026#34;) print(f\u0026#34;Is my truck a Vehicle? {isinstance(truck, Vehicle)}\u0026#34;) print(f\u0026#34;Is my truck a Car? {isinstance(truck, Car)}\u0026#34;) print(f\u0026#34;Is a Truck a subclass of Vehicle? {issubclass(Truck, Vehicle)}\u0026#34;) Here\u0026#39;s what you should have seen on your command line: (env) $ python class_example.py My daily driver is a \u0026lt;class \u0026#39;__main__.Car\u0026#39;\u0026gt; and my truck is a \u0026lt;class \u0026#39;__main__.Truck\u0026#39;\u0026gt; Is my daily driver a car? True Is my truck a Vehicle? True Is my truck a Car? False Is a Truck a subclass of Vehicle? True "
},
{
	"uri": "https://pythonianrocketship.github.io/en/03-intermediate-python/50-libraries-modules/90-exercise/",
	"title": "Practice",
	"tags": [],
	"description": "",
	"content": "The Standard Library The Python standard library has a huge number of packages - no matter what you want to do, there\u0026rsquo;s probably a package included. Let\u0026rsquo;s practice using some of the more common ones. Create a new file and use the os module to see if you can get a file listing for the folder your new file is in.\nimport os my_folder = os.getcwd() print(f\u0026#34;Here are the files in {my_folder}:\u0026#34;) with os.scandir(my_folder) as folder: for entry in folder: print(f\u0026#34; - {entry.name}\u0026#34;) Here\u0026#39;s what you should have seen on your command line: (env) $ python libraries_exercise.py Here are the files in /Users/nina/Desktop/libraries_exercise: - libraries_exercise.py sys is another commonly useful library, giving you access to some variables and functions used or maintained by the Python interpreter. Let\u0026rsquo;s try using sys to get the arguments passed into our program from the command line, and to figure out what kind of computer we\u0026rsquo;re using:\nimport sys arguments = sys.argv print(f\u0026#34;We received the following arguments:\u0026#34;) for arg in arguments: print(f\u0026#34; - {arg}\u0026#34;) print(f\u0026#34;We are running on a \u0026#39;{sys.platform}\u0026#39; machine\u0026#34;) Here\u0026#39;s what you should have seen on your command line: (env) $ python libraries_exercise.py argument1 hello world \u0026#34;this is one argument\u0026#34; We received the following arguments: - libraries_exercise.py - argument1 - hello - world - this is one argument We are running on a \u0026#39;darwin\u0026#39; machine Note: if the string returned by sys.platform isn\u0026rsquo;t what you expect, take a look at the sys documentation.\nPypi PyPI (the Python Package Index) is an awesome service that helps you find and install almost any 3rd party Python package. You can browse the site at PyPI.org but most of the time you will probably interact with it through Python\u0026rsquo;s pip command line tool.\nFor example, earlier you may have installed the requests module. If you search pip for requests, you\u0026rsquo;ll see every package in the index containing the word requests:\n(env) $ python -m pip search requests requests-hawk (1.0.0) - requests-hawk requests-dump (0.1.3) - `requests-dump` provides hook functions for requests. requests-aws4auth (0.9) - AWS4 authentication for Requests ... We just want the one named requests, so we\u0026rsquo;ll install it with the install keyword. If you don\u0026rsquo;t have it installed, pip will install it for you. If you installed it earlier, you\u0026rsquo;ll see something like this:\n(env) $ python -m pip install requests Requirement already satisfied: requests in /usr/local/lib/python3.7/site-packages (2.21.0) Requirement already satisfied: chardet\u0026lt;3.1.0,\u0026gt;=3.0.2 in /usr/local/lib/python3.7/site-packages (from requests) (3.0.4) Requirement already satisfied: certifi\u0026gt;=2017.4.17 in /usr/local/lib/python3.7/site-packages (from requests) (2019.3.9) Requirement already satisfied: idna\u0026lt;2.9,\u0026gt;=2.5 in /usr/local/lib/python3.7/site-packages (from requests) (2.8) Requirement already satisfied: urllib3\u0026lt;1.25,\u0026gt;=1.21.1 in /usr/local/lib/python3.7/site-packages (from requests) (1.24.1) "
},
{
	"uri": "https://pythonianrocketship.github.io/en/03-intermediate-python/70-tests/90-exercise/",
	"title": "Practice",
	"tags": [],
	"description": "",
	"content": "Tests Python comes with a very easy-to-use unittest library built in. Write a simple function that accepts two numbers, and returns True if the first number is evenly divisible by the second.\ndef divisible_by(check_number, divisor): return check_number % divisor == 0 Save your file as divisible.py. In a second file called test_divisible.py, create a TestCase using the unittest framework and use asserts to verify that the divisible_by()function returns the correct result. Don\u0026rsquo;t forget to import your divisible_by() function.\nimport unittest from divisible import divisible_by class TestCase(unittest.TestCase): def test_divisible_by(self): self.assertTrue(divisible_by(10, 2)) self.assertTrue(divisible_by(10, 3)) if __name__ == \u0026#39;__main__\u0026#39;: unittest.main() Name your file test_divisible.py and run it:\n(env) $ python test_divisible.py --verbose Here\u0026#39;s what you should have seen on your command line: (env) $ python test_divisible.py --verbose test_divisible_by (__main__.TestCase) ... FAIL ====================================================================== FAIL: test_divisible_by (__main__.TestCase) ---------------------------------------------------------------------- Traceback (most recent call last): File \u0026#34;test_divisible.py\u0026#34;, line 8, in test_divisible_by self.assertTrue(divisible_by(10, 3)) AssertionError: False is not true ---------------------------------------------------------------------- Ran 1 test in 0.001s FAILED (failures=1) You should have gotten an error: AssertionError: False is not true caused by self.assertTrue(divisible_by(10, 3)). Makes sense, because 10 is not evenly divisible by 3.\nChange self.assertTrue to self.assertFalse and your test should pass.\n(env) $ python test_divisible.py --verbose test_divisible_by (__main__.TestCase) ... ok ---------------------------------------------------------------------- Ran 1 test in 0.000s OK "
},
{
	"uri": "https://pythonianrocketship.github.io/en/02-introduction-to-python/080-advanced-datatypes/20-adding-removing-finding/",
	"title": "Lists, Part 2",
	"tags": [],
	"description": "",
	"content": "Adding, Removing, Changing, and Finding Items in lists cheat sheet action method returns possible errors check length len(my_list) int add: to the end my_list.append(item) - insert: at position my_list.insert(pos, item) - update: at position my_list[pos] = item - - IndexError if pos is \u0026gt;= len(my_list) extend: add items from another list my_list.extend(other_list) - is item in list? item in my_list True or False index of item my_list.index(item) int ValueError if item is not in my_list count of item my_list.count(item) int remove an item my_list.remove(item) - ValueError if item not in my_list remove the last item, or an item at an index my_list.pop() or my_list.pop(pos) item IndexError if pos \u0026gt;= len(my_list) Checking Length Before we add or remove items, it\u0026rsquo;s usually a good idea to check a list\u0026rsquo;s length. We do that with the len built in function. We can even use the len built in function to check the lengths of other types, like strings.\nLet\u0026rsquo;s see it in action on a names list with two items, and a name string with four characters.\n\u0026gt;\u0026gt;\u0026gt; len(names) 2 \u0026gt;\u0026gt;\u0026gt; name = \u0026#34;Nina\u0026#34; \u0026gt;\u0026gt;\u0026gt; len(name) 4 Adding Items Let\u0026rsquo;s start with a list of two names.\n\u0026gt;\u0026gt;\u0026gt; names = [\u0026#34;Nina\u0026#34;, \u0026#34;Max\u0026#34;] my_list.append(item) adds to the end of my_list We can use my_list.append(item) to add an additional item to the end of the list.\n\u0026gt;\u0026gt;\u0026gt; names.append(\u0026#34;John\u0026#34;) \u0026gt;\u0026gt;\u0026gt; names [\u0026#39;Nina\u0026#39;, \u0026#39;Max\u0026#39;, \u0026#39;John\u0026#39;] my_list.insert(pos, item) inserts an item into my_list at the given position Use my_list.insert(pos, item) to insert items in an arbitrary position in the list. If the position is 0, we\u0026rsquo;ll insert at the beginning of the list.\n\u0026gt;\u0026gt;\u0026gt; names.insert(0, \u0026#34;Rose\u0026#34;) \u0026gt;\u0026gt;\u0026gt; names [\u0026#39;Rose\u0026#39;, \u0026#39;Nina\u0026#39;, \u0026#39;Max\u0026#39;, \u0026#39;John\u0026#39;] You can call dir() on our names list to verify that it\u0026rsquo;s actually of type list. If you forget which order insert is called in, don\u0026rsquo;t forget you can always use the help() function on the REPL. Remember: Press q to quit the help screen. Let\u0026rsquo;s try it now:\n\u0026gt;\u0026gt;\u0026gt; type(names) \u0026lt;class \u0026#39;list\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt; help(names.insert) Help on method_descriptor: insert(self, index, object, /) Insert object before index. You can also call help on names.insert. Because names is already of type list, it achieves the same result.\nmy_list.extend(other_list) adds all the contents of other_list to my_list \u0026gt;\u0026gt;\u0026gt; names = [\u0026#34;Nina\u0026#34;, \u0026#34;Max\u0026#34;] \u0026gt;\u0026gt;\u0026gt; colors = [\u0026#34;Red\u0026#34;, \u0026#34;Blue\u0026#34;] \u0026gt;\u0026gt;\u0026gt; names [\u0026#39;Nina\u0026#39;, \u0026#39;Max\u0026#39;] \u0026gt;\u0026gt;\u0026gt; names.extend(colors) \u0026gt;\u0026gt;\u0026gt; names [\u0026#39;Nina\u0026#39;, \u0026#39;Max\u0026#39;, \u0026#39;Red\u0026#39;, \u0026#39;Blue\u0026#39;] Looking for Items Looking for items in a list is slow. Each item needs to be checked in order to find a match.\nThis doesn\u0026rsquo;t matter much when you\u0026rsquo;re just getting started, unless your data set is large, or if you\u0026rsquo;re building high-performance systems. If you want to quickly search for an item, you\u0026rsquo;ll need to use a set or a dictionary instead.\nThere are a few ways to determine if an item is in the list, and at which position. Let\u0026rsquo;s try this on our list of names.\nnames = [\u0026#34;Nina\u0026#34;, \u0026#34;Max\u0026#34;, \u0026#34;Phillip\u0026#34;, \u0026#34;Nina\u0026#34;] Use the in keyword to determine if an item is present or not. \u0026gt;\u0026gt;\u0026gt; \u0026#34;Nina\u0026#34; in names True \u0026gt;\u0026gt;\u0026gt; \u0026#34;Rose\u0026#34; in names False Use the my_list.index(item) method to find the first index of a potential match. Notice that only the first index of the string \u0026quot;Nina\u0026quot; is returned. We\u0026rsquo;ll learn more about what an index is in the next chapter.\nIf the item we\u0026rsquo;re looking for is not in the list, Python will throw a ValueError.\nYou\u0026rsquo;ll learn how to deal with exceptions later. For now, you can use the in operator to check if an item is present in the list before finding its index.\n\u0026gt;\u0026gt;\u0026gt; names.index(\u0026#34;Nina\u0026#34;) 0 \u0026gt;\u0026gt;\u0026gt; names.index(\u0026#34;Rose\u0026#34;) Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; ValueError: \u0026#39;Rose\u0026#39; is not in list Use the my_list.count(item) method to find out how many times an item appears in a list. \u0026gt;\u0026gt;\u0026gt; names.count(\u0026#34;Nina\u0026#34;) 2 \u0026gt;\u0026gt;\u0026gt; names.count(\u0026#34;Rose\u0026#34;) 0 Updating Items To update items in a list, use the position of the item you\u0026rsquo;d like to change using square bracket [] syntax. Like: my_list[pos] = new_item\nFor example:\n\u0026gt;\u0026gt;\u0026gt; names = [\u0026#34;Nina\u0026#34;, \u0026#34;Max\u0026#34;] \u0026gt;\u0026gt;\u0026gt; names[0] = \u0026#34;Rose\u0026#34; \u0026gt;\u0026gt;\u0026gt; names [\u0026#39;Rose\u0026#39;, \u0026#39;Max\u0026#39;] Or, when used with my_list.index(item):\n\u0026gt;\u0026gt;\u0026gt; names = [\u0026#34;Nina\u0026#34;, \u0026#34;Max\u0026#34;] \u0026gt;\u0026gt;\u0026gt; pos = names.index(\u0026#34;Max\u0026#34;) \u0026gt;\u0026gt;\u0026gt; names[pos] = \u0026#34;Rose\u0026#34; \u0026gt;\u0026gt;\u0026gt; names [\u0026#39;Nina\u0026#39;, \u0026#39;Rose\u0026#39;] You\u0026rsquo;ll see a IndexError: list assignment index out of range if you try to update an item in a position that doesn\u0026rsquo;t exist, that is if the position is greater than or equal to \u0026gt;= the length of the list.\n\u0026gt;\u0026gt;\u0026gt; names = [\u0026#34;Nina\u0026#34;, \u0026#34;Max\u0026#34;] \u0026gt;\u0026gt;\u0026gt; len(names) 2 \u0026gt;\u0026gt;\u0026gt; names[2] = \u0026#34;Rose\u0026#34; Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; IndexError: list assignment index out of range Removing Items There are a few ways to remove items from a list.\nUse my_list.remove(item) to remove the first instance of the item Be careful. remove() only removes the first instance of the item from the list, which isn\u0026rsquo;t always what we want to do.\n\u0026gt;\u0026gt;\u0026gt; names = [\u0026#34;Nina\u0026#34;, \u0026#34;Max\u0026#34;, \u0026#34;Rose\u0026#34;] \u0026gt;\u0026gt;\u0026gt; names.remove(\u0026#34;Nina\u0026#34;) \u0026gt;\u0026gt;\u0026gt; names [\u0026#39;Max\u0026#39;, \u0026#39;Rose\u0026#39;] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; names = [\u0026#34;Nina\u0026#34;, \u0026#34;Max\u0026#34;, \u0026#34;Nina\u0026#34;] \u0026gt;\u0026gt;\u0026gt; names.remove(\u0026#34;Nina\u0026#34;) \u0026gt;\u0026gt;\u0026gt; names [\u0026#39;Max\u0026#39;, \u0026#39;Nina\u0026#39;] If we try to remove an item that\u0026rsquo;s not in the list, we\u0026rsquo;ll get a ValueError: list.remove(x): x not in list.\n\u0026gt;\u0026gt;\u0026gt; names = [\u0026#34;Nina\u0026#34;] \u0026gt;\u0026gt;\u0026gt; names.remove(\u0026#34;Max\u0026#34;) Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; ValueError: list.remove(x): x not in list Use my_list.pop() to remove the last item, or my_list.pop(index) to remove the item at that index Using pop() will also return the item that was in that position. That\u0026rsquo;s useful if we want to save the item.\n\u0026gt;\u0026gt;\u0026gt; names = [\u0026#34;Nina\u0026#34;, \u0026#34;Max\u0026#34;, \u0026#34;Rose\u0026#34;] \u0026gt;\u0026gt;\u0026gt; names.pop() \u0026#39;Rose\u0026#39; \u0026gt;\u0026gt;\u0026gt; names [\u0026#39;Nina\u0026#39;, \u0026#39;Max\u0026#39;] \u0026gt;\u0026gt;\u0026gt; names.pop(1) \u0026#39;Max\u0026#39; \u0026gt;\u0026gt;\u0026gt; names [\u0026#39;Nina\u0026#39;] If we try to pop an item from an index that is longer than or equal to the length of the list, we\u0026rsquo;ll get an IndexError: pop index out of range.\n\u0026gt;\u0026gt;\u0026gt; names = [\u0026#34;Nina\u0026#34;] \u0026gt;\u0026gt;\u0026gt; len(names) 1 \u0026gt;\u0026gt;\u0026gt; names.pop(1) Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; IndexError: pop index out of range "
},
{
	"uri": "https://pythonianrocketship.github.io/en/03-intermediate-python/20-advanced-looping/",
	"title": "Advanced Looping",
	"tags": [],
	"description": "",
	"content": "Chapter 2 Advanced Looping with List Comprehensions Learn about advanced looping with list comprehensions, and other types of comprehensions.\n"
},
{
	"uri": "https://pythonianrocketship.github.io/en/02-introduction-to-python/090-boolean-logic/20-comparisons/",
	"title": "Comparisons",
	"tags": [],
	"description": "",
	"content": "How can we compare different values with each other?\nOrder Comparisons Cheat Sheet Operator Means \u0026lt; less-than \u0026lt;= less-than-or-equal-to \u0026gt; greater-than \u0026gt;= greater-than-or-equal-to In Python, comparing numbers is pretty straight forward.\n\u0026gt;\u0026gt;\u0026gt; 1 \u0026lt; 10 # 1 is less than 10? True True \u0026gt;\u0026gt;\u0026gt; 20 \u0026lt;= 20 # 20 is less than or equal to 20? True True \u0026gt;\u0026gt;\u0026gt; 10 \u0026gt; 1 # 10 is greater than 1? True True \u0026gt;\u0026gt;\u0026gt; -1 \u0026gt; 1 # -1 is greater than 1? False False \u0026gt;\u0026gt;\u0026gt; 30 \u0026gt;= 30 # 30 is greater than or equal to 30? True True Things get interesting when you try to compare strings. Strings are compared lexicographically. That means by the ASCII value of the character. You don\u0026rsquo;t need to know much about ASCII, besides that capital letters come before lower case ones.\nEach character in the two strings is checked one by one, until a character is found that is of a different value. That determines the order. Under the hood, this allows Python to sort strings by comparing them to each other.\n\u0026gt;\u0026gt;\u0026gt; \u0026#34;T\u0026#34; \u0026lt; \u0026#34;t\u0026#34; # Upper case letters are \u0026#34;lower\u0026#34; valued. True \u0026gt;\u0026gt;\u0026gt; \u0026#34;a\u0026#34; \u0026lt; \u0026#34;b\u0026#34; True \u0026gt;\u0026gt;\u0026gt; \u0026#34;bat\u0026#34; \u0026lt; \u0026#34;cat\u0026#34; True Equality Cheat Sheet Operator Means == equals != not-equals The equality operators val1 == val2 (val1 equals val2) and val1 != val2 (val1 doesn\u0026rsquo;t equal val2) compare the contents of two different values and return a boolean.\nEquality works like you\u0026rsquo;d expect it to for simple data types.\n\u0026gt;\u0026gt;\u0026gt; a = 1 \u0026gt;\u0026gt;\u0026gt; b = 1 \u0026gt;\u0026gt;\u0026gt; a == b True \u0026gt;\u0026gt;\u0026gt; a != b False \u0026gt;\u0026gt;\u0026gt; a = \u0026#34;Nina\u0026#34; \u0026gt;\u0026gt;\u0026gt; b = \u0026#34;Nina\u0026#34; \u0026gt;\u0026gt;\u0026gt; a == b True \u0026gt;\u0026gt;\u0026gt; a != b False Equality for container types is interesting. Even though a and b are two different lists, their contents are still the same. So compared two lists containing the same values with == will return True.\n\u0026gt;\u0026gt;\u0026gt; a = [1, 2, 3] \u0026gt;\u0026gt;\u0026gt; b = [1, 2, 3] \u0026gt;\u0026gt;\u0026gt; a == b True \u0026gt;\u0026gt;\u0026gt; a != b False Identity Cheat Sheet Operator Means is is the same object in memory? (not equality!) is not is not the same object in memory? (not equality!) This is something that trips up Python beginners, so make sure you remember that equality (==, !=) is not the same as identity (is, not is).\nThe is keywords tests if the two compared objects are stored in the same memory location. I won\u0026rsquo;t go into too much detail into why, but remember not to use is when what you actually want to check for is equality.\n\u0026gt;\u0026gt;\u0026gt; a = [1, 2, 3] \u0026gt;\u0026gt;\u0026gt; b = [1, 2, 3] \u0026gt;\u0026gt;\u0026gt; a == b # Testing for equality. a and b contain the same values True \u0026gt;\u0026gt;\u0026gt; a is b # Testing for identity. a and b are NOT the same object. False When you\u0026rsquo;re first starting out, the only place you\u0026rsquo;ll want to use the is keyword is to explicitly compare a value to the built-in types of None, True, or False.\n\u0026gt;\u0026gt;\u0026gt; a = True \u0026gt;\u0026gt;\u0026gt; a is True True \u0026gt;\u0026gt;\u0026gt; b = False \u0026gt;\u0026gt;\u0026gt; b is False True \u0026gt;\u0026gt;\u0026gt; b is not True # Opposite of is b True. aka is b False? True \u0026gt;\u0026gt;\u0026gt; c = None \u0026gt;\u0026gt;\u0026gt; c is None True \u0026gt;\u0026gt;\u0026gt; c is not None False "
},
{
	"uri": "https://pythonianrocketship.github.io/en/02-introduction-to-python/175-running-code/20-print-tips/",
	"title": "Printing Tips",
	"tags": [],
	"description": "",
	"content": "One of the nice things about the REPL is we can quickly and easily see the contents of our variables, just by typing their name and pressing enter. Unfortunately, running code from Python files doesn\u0026rsquo;t do quite the same thing.\nIn a file named name.py:\n# file name.py name = \u0026#34;Nina\u0026#34; name Output:\n(env) $ python name.py Notice, there was no output.\nNow, in a file named print_name.py:\n# file print_name.py name = \u0026#34;Nina\u0026#34; print(name) Output:\n(env) $ python name.py Nina Hooray! Now we see some output. 🎉\nIf you want to see any output from your Python programs, you\u0026rsquo;ll need to use print().\nDebugging Your Code With print() As your Python programs become more complicated, you\u0026rsquo;ll want to do some basic debugging to figure out what\u0026rsquo;s going on under the hood. For beginners, using print() is a great way to accomplish that goal.\nIf you write Python code on a team or plan on sharing it, it\u0026rsquo;s a good idea to remove your debugging print()s before you share your code with others.\nIn a Python file named mystery.py:\ndef mystery(): num = 10 * 3 if num == 10: print(\u0026#34;Num was equal to 10\u0026#34;) num = num * 10 if num == 20: print(\u0026#34;Num was equal to 20\u0026#34;) num = num * 20 if num == 30: print(\u0026#34;Num was equal to 30\u0026#34;) num = num * 30 print(f\u0026#34;Value of returned num is: {num}\u0026#34;) return num mystery() We\u0026rsquo;ll see the output:\nNum was equal to 30 Value of returned num is: 900 Tip: As you continue your Python journey, try using a debugger, like the built-in pdb instead of the print() function to really dive into what your code is doing under the hood.\nOutput Formatting Tips If your Python program will have terminal output, you can use these tips to make it a little nicer.\nUse new lines and tabs Use control characters in your string to change how your output is represented.\n\\n for new line \\t for tab In formatting_example.py:\n# Use \\n to add a new line, before, in the middle of, or after a string. print(\u0026#34;\\nExtra New Line Before\u0026#34;) print(\u0026#34;One Print\\nTwo New Lines!\u0026#34;) print(\u0026#34;Extra New Line After\\n\u0026#34;) # Use \\t to add a tab. print(\u0026#34;\\t Here\u0026#39;s some tabbed output.\u0026#34;) # Or, combine both! print(\u0026#34;\\nOne Print\\n\\tOne Tab\u0026#34;) Output running: python3 formatting_example.py.\nExtra New Line Before One Print Two New Lines! Extra New Line After Here\u0026#39;s some tabbed output. One Print One Tab Pretty Printing with pprint When printing large data structures like long lists or big dictionaries, they come out on one line. It\u0026rsquo;s a bit hard to read.\nIf you want a little bit of extra formatting, like having each element of a long list on a new line, you can use the included pprint module (stands for pretty print) in your files or in the REPL.\n\u0026gt;\u0026gt;\u0026gt; long_list = list(range(23)) \u0026gt;\u0026gt;\u0026gt; print(long_list) [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22] \u0026gt;\u0026gt;\u0026gt; from pprint import pprint \u0026gt;\u0026gt;\u0026gt; pprint(long_list) [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22] This will become more useful as your Python programs become more complex.\n"
},
{
	"uri": "https://pythonianrocketship.github.io/en/02-introduction-to-python/020-basic-data-types/",
	"title": "Basic Data Types",
	"tags": [],
	"description": "",
	"content": "Chapter 2 Basic Data Types Working with numbers, strings, and more.\n"
},
{
	"uri": "https://pythonianrocketship.github.io/en/03-intermediate-python/30-oop-classes-inheritance/",
	"title": "Object Oriented Programming",
	"tags": [],
	"description": "",
	"content": "Chapter 3 Classes, Objects, Object Oriented programming Object oriented programming allows us to represent our code in a different way, organized into classes\n"
},
{
	"uri": "https://pythonianrocketship.github.io/en/02-introduction-to-python/110-control-statements-looping/30-while-loops/",
	"title": "while loops",
	"tags": [],
	"description": "",
	"content": "while loops are a special type of loop in Python. Instead of running just once when a condition is met, like an if statement, they run forever until a condition is no longer met.\nwhile loops usually need to be accompanied by an always changing sentinel value.\n\u0026gt;\u0026gt;\u0026gt; counter = 0 \u0026gt;\u0026gt;\u0026gt; max = 4 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; while counter \u0026lt; max: ... print(f\u0026#34;The count is: {counter}\u0026#34;) ... counter = counter + 1 ... The count is: 0 The count is: 1 The count is: 2 The count is: 3 Our loop will run forever if we forget to update the sentinel value. Press Ctrl-C to exit the infinite loop.\n# Warning: don\u0026#39;t copy and paste this example. \u0026gt;\u0026gt;\u0026gt; counter = 0 \u0026gt;\u0026gt;\u0026gt; max = 4 \u0026gt;\u0026gt;\u0026gt; while counter \u0026lt; max: ... print(f\u0026#34;The count is: {counter}\u0026#34;) ... # What happens if we don\u0026#39;t update counter? The count is: 0 The count is: 0 The count is: 0 The count is: 0 # An infinite loop repeated until we hit Ctrl-C The count ^CTraceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 2, in \u0026lt;module\u0026gt; KeyboardInterrupt "
},
{
	"uri": "https://pythonianrocketship.github.io/en/02-introduction-to-python/080-advanced-datatypes/30-tuples/",
	"title": "Tuples",
	"tags": [],
	"description": "",
	"content": "Tuples are light-weight collections used to keep track of related, but different items. Tuples are immutable, meaning that once a tuple has been created, the items in it can\u0026rsquo;t change.\nYou might ask, why tuples when Python already has lists? Tuples are different in a few ways. While lists are generally used to store collections of similar items together, tuples, by contrast, can be used to contain a snapshot of data. They can\u0026rsquo;t be continually changed, added or removed from like you could with a list.\ntuple cheat sheet type tuple use Used for storing a snapshot of related items when we don\u0026rsquo;t plan on modifying, adding, or removing data. creation () or tuple() for empty tuple. (1, ) for one item, or (1, 2, 3) for a tuple with items. search methods my_tuple.index(item) or item in my_tuple search speed Searching for an item in a large tuple is slow. Each item must be checked. common methods Can\u0026rsquo;t add or remove from tuples. order preserved? Yes. Items can be accessed by index. mutable? No in-place sortable? No Uses A good use of a tuple might be for storing the information for a row in a spreadsheet. That data is information only. We don\u0026rsquo;t necessarily care about updating or manipulating that data. We just want a read-only snapshot.\nTuples are an interesting and powerful datatype, and one of the more unique aspects of Python. Most other programming languages have ways of representing lists and dictionaries, but only a small subset contain tuples. Use them to your advantage.\nExamples Empty and one-item tuples One important thing to note about tuples, is there\u0026rsquo;s a quirk to their creation. Let\u0026rsquo;s check the type of an empty tuple created with ().\n\u0026gt;\u0026gt;\u0026gt; a = () \u0026gt;\u0026gt;\u0026gt; type(a) \u0026lt;class \u0026#39;tuple\u0026#39;\u0026gt; That looks like we\u0026rsquo;d expect it to. What about if we tried to create a one-item tuple using the same syntax?\n\u0026gt;\u0026gt;\u0026gt; b = (1) \u0026gt;\u0026gt;\u0026gt; type(b) \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; It didn\u0026rsquo;t work! type((1)) is an integer. In order to create a one-item tuple, you\u0026rsquo;ll need to include a trailing comma.\n\u0026gt;\u0026gt;\u0026gt; c = (1, ) \u0026gt;\u0026gt;\u0026gt; type(c) \u0026lt;class \u0026#39;tuple\u0026#39;\u0026gt; If you\u0026rsquo;re creating a one-item tuple, you must include a trailing comma, like this: (1, )\nCreation Let\u0026rsquo;s say we have a spreadsheet of students, and we\u0026rsquo;d like to represent each row as a tuple.\n\u0026gt;\u0026gt;\u0026gt; student = (\u0026#34;Marcy\u0026#34;, 8, \u0026#34;History\u0026#34;, 3.5) Access by index We can access items in the tuple by index, but we can\u0026rsquo;t change them.\n\u0026gt;\u0026gt;\u0026gt; student = (\u0026#34;Marcy\u0026#34;, 8, \u0026#34;History\u0026#34;, 3.5) \u0026gt;\u0026gt;\u0026gt; student[0] \u0026#39;Marcy\u0026#39; \u0026gt;\u0026gt;\u0026gt; student[0] = \u0026#34;Bob\u0026#34; Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; TypeError: \u0026#39;tuple\u0026#39; object does not support item assignment We\u0026rsquo;ll see TypeError: 'tuple' object does not support item assignment if we try to change the items in a tuple.\ntuples also don\u0026rsquo;t have an append or extend method available on them like lists do, because they can\u0026rsquo;t be changed.\ntuple unpacking. Sounds like a lot of work for not a lot of benefit, right? Not so. tuples are great when you depend on your data staying unchanged. Because of this guarantee, we can use tuples in other types of containers like sets and dictionaries.\nIt\u0026rsquo;s also a great way to quickly consolidate information.\nYou can also use tuples for something called unpacking. Let\u0026rsquo;s see it in action:\n\u0026gt;\u0026gt;\u0026gt; student = (\u0026#34;Marcy\u0026#34;, 8, \u0026#34;History\u0026#34;, 3.5) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; name, age, subject, grade = student \u0026gt;\u0026gt;\u0026gt; name \u0026#39;Marcy\u0026#39; \u0026gt;\u0026gt;\u0026gt; age 8 \u0026gt;\u0026gt;\u0026gt; subject \u0026#39;History\u0026#39; \u0026gt;\u0026gt;\u0026gt; grade 3.5 You can return tuples from functions, and use unpacking.\n\u0026gt;\u0026gt;\u0026gt; def http_status_code(): ... return 200, \u0026#34;OK\u0026#34; ... \u0026gt;\u0026gt;\u0026gt; code, value = http_status_code() \u0026gt;\u0026gt;\u0026gt; code 200 \u0026gt;\u0026gt;\u0026gt; value \u0026#39;OK\u0026#39; "
},
{
	"uri": "https://pythonianrocketship.github.io/en/02-introduction-to-python/090-boolean-logic/30-and-or-not/",
	"title": "and, or, not",
	"tags": [],
	"description": "",
	"content": "and, or, and not are the three basic types of boolean operators that are present in math, programming, and database logic.\nIn other programming languages, you might have seen the concept of and represented with \u0026amp;\u0026amp;, or, represented with ||, and not represented by !. The Python language is instead focused on readability. So we\u0026rsquo;ll use the english and instead of trying to remember fancy symbols. Python still uses the \u0026amp;, | and ! expressions, but they\u0026rsquo;re used for bitwise operations.\nYou can use them to compare one (or more expressions) and determine if they evaluate to True or False.\nThankfully, you don\u0026rsquo;t have to be a computer scientist to understand them if you use this handy table.\nand, or, not Cheat Sheet Operation Result a or b if a is False, then b, else a a and b if a is False, then a, else b not a if a is false, then True, else False and For a and b, if a is false, a is returned. Otherwise b is returned. If a and b are both boolean values, the expression evaluates toTrue if both a and b are True.\n\u0026gt;\u0026gt;\u0026gt; a = True # a is True \u0026gt;\u0026gt;\u0026gt; b = True \u0026gt;\u0026gt;\u0026gt; a and b # True is returned. (value of b) True \u0026gt;\u0026gt;\u0026gt; a = False # a is False \u0026gt;\u0026gt;\u0026gt; b = True \u0026gt;\u0026gt;\u0026gt; a and b # False is returned. (value of a) False \u0026gt;\u0026gt;\u0026gt; a = False # a is False \u0026gt;\u0026gt;\u0026gt; b = False \u0026gt;\u0026gt;\u0026gt; a and b # False is returned. (value of a) False Notice what happens when do the same thing to values that have a \u0026ldquo;truthiness\u0026rdquo; to them.\n\u0026gt;\u0026gt;\u0026gt; bool(0) # Verify that zero is \u0026#34;falsey\u0026#34; False \u0026gt;\u0026gt;\u0026gt; bool(1) # Verify that one is \u0026#34;truthy\u0026#34; True \u0026gt;\u0026gt;\u0026gt; 0 and 1 # 0 is False. 0 is returned. 0 or For a or b, if a is false, b is returned. If a is true, a is returned. a or b evaluates to True if either (or both) of the expressions are true.\n\u0026gt;\u0026gt;\u0026gt; a = True # a is true \u0026gt;\u0026gt;\u0026gt; b = True \u0026gt;\u0026gt;\u0026gt; a or b # True is returned (value of a) True \u0026gt;\u0026gt;\u0026gt; a = False # a is false \u0026gt;\u0026gt;\u0026gt; b = True \u0026gt;\u0026gt;\u0026gt; a or b # True is returned (value of b) True \u0026gt;\u0026gt;\u0026gt; 0 or 1 # 0 is false. Return 1. 1 not a not a true False false True not a reverses the boolean value of a. If it was true, it will return False. If it was false, it will return True.\n\u0026gt;\u0026gt;\u0026gt; a = True \u0026gt;\u0026gt;\u0026gt; not a # not returns the opposite. True -\u0026gt; False False \u0026gt;\u0026gt;\u0026gt; a = False \u0026gt;\u0026gt;\u0026gt; not a # not returns the opposite. False -\u0026gt; True True And again, with numbers. Remember, zero is considered False, any other number is considered True.\n\u0026gt;\u0026gt;\u0026gt; bool(1) True \u0026gt;\u0026gt;\u0026gt; not 1 False \u0026gt;\u0026gt;\u0026gt; bool(0) False \u0026gt;\u0026gt;\u0026gt; not 0 True In Combination When combining multiple boolean operators, you can add optional parenthesis for readability.\n\u0026gt;\u0026gt;\u0026gt; a = True \u0026gt;\u0026gt;\u0026gt; b = True \u0026gt;\u0026gt;\u0026gt; c = False \u0026gt;\u0026gt;\u0026gt; a and (b or c) True You can combine multiple operators to test complex assumptions. For example, to return True only if both values are False, we can use the not negation operation on the result of an or.\n\u0026gt;\u0026gt;\u0026gt; a = False \u0026gt;\u0026gt;\u0026gt; b = False \u0026gt;\u0026gt;\u0026gt; a or b # False because both are False. False \u0026gt;\u0026gt;\u0026gt; not (a or b) # True - checking if both are False. True With \u0026ldquo;truthiness\u0026rdquo; Remember, we learned that some values in Python are falsey like the number zero, and some are truthy like any number expect for zero.\nIt\u0026rsquo;s a little counter intuitive, but when we compare values other than booleans, our code behaves a little differently.\nOperation Result x or y if x is false, then y, else x x and y if x is false, then x, else y Let\u0026rsquo;s see it in action. First, lets test our assumptions again.\n\u0026gt;\u0026gt;\u0026gt; bool(0) # Truthiness of 0 is False False \u0026gt;\u0026gt;\u0026gt; bool(1) # Truthiness of 1 is True True \u0026gt;\u0026gt;\u0026gt; bool(None) # Truthiness of None type is False False \u0026gt;\u0026gt;\u0026gt; 1 or 0 # Returns 1, the True value 1 \u0026gt;\u0026gt;\u0026gt; 1 and 0 # Returns 0, the False value 0 \u0026gt;\u0026gt;\u0026gt; 0 or None # Neither are True. Returns nothing (None) "
},
{
	"uri": "https://pythonianrocketship.github.io/en/02-introduction-to-python/175-running-code/30-the-main-method/",
	"title": "The main Method",
	"tags": [],
	"description": "",
	"content": "Once you start writing more comprehensive Python programs, you\u0026rsquo;ll want to include a main method in your code.\nThe purpose of checking for the main method is to make sure that the code in your main method is only run when it\u0026rsquo;s executed as a stand-alone program. Because of how Python\u0026rsquo;s import system works, if someone else imports your Python program, any code in it is executed on import.\nWe\u0026rsquo;ll talk more about imports and modules on day two, but let\u0026rsquo;s look at a quick example.\nLet\u0026rsquo;s say we had a Python file named name_lib.py\ndef name_length(name): return len(name) def upper_case_name(name): return name.upper() def lower_case_name(name): return name.lower() name = \u0026#34;Nina\u0026#34; length = name_length(name) upper_case = upper_case_name(name) print(f\u0026#34;The length is {length} and the uppercase version is: {upper_case}\u0026#34;) If we ran this code, we\u0026rsquo;d see exactly what we expect.\n(env) $ python name_lib.py name_lib.py The length is 4 and the uppercase version is: NINA Writing Reusable Code We went through all this trouble of writing a useful name library. What if someone else wanted to use our library in their own code by importing it?\nLet\u0026rsquo;s say someone else wrote their own program, in other_program.py\nimport name_lib my_name = \u0026#34;Fred\u0026#34; my_length = name_lib.name_length(my_name) my_lower_case = name_lib.lower_case_name(my_name) print(f\u0026#34;In my code, my length is {my_length} and my lower case name is: {my_lower_case}\u0026#34;) If we ran this, we\u0026rsquo;d see the following result:\n(env) $ python other_program.py The length is 4 and the uppercase version is: NINA In my code, my length is 4 and my lower case name is: fred If I\u0026rsquo;m Fred, I just wanted to use this cool library. But all of a sudden, I\u0026rsquo;m seeing information about Nina!\nTo prevent this from happening, we want to write a conditional that will only run our code if we\u0026rsquo;re the ones running the program directly.\nTo do that, we\u0026rsquo;ll need to check if __name__ == __main__.\nLet\u0026rsquo;s unwrap that.\n__name__ is a special variable that\u0026rsquo;s set by Python that tells it where it was called from. We can tell it\u0026rsquo;s a special variable because it starts and ends with __. That\u0026rsquo;s a hint that you don\u0026rsquo;t want to change the value of this variable, or it could adversely affect the execution of your Python program.\nIn Python, __ is also called double underscore, or dunder.\nLet\u0026rsquo;s comment out our original print, and add the following line to the end of name_lib.py:\n# Note: add to the bottom of name_lib.py # print(f\u0026#34;The length is {length} and the uppercase version is: {upper_case}\u0026#34;) print(f\u0026#34;The value of __name__ is: {__name__}\u0026#34;) Now, let\u0026rsquo;s run name_lib.py again. We should see:\n(env) $ python name_lib.py The value of __name__ is: __main__ We\u0026rsquo;re getting somewhere. When we run this file directly, we\u0026rsquo;ll see that __name__ has the value of __main__.\nWhat if we run our other program again?\n(env) $ python other_program.py The value of __name__ is: name_lib When we \u0026ldquo;run\u0026rdquo; our library by importing it, we\u0026rsquo;ll see that it\u0026rsquo;s __name__ is set to the name of the file that it\u0026rsquo;s in, minus the .py extension. In this case, __name__ is set to name_lib.\nPutting Code in a main Conditional To avoid running our code when it\u0026rsquo;s imported by other modules, we put it in a conditional statement, and explicitly check if __name__ == \u0026quot;__main__\u0026quot;.\nLet\u0026rsquo;s update name_lib.py, and put our own code inside of the conditional check.\ndef name_length(name): return len(name) def upper_case_name(name): return name.upper() def lower_case_name(name): return name.lower() if __name__ == \u0026#34;__main__\u0026#34;: name = \u0026#34;Nina\u0026#34; length = name_length(name) upper_case = upper_case_name(name) print(f\u0026#34;The length is {length} and the uppercase version is: {upper_case}\u0026#34;) Now, if we run other_program.py, we\u0026rsquo;ll see:\n(env) $ python other_program.py In my code, my length is 4 and my lower case name is: fred Much better!\nUsing a main method is a common pattern that you’ll see in Python programs, and it comes in handy for being able to write programs that work both on their own and when imported into other programs.\n"
},
{
	"uri": "https://pythonianrocketship.github.io/en/02-introduction-to-python/060-functions/30-function-arguments/",
	"title": "Function Arguments",
	"tags": [],
	"description": "",
	"content": "Arguments in Practice Positional arguments are required Positional arguments are all required, and must be given in the order they are declared.\nFor example, this function doesn\u0026rsquo;t do what we expected, because we passed in our arguments in the wrong order.\nIn the REPL:\n\u0026gt;\u0026gt;\u0026gt; def say_greeting(name, greeting): ... print(f\u0026#34;{greeting}, {name}.\u0026#34;) ... \u0026gt;\u0026gt;\u0026gt; say_greeting(\u0026#34;Hello!\u0026#34;, \u0026#34;Nina\u0026#34;) Nina, Hello!. Keyword arguments with default values Functions can accept two types of named arguments, ones without default values, and ones with default values. Arguments that have default values are called keyword arguments. The nice thing about defaults is they can be overridden when needed.\nLet\u0026rsquo;s see this in practice, by writing two functions that print out a greeting. One function will have a default argument to make things easier for us.\n# No default arguments def say_greeting(greeting, name): print(f\u0026#34;{greeting}, {name}.\u0026#34;) # Default argument - greeting will always be # Hello, if one isn\u0026#39;t provided. def say_greeting_with_default(name, greeting=\u0026#34;Hello\u0026#34;, punctuation=\u0026#34;!\u0026#34;): print(f\u0026#34;{greeting}, {name}{punctuation}\u0026#34;) Without default arguments Now, in the REPL, let\u0026rsquo;s try calling our function with no default arguments:\n\u0026gt;\u0026gt;\u0026gt; # No Default arguments \u0026gt;\u0026gt;\u0026gt; def say_greeting(greeting, name): ... print(f\u0026#34;{greeting}, {name}.\u0026#34;) ... \u0026gt;\u0026gt;\u0026gt; say_greeting(\u0026#34;Good Day\u0026#34;, \u0026#34;Nina\u0026#34;) Good Day, Nina. Using default arguments Let\u0026rsquo;s make a new function, say_greeting_with_default that accepts two arguments \u0026ndash; name, and a now optional argument, greeting. If greeting is not passed in, it will default to Hello.\nIn the REPL:\n\u0026gt;\u0026gt;\u0026gt; # With Default Arguments \u0026gt;\u0026gt;\u0026gt; def say_greeting_with_default(name, greeting=\u0026#34;Hello\u0026#34;, punctuation=\u0026#34;!\u0026#34;): ... print(f\u0026#34;{greeting}, {name}{punctuation}\u0026#34;) ... \u0026gt;\u0026gt;\u0026gt; say_greeting_with_default(\u0026#34;Nina\u0026#34;) Hello, Nina! \u0026gt;\u0026gt;\u0026gt; say_greeting_with_default(\u0026#34;Nina\u0026#34;, \u0026#34;Good Day\u0026#34;) Good Day, Nina! Order matters! A function can accept all of one type or the other, but arguments need to go in a specific order.\nAll of the required arguments go first. They are then followed by the optional keyword arguments.\nWhat happens when we try to define our arguments out of order? If you guessed a SyntaxError, you\u0026rsquo;re correct!\n\u0026gt;\u0026gt;\u0026gt; def say_greeting_bad(greeting=\u0026#34;Hello\u0026#34;, name): ... print(\u0026#34;Oops, this won\u0026#39;t work!\u0026#34;) ... File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1 SyntaxError: non-default argument follows default argument Calling functions with arguments There are a few important things to know about calling functions with arguments.\nArguments without defaults are required! Arguments without default values are required by Python. Otherwise your function wouldn\u0026rsquo;t know what to do! If you don\u0026rsquo;t pass in all the required arguments, you\u0026rsquo;ll get a TypeError.\nIn the REPL:\n\u0026gt;\u0026gt;\u0026gt; def say_greeting(name, greeting): ... print(f\u0026#34;{greeting}, {name}.\u0026#34;) ... \u0026gt;\u0026gt;\u0026gt; say_greeting(\u0026#34;Nina\u0026#34;) Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; TypeError: say_greeting() missing 1 required positional argument: \u0026#39;greeting\u0026#39; You can pass in none, some, or all of the keyword arguments. If your function takes keyword arguments, you can provide zero, one, or all of them when you call it. You don\u0026rsquo;t need to pass these arguments in order either.\n\u0026gt;\u0026gt;\u0026gt; def create_query(language=\u0026#34;JavaScipt\u0026#34;, num_stars=50, sort=\u0026#34;desc\u0026#34;): ... return f\u0026#34;language:{language} num_stars:{num_stars} sort:{sort}\u0026#34; ... \u0026gt;\u0026gt;\u0026gt; create_query() \u0026#39;language:JavaScipt num_stars:50 sort:desc\u0026#39; \u0026gt;\u0026gt;\u0026gt; create_query(language=\u0026#34;Ruby\u0026#34;) \u0026#39;language:Ruby num_stars:50 sort:desc\u0026#39; \u0026gt;\u0026gt;\u0026gt; create_query(num_stars=1, language=\u0026#34;Python\u0026#34;, sort=\u0026#34;asc\u0026#34;) \u0026#39;language:Python num_stars:1 sort:asc\u0026#39; You can pass in required parameters by keyword. Even if your function arguments don\u0026rsquo;t have keyword arguments with defaults, you can still pass values in to the function by name. This is especially helpful if you want to be extra clear about what you\u0026rsquo;re passing in.\n\u0026gt;\u0026gt;\u0026gt; def say_greeting(name, greeting): ... print(f\u0026#34;{greeting}, {name}.\u0026#34;) ... \u0026gt;\u0026gt;\u0026gt; say_greeting(\u0026#34;Nina\u0026#34;, \u0026#34;Hello\u0026#34;) Hello, Nina. \u0026gt;\u0026gt;\u0026gt; say_greeting(name=\u0026#34;Max\u0026#34;, greeting=\u0026#34;Bonjour\u0026#34;) Bonjour, Max. Arguments Danger Zone Never use mutable types, like lists as a default argument.\nWe\u0026rsquo;ll talk more about lists and mutability in the coming chapter, but for the time being remember to never use an empty list as a default value to a function.\nWhy? Because it won\u0026rsquo;t work like you\u0026rsquo;d expect it to.\n\u0026gt;\u0026gt;\u0026gt; # Don\u0026#39;t do this! \u0026gt;\u0026gt;\u0026gt; def add_five_to_list(my_list=[]): ... my_list.append(5) ... return my_list ... \u0026gt;\u0026gt;\u0026gt; # This works like we expected it to. \u0026gt;\u0026gt;\u0026gt; add_five_to_list() [5] \u0026gt;\u0026gt;\u0026gt; # Huh? \u0026gt;\u0026gt;\u0026gt; add_five_to_list() [5, 5] \u0026gt;\u0026gt;\u0026gt; # We see that the original `my_list` is still being modified. \u0026gt;\u0026gt;\u0026gt; add_five_to_list() [5, 5, 5] If you need to use a mutable type, like a list as a default, use a marker instead. We\u0026rsquo;ll cover this technique when we talk about lists in the next chapter.\nIn Python, default arguments are evaluated only once \u0026ndash; when the function is defined. Not each time the function is called. That means if you use a value that can be changed, it won\u0026rsquo;t behave like you\u0026rsquo;d expect it to.\nNaming Functions and Arguments Because Python is a dynamic language (sometimes called duck-typed) we use names as cues for what our function does, the arguments it accepts, and the values it returns.\nThis is especially important because we generally don\u0026rsquo;t declare types for our programs when we\u0026rsquo;re first starting out. Note: Python does support Type hinting, but it\u0026rsquo;s more of an intermediate feature. Make sure you have the basics down before learning more about it.\nTry to avoid single character names for your functions and variables, unless they have meaning in math.\nFor example, in this function, x and y are common names used when referring to points, so it\u0026rsquo;s OK to use single-letter names in this scenario.\ndef add_points(x1, y1, x2, y2): return x1 + x2, y1 + y2 For sequences, like lists, it\u0026rsquo;s appropriate to name them in the plural.\nFor example, I\u0026rsquo;d expect a variable called name to be a single string, and a variable called names to be a list of strings.\nA great resource to help you figure out the best naming conventions to use in your production Python code is a talk by Brandon Rhodes, called \u0026ldquo;The Naming of Ducks: Where Dynamic Types Meet Smart Conventions\u0026rdquo;.\n"
},
{
	"uri": "https://pythonianrocketship.github.io/en/02-introduction-to-python/110-control-statements-looping/40-break-continue/",
	"title": "break, continue, and return",
	"tags": [],
	"description": "",
	"content": " break and continue allow you to control the flow of your loops. They\u0026rsquo;re a concept that beginners to Python tend to misunderstand, so pay careful attention.\nUsing break The break statement will completely break out of the current loop, meaning it won\u0026rsquo;t run any more of the statements contained inside of it.\n\u0026gt;\u0026gt;\u0026gt; names = [\u0026#34;Rose\u0026#34;, \u0026#34;Max\u0026#34;, \u0026#34;Nina\u0026#34;, \u0026#34;Phillip\u0026#34;] \u0026gt;\u0026gt;\u0026gt; for name in names: ... print(f\u0026#34;Hello, {name}\u0026#34;) ... if name == \u0026#34;Nina\u0026#34;: ... break ... Hello, Rose Hello, Max Hello, Nina break completely breaks out of the loop.\nUsing continue continue works a little differently. Instead, it goes back to the start of the loop, skipping over any other statements contained within the loop.\n\u0026gt;\u0026gt;\u0026gt; for name in names: ... if name != \u0026#34;Nina\u0026#34;: ... continue ... print(f\u0026#34;Hello, {name}\u0026#34;) ... Hello, Nina continue continues to the start of the loop\nbreak and continue visualized What happens when we run the code from this Python file?\n# Python file names.py names = [\u0026#34;Jimmy\u0026#34;, \u0026#34;Rose\u0026#34;, \u0026#34;Max\u0026#34;, \u0026#34;Nina\u0026#34;, \u0026#34;Phillip\u0026#34;] for name in names: if len(name) != 4: continue print(f\u0026#34;Hello, {name}\u0026#34;) if name == \u0026#34;Nina\u0026#34;: break print(\u0026#34;Done!\u0026#34;) Results See if you can guess the results before expanding this section. (env) $ python names.py Hello, Rose Hello, Nina Done! Using break and continue in nested loops. Remember, break and continue only work for the current loop. Even though I\u0026rsquo;ve been programming Python for years, this is something that still trips me up!\n\u0026gt;\u0026gt;\u0026gt; names = [\u0026#34;Rose\u0026#34;, \u0026#34;Max\u0026#34;, \u0026#34;Nina\u0026#34;] \u0026gt;\u0026gt;\u0026gt; target_letter = \u0026#39;x\u0026#39; \u0026gt;\u0026gt;\u0026gt; for name in names: ... print(f\u0026#34;{name} in outer loop\u0026#34;) ... for char in name: ... if char == target_letter: ... print(f\u0026#34;Found {name} with letter: {target_letter}\u0026#34;) ... print(\u0026#34;breaking out of inner loop\u0026#34;) ... break ... Rose in outer loop Max in outer loop Found Max with letter: x breaking out of inner loop Nina in outer loop \u0026gt;\u0026gt;\u0026gt; break in the inner loop only breaks out of the inner loop! The outer loop continues to run.\nLoop Control in while loops You can also use break and continue in while loops. One common scenario is running a loop forever, until a certain condition is met.\n\u0026gt;\u0026gt;\u0026gt; count = 0 \u0026gt;\u0026gt;\u0026gt; while True: ... count += 1 ... if count == 5: ... print(\u0026#34;Count reached\u0026#34;) ... break ... Count reached Be careful that your condition will eventually be met, or else your program will get stuck in an infinite loop. For production use, it\u0026rsquo;s better to use asynchronous programming.\nLoops and the return statement Just like in functions, consider the return statement the hard kill-switch of the loop.\n\u0026gt;\u0026gt;\u0026gt; def name_length(names): ... for name in names: ... print(name) ... if name == \u0026#34;Nina\u0026#34;: ... return \u0026#34;Found the special name\u0026#34; ... \u0026gt;\u0026gt;\u0026gt; names = [\u0026#34;Max\u0026#34;, \u0026#34;Nina\u0026#34;, \u0026#34;Rose\u0026#34;] \u0026gt;\u0026gt;\u0026gt; name_length(names) Max Nina \u0026#39;Found the special name\u0026#39; "
},
{
	"uri": "https://pythonianrocketship.github.io/en/03-intermediate-python/40-exceptions/",
	"title": "Exceptions",
	"tags": [],
	"description": "",
	"content": "Chapter 4 Exceptions In this chapter you\u0026rsquo;ll learn all about Exceptions in Python. We\u0026rsquo;ll start by reviewing the exception hierarchy, raising exceptions, examining try and catch, and finally how to create our own Exception classes.\n"
},
{
	"uri": "https://pythonianrocketship.github.io/en/02-introduction-to-python/090-boolean-logic/40-exercise/",
	"title": "Practice",
	"tags": [],
	"description": "",
	"content": "Boolean Logic Comparisons Let\u0026rsquo;s practice using our comparison operators. Remember:\nOperator Means \u0026lt; less-than \u0026lt;= less-than-or-equal-to \u0026gt; greater-than \u0026gt;= greater-than-or-equal-to == equals != not-equals Remember, the first six operators test the object\u0026rsquo;s value. is and is not test whether two objects are the same thing. This is useful for singletons, such as None or False. We won\u0026rsquo;t be using them much in this intro course, but feel free to play with them.\n\u0026gt;\u0026gt;\u0026gt; 10 \u0026gt; 5 \u0026gt;\u0026gt;\u0026gt; 5 \u0026gt; 10 \u0026gt;\u0026gt;\u0026gt; 10 \u0026gt; 10 \u0026gt;\u0026gt;\u0026gt; 10 \u0026gt;= 10 \u0026gt;\u0026gt;\u0026gt; 5 \u0026lt; 10 \u0026gt;\u0026gt;\u0026gt; 5 \u0026lt; 5 \u0026gt;\u0026gt;\u0026gt; 5 \u0026lt;= 5 \u0026gt;\u0026gt;\u0026gt; 5 == 5 \u0026gt;\u0026gt;\u0026gt; 5 != 10 Here\u0026#39;s what you should have seen in your REPL: \u0026gt;\u0026gt;\u0026gt; 10 \u0026gt; 5 True \u0026gt;\u0026gt;\u0026gt; 5 \u0026gt; 10 False \u0026gt;\u0026gt;\u0026gt; 10 \u0026gt; 10 False \u0026gt;\u0026gt;\u0026gt; 10 \u0026gt;= 10 True \u0026gt;\u0026gt;\u0026gt; 5 \u0026lt; 10 True \u0026gt;\u0026gt;\u0026gt; 5 \u0026lt; 5 False \u0026gt;\u0026gt;\u0026gt; 5 \u0026lt;= 5 True \u0026gt;\u0026gt;\u0026gt; 5 == 5 True \u0026gt;\u0026gt;\u0026gt; 5 != 10 True Truthiness Different languages have different ideas of what is \u0026ldquo;truthy\u0026rdquo; and \u0026ldquo;falsy.\u0026rdquo; In Python, all objects can be tested for truth, and an object is considered True unless except under certain circumstances that we talked about earlier in the chapter. Remember that checking if an object is \u0026ldquo;equal\u0026rdquo; to another object doesn\u0026rsquo;t necessarily mean the same thing. An object is considered \u0026ldquo;truthy\u0026rdquo; if it satisfies the check performed by if or while statements.\nLet\u0026rsquo;s try a few of these out:\n\u0026gt;\u0026gt;\u0026gt; 5 == True \u0026gt;\u0026gt;\u0026gt; # The number 5 does not equal True, but... \u0026gt;\u0026gt;\u0026gt; if 5: ... print(\u0026#34;The number 5 is truthy!\u0026#34;) ... \u0026gt;\u0026gt;\u0026gt; # The number 5 is truthy for an if test! True and False can also be represented by 1 and 0\n\u0026gt;\u0026gt;\u0026gt; 1 == True \u0026gt;\u0026gt;\u0026gt; 0 == False Here\u0026#39;s what you should have seen in your REPL: \u0026gt;\u0026gt;\u0026gt; 5 == True False \u0026gt;\u0026gt;\u0026gt; # The number 5 does not equal True, but... \u0026gt;\u0026gt;\u0026gt; if 5: ... print(\u0026#34;The number 5 is truthy!\u0026#34;) ... The number 5 is truthy! \u0026gt;\u0026gt;\u0026gt; # The number 5 is truthy for an if test! \u0026gt;\u0026gt;\u0026gt; 1 == True True \u0026gt;\u0026gt;\u0026gt; 0 == False True Boolean Operators Python also supports boolean operators, although they\u0026rsquo;re a little different than the comparison operators. Remember that or and and return one of their operands, rather than True or False.\nOperation Result x or y if x is false, then y, else x x and y if x is false, then x, else y not x if x is false, then True, else False \u0026gt;\u0026gt;\u0026gt; True or False \u0026gt;\u0026gt;\u0026gt; [] or [1, 2, 3] \u0026gt;\u0026gt;\u0026gt; \u0026#34;Hello\u0026#34; or None \u0026gt;\u0026gt;\u0026gt; True and False \u0026gt;\u0026gt;\u0026gt; 5 and 0 \u0026gt;\u0026gt;\u0026gt; [1] and [1, 2, 3] \u0026gt;\u0026gt;\u0026gt; \u0026#34;Hello\u0026#34; and None # Of course, you can use `and` and `or` aren\u0026#39;t limited to two operands \u0026gt;\u0026gt;\u0026gt; a = False \u0026gt;\u0026gt;\u0026gt; b = False \u0026gt;\u0026gt;\u0026gt; c = False \u0026gt;\u0026gt;\u0026gt; a or b or c \u0026gt;\u0026gt;\u0026gt; b = True \u0026gt;\u0026gt;\u0026gt; a or b or c \u0026gt;\u0026gt;\u0026gt; a and b and c \u0026gt;\u0026gt;\u0026gt; a = True \u0026gt;\u0026gt;\u0026gt; c = True \u0026gt;\u0026gt;\u0026gt; a and b and c Here\u0026#39;s what you should have seen in your REPL: \u0026gt;\u0026gt;\u0026gt; True or False True \u0026gt;\u0026gt;\u0026gt; [] or [1, 2, 3] [1, 2, 3] \u0026gt;\u0026gt;\u0026gt; \u0026#34;Hello\u0026#34; or None \u0026#39;Hello\u0026#39; \u0026gt;\u0026gt;\u0026gt; True and False False \u0026gt;\u0026gt;\u0026gt; 5 and 0 0 \u0026gt;\u0026gt;\u0026gt; [1] and [1, 2, 3] [1, 2, 3] \u0026gt;\u0026gt;\u0026gt; \u0026#34;Hello\u0026#34; and None \u0026gt;\u0026gt;\u0026gt; # No output, since the result was None \u0026gt;\u0026gt;\u0026gt; a = False \u0026gt;\u0026gt;\u0026gt; b = False \u0026gt;\u0026gt;\u0026gt; c = False \u0026gt;\u0026gt;\u0026gt; a or b or c False \u0026gt;\u0026gt;\u0026gt; b = True \u0026gt;\u0026gt;\u0026gt; a or b or c True \u0026gt;\u0026gt;\u0026gt; a and b and c False \u0026gt;\u0026gt;\u0026gt; a = True \u0026gt;\u0026gt;\u0026gt; c = True \u0026gt;\u0026gt;\u0026gt; a and b and c True "
},
{
	"uri": "https://pythonianrocketship.github.io/en/02-introduction-to-python/060-functions/40-scope/",
	"title": "Function Scope",
	"tags": [],
	"description": "",
	"content": "Scope inside a function Inside of a function in Python, the scope changes.\nThink about it this way: scoping in Python happens with whitespace. When we delineate the code a function contains by indenting it under a function definition, it\u0026rsquo;s scope changes to a new internal scope. It has access to the variables defined outside of it, but it can\u0026rsquo;t change them.\nOnce the function is done running, its scope goes away, as do its defined variables.\nLet\u0026rsquo;s double check this in the REPL:\n\u0026gt;\u0026gt;\u0026gt; def twitter_info(): ... twitter_account = \u0026#34;Seyamalam1\u0026#34; ... print(f\u0026#34;Account inside function: {twitter_account}\u0026#34;) ... \u0026gt;\u0026gt;\u0026gt; twitter_info() Account inside function: Seyamalam1 \u0026gt;\u0026gt;\u0026gt; print(f\u0026#34;Account outside of function: {twitter_account}\u0026#34;) Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; NameError: name \u0026#39;twitter_account\u0026#39; is not defined We get a NameError when trying to access the twitter_account variable outside of the function. That\u0026rsquo;s because it\u0026rsquo;s out of scope, exactly like we expected it to be.\nUsing variables defined outside of the function Generally, we want to be careful when using variables defined outside of our function.\nNote, that if we try to change the value of a variable defined outside of our function, we\u0026rsquo;ll see the changes in the function, but not outside of it.\nYou can\u0026rsquo;t change variables defined outside of the function inside of the function. If you try to, your changes will only apply while the function is running. Once the function is done running, the value goes back to what it was before your function ran.\nA little confusing, but let\u0026rsquo;s see it in action:\n\u0026gt;\u0026gt;\u0026gt; name = \u0026#34;Nina\u0026#34; \u0026gt;\u0026gt;\u0026gt; print(f\u0026#34;Name outside of function: {name}\u0026#34;) Name outside of function: Nina \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; def try_change_name(): ... name = \u0026#34;Max\u0026#34; ... print(f\u0026#34;Name inside of function: {name}\u0026#34;) ... \u0026gt;\u0026gt;\u0026gt; try_change_name() Name inside of function: Max \u0026gt;\u0026gt;\u0026gt; print(f\u0026#34;Name outside of function: {name}\u0026#34;) Name outside of function: Nina If we didn\u0026rsquo;t know what to look for, the program might not behave how we\u0026rsquo;d expect it to. A good rule of thumb is to name our variables clearly, and minimize how many variables we declare outside of functions and classes, which you\u0026rsquo;ll learn about in day two.\nAn appropriate use is when using a constant, a variable defined in all caps, with the words separated by underscores. A constant is a value that we expect to use several times within our program, but we never expect to change it programmatically.\nFor example:\n\u0026gt;\u0026gt;\u0026gt; ROOT_API_URL = \u0026#34;https://api.github.com\u0026#34; \u0026gt;\u0026gt;\u0026gt; def api_search_repos_url(): ... return f\u0026#34;{ROOT_API_URL}/search/repositories\u0026#34; ... \u0026gt;\u0026gt;\u0026gt; api_search_repos_url() \u0026#39;https://api.github.com/search/repositories\u0026#39; \u0026gt;\u0026gt;\u0026gt; "
},
{
	"uri": "https://pythonianrocketship.github.io/en/02-introduction-to-python/110-control-statements-looping/50-exercise/",
	"title": "Practice",
	"tags": [],
	"description": "",
	"content": "Control statements and looping if, else, and elif Let\u0026rsquo;s practice our branching statements. Remember that elif (short for else if) is an optional branch that will let you add another if test, and else is an optional branch that will catch anything not previously caught by if or elif.\n\u0026gt;\u0026gt;\u0026gt; def test_number(number): ... if number \u0026lt; 100: ... print(\u0026#34;This is a pretty small number\u0026#34;) ... elif number == 100: ... print(\u0026#34;This number is alright\u0026#34;) ... else: ... print(\u0026#34;This number is huge!\u0026#34;) ... \u0026gt;\u0026gt;\u0026gt; test_number(5) \u0026gt;\u0026gt;\u0026gt; test_number(99) \u0026gt;\u0026gt;\u0026gt; test_number(100) \u0026gt;\u0026gt;\u0026gt; test_number(8675309) Here\u0026#39;s what you should have seen in your REPL: \u0026gt;\u0026gt;\u0026gt; def test_number(number): ... if number \u0026lt; 100: ... print(\u0026#34;This is a pretty small number\u0026#34;) ... elif number == 100: ... print(\u0026#34;This number is alright\u0026#34;) ... else: ... print(\u0026#34;This number is huge!\u0026#34;) ... \u0026gt;\u0026gt;\u0026gt; test_number(5) This is a pretty small number \u0026gt;\u0026gt;\u0026gt; test_number(99) This is a pretty small number \u0026gt;\u0026gt;\u0026gt; test_number(100) This number is alright \u0026gt;\u0026gt;\u0026gt; test_number(8675309) This number is huge! You can also have multiple conditions in an if statement. This function prints \u0026ldquo;Fizzbuzz!\u0026rdquo; if the number is divisible by both 3 and 5 (the % or modulo operator returns the remainder from the division of two numbers):\n\u0026gt;\u0026gt;\u0026gt; def fizzbuzz(number): ... if number % 3 == 0 and number % 5 == 0: ... print(\u0026#34;Fizzbuzz!\u0026#34;) ... \u0026gt;\u0026gt;\u0026gt; fizzbuzz(3) \u0026gt;\u0026gt;\u0026gt; fizzbuzz(5) \u0026gt;\u0026gt;\u0026gt; fizzbuzz(15) Here\u0026#39;s what you should have seen in your REPL: \u0026gt;\u0026gt;\u0026gt; def fizzbuzz(number): ... if number % 3 == 0 and number % 5 == 0: ... print(\u0026#34;Fizzbuzz!\u0026#34;) ... \u0026gt;\u0026gt;\u0026gt; fizzbuzz(3) \u0026gt;\u0026gt;\u0026gt; fizzbuzz(5) \u0026gt;\u0026gt;\u0026gt; fizzbuzz(15) Fizzbuzz! Let\u0026rsquo;s also practice using if to test for an empty list. Remember that an empty list is \u0026ldquo;Falsey\u0026rdquo;, or resolves to False. Write a function to print a list of elements, or an error message if the list is empty. Print a special message if a list item is None:\n\u0026gt;\u0026gt;\u0026gt; def my_func(my_list): ... if my_list: ... for item in my_list: ... if item is None: ... print(\u0026#34;Got None!\u0026#34;) ... else: ... print(item) ... else: ... print(\u0026#34;Got an empty list!\u0026#34;) ... \u0026gt;\u0026gt;\u0026gt; my_func([1, 2, 3]) 1 2 3 \u0026gt;\u0026gt;\u0026gt; my_func([2, None, \u0026#34;hello\u0026#34;, 42]) 2 Got None! hello 42 \u0026gt;\u0026gt;\u0026gt; my_func([]) Got an empty list! The for loop, range() and enumerate() Let\u0026rsquo;s try making a list and looping over it:\n\u0026gt;\u0026gt;\u0026gt; my_list = [0, 1, 2] \u0026gt;\u0026gt;\u0026gt; for num in my_list: ... print(f\u0026#34;Next value: {num}\u0026#34;) ... If we\u0026rsquo;re just interested in looping over a list of numbers, we can use the range() function instead. Remember that the first argument is inclusive and the second is exclusive:\n\u0026gt;\u0026gt;\u0026gt; for num in range(0, 3): ... print(f\u0026#34;Next value: {num}\u0026#34;) ... Another useful function is enumerate(), which iterates over an iterable (like a list) and also gives you an automatic counter. enumerate() returns a tuple in the form of (counter, item).\n\u0026gt;\u0026gt;\u0026gt; my_list = [\u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;, \u0026#34;baz\u0026#34;] \u0026gt;\u0026gt;\u0026gt; for index, item in enumerate(my_list): ... print(f\u0026#34;Item {index}: {item}\u0026#34;) ... We can also loop over a dictionary\u0026rsquo;s keys and/or values. If you try to iterate over the dictionary object itself, what do you get?\n\u0026gt;\u0026gt;\u0026gt; my_dict = {\u0026#34;foo\u0026#34;: \u0026#34;bar\u0026#34;, \u0026#34;hello\u0026#34;: \u0026#34;world\u0026#34;} \u0026gt;\u0026gt;\u0026gt; for key in my_dict: ... print(f\u0026#34;Key: {key}\u0026#34;) ... # This is equivalent to... \u0026gt;\u0026gt;\u0026gt; for key in my_dict.keys(): ... print(f\u0026#34;Key: {key}\u0026#34;) ... The keys() method returns the dictionary\u0026rsquo;s keys as a list, which you can then iterate over as you would any other list. This also works for values()\n\u0026gt;\u0026gt;\u0026gt; for value in my_dict.values(): ... print(f\u0026#34;Value: {value}\u0026#34;) ... The most useful function, however, is items(), which returns the dictionary\u0026rsquo;s items as tuples in the form of (key, value):\n\u0026gt;\u0026gt;\u0026gt; for key, value in my_dict.items(): ... print(f\u0026#34;Item {key} = {value}\u0026#34;) ... Here\u0026#39;s what you should have seen in your REPL: \u0026gt;\u0026gt;\u0026gt; my_list = [1, 2, 3] \u0026gt;\u0026gt;\u0026gt; for num in my_list: ... print(f\u0026#34;Next value: {num}\u0026#34;) ... Next value: 0 Next value: 1 Next value: 2 \u0026gt;\u0026gt;\u0026gt; for num in range(0, 3): ... print(f\u0026#34;Next value: {num}\u0026#34;) ... Next value: 0 Next value: 1 Next value: 2 \u0026gt;\u0026gt;\u0026gt; my_list = [\u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;, \u0026#34;baz\u0026#34;] \u0026gt;\u0026gt;\u0026gt; for index, item in enumerate(my_list): ... print(f\u0026#34;Item {index}: {item}\u0026#34;) ... Item 0: foo Item 1: bar Item 2: baz \u0026gt;\u0026gt;\u0026gt; my_dict = {\u0026#34;foo\u0026#34;: \u0026#34;bar\u0026#34;, \u0026#34;hello\u0026#34;: \u0026#34;world\u0026#34;} \u0026gt;\u0026gt;\u0026gt; for key in my_dict: ... print(f\u0026#34;Key: {key}\u0026#34;) ... Key: foo Key: hello \u0026gt;\u0026gt;\u0026gt; for key in my_dict.keys(): ... print(f\u0026#34;Key: {key}\u0026#34;) ... Key: foo Key: hello \u0026gt;\u0026gt;\u0026gt; for value in my_dict.values(): ... print(f\u0026#34;Value: {value}\u0026#34;) ... Value: bar Value: world \u0026gt;\u0026gt;\u0026gt; for key, value in my_dict.items(): ... print(f\u0026#34;Item {key} = {value}\u0026#34;) ... Item foo = bar Item hello = world break, continue, and return break and continue are important functions for controlling the program flow inside loops. break ends the loop immediately and continues executing from outside the loop\u0026rsquo;s scope, and continue skips the remainder of the loop and continues executing from the next round of the loop. Let\u0026rsquo;s practice:\n\u0026gt;\u0026gt;\u0026gt; for num in range(0, 100): ... print(f\u0026#34;Testing number {num}\u0026#34;) ... if num == 3: ... print(\u0026#34;Found number 3!\u0026#34;) ... break ... print(\u0026#34;Not yet...\u0026#34;) ... Notice that \u0026ldquo;Not yet\u0026hellip;\u0026rdquo; doesn\u0026rsquo;t get printed for number 3, because we break out of the loop first. Let\u0026rsquo;s try a continue:\n\u0026gt;\u0026gt;\u0026gt; for num in range(0, 100): ... print(f\u0026#34;Testing number {num}\u0026#34;) ... if num \u0026lt; 3: ... continue ... elif num == 5: ... print(\u0026#34;Found number 5!\u0026#34;) ... break ... print(\u0026#34;Not yet...\u0026#34;) ... Notice that \u0026ldquo;Not yet\u0026hellip;\u0026rdquo; doesn\u0026rsquo;t get printed at all until the number is 3, because the continue short-circuits the loop back to the beginning. Then we break when we hit 5.\nYou can also use the return keyword to break out of a loop within a function, while optionally returning a value.\n\u0026gt;\u0026gt;\u0026gt; def is_number_in_list(number_to_check, list_to_search): ... for num in list_to_search: ... print(f\u0026#34;Checking {num}...\u0026#34;) ... if num == number_to_check: ... return True ... return False \u0026gt;\u0026gt;\u0026gt; my_list = [1, 2, 3, 4, 5] \u0026gt;\u0026gt;\u0026gt; is_number_in_list(27, my_list) \u0026gt;\u0026gt;\u0026gt; is_number_in_list(2, my_list) Notice that our function is_number_in_list checks all the numbers in my_list on the first run, but on the next run, stops immediately when it hits 3 and returns True.\nHere\u0026#39;s what you should have seen in your REPL: \u0026gt;\u0026gt;\u0026gt; for num in range(0, 100): ... print(f\u0026#34;Testing number {num}\u0026#34;) ... if num == 3: ... print(\u0026#34;Found number 3!\u0026#34;) ... break ... print(\u0026#34;Not yet...\u0026#34;) ... Testing number 0 Not yet... Testing number 1 Not yet... Testing number 2 Not yet... Testing number 3 Found number 3! \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; for num in range(0, 100): ... print(f\u0026#34;Testing number {num}\u0026#34;) ... if num \u0026lt; 3: ... continue ... elif num == 5: ... print(\u0026#34;Found number 5!\u0026#34;) ... break ... print(\u0026#34;Not yet...\u0026#34;) ... Testing number 0 Testing number 1 Testing number 2 Testing number 3 Not yet... Testing number 4 Not yet... Testing number 5 Found number 5! \u0026gt;\u0026gt;\u0026gt; def is_number_in_list(number_to_check, list_to_search): ... for num in list_to_search: ... print(f\u0026#34;Checking {num}...\u0026#34;) ... if num == number_to_check: ... return True ... return False ... \u0026gt;\u0026gt;\u0026gt; is_number_in_list(27, my_list) Checking 1... Checking 2... Checking 3... Checking 4... Checking 5... False \u0026gt;\u0026gt;\u0026gt; is_number_in_list(2, my_list) Checking 1... Checking 2... True while loop Instead of looping over a sequence, while loops continue looping while a certain condition is met (or not met). The condition is checked at the beginning every iteration.\n\u0026gt;\u0026gt;\u0026gt; counter = 0 \u0026gt;\u0026gt;\u0026gt; while counter \u0026lt; 3: ... print(f\u0026#34;Counter = {counter}\u0026#34;) ... counter += 1 Notice that the loop ends once counter 3, and the remainder of the loop is bypassed. You can also loop forever by using while True or while False, but you should make sure you have solid break conditions, or your program will just loop forever (unless that\u0026rsquo;s what you want).\n\u0026gt;\u0026gt;\u0026gt; counter = 0 \u0026gt;\u0026gt;\u0026gt; while True: ... print(f\u0026#34;Counter = {counter}\u0026#34;) ... if counter == 3: ... break ... counter += 1 Here\u0026#39;s what you should have seen in your REPL: \u0026gt;\u0026gt;\u0026gt; counter = 0 \u0026gt;\u0026gt;\u0026gt; while counter \u0026lt; 3: ... print(f\u0026#34;Counter = {counter}\u0026#34;) ... counter += 1 ... Counter = 0 Counter = 1 Counter = 2 \u0026gt;\u0026gt;\u0026gt; counter = 0 \u0026gt;\u0026gt;\u0026gt; while True: ... print(f\u0026#34;Counter = {counter}\u0026#34;) ... if counter == 3: ... break ... counter += 1 ... Counter = 0 Counter = 1 Counter = 2 Counter = 3 Nested Loops Nesting loops is often necessary and sometimes tricky. The break keyword will only get you out of whichever loop you\u0026rsquo;re breaking. The only way to exit all loops is with multiple break statements (at each level), or the return keyword (inside a function). For example:\nnames = [\u0026#34;Rose\u0026#34;, \u0026#34;Max\u0026#34;, \u0026#34;Nina\u0026#34;] target_letter = \u0026#39;x\u0026#39; found = False for name in names: for char in name: if char == target_letter: found = True break if found: print(f\u0026#34;Found {name} with letter: {target_letter}\u0026#34;) break Or:\n\u0026gt;\u0026gt;\u0026gt; for x in range(0, 5): ... for y in range(0, 5): ... print(f\u0026#34;x = {x}, y = {y}\u0026#34;) ... if y == 2: ... break ... Notice how the inner y loop never gets above 2, whereas the outer x loop continues until the end of its range.\nHere\u0026#39;s what you should have seen in your REPL: \u0026gt;\u0026gt;\u0026gt; for x in range(0, 5): ... for y in range(0, 5): ... print(f\u0026#34;x = {x}, y = {y}\u0026#34;) ... if y == 2: ... break ... x = 0, y = 0 x = 0, y = 1 x = 0, y = 2 x = 1, y = 0 x = 1, y = 1 x = 1, y = 2 x = 2, y = 0 x = 2, y = 1 x = 2, y = 2 x = 3, y = 0 x = 3, y = 1 x = 3, y = 2 x = 4, y = 0 x = 4, y = 1 x = 4, y = 2 "
},
{
	"uri": "https://pythonianrocketship.github.io/en/03-intermediate-python/50-libraries-modules/",
	"title": "Libraries and Modules",
	"tags": [],
	"description": "",
	"content": "Chapter 5 Libraries and Modules The Python language was designed to be \u0026ldquo;batteries included\u0026rdquo; \u0026ndash; it has a rich and versatile standard library which is immediately available, without making the user download separate packages. This has given the Python language a head start in many projects. Let\u0026rsquo;s explore some of the helpful packages in the standard library, and learn how to make our own modules.\n"
},
{
	"uri": "https://pythonianrocketship.github.io/en/02-introduction-to-python/060-functions/50-exercise/",
	"title": "Practice",
	"tags": [],
	"description": "",
	"content": "Functions Let\u0026rsquo;s try creating a basic function. Use tab to indent the second line, and press enter on an empty line to finish the function.\n\u0026gt;\u0026gt;\u0026gt; def add_numbers(x, y): ... return x + y ... # Press Enter Now let\u0026rsquo;s try our new function. Type this into your REPL:\n\u0026gt;\u0026gt;\u0026gt; add_numbers(1, 2) # Let\u0026#39;s use the string formatting we learned in the last chapter \u0026gt;\u0026gt;\u0026gt; print(f\u0026#34;The sum of 1 and 2 is {add_numbers(1, 2)}\u0026#34;) Here\u0026#39;s what you should have seen in your REPL: \u0026gt;\u0026gt;\u0026gt; add_numbers(1, 2) 3 # Let\u0026#39;s use the string formatting we learned in the last chapter \u0026gt;\u0026gt;\u0026gt; print(f\u0026#34;The sum of 1 and 2 is {add_numbers(1, 2)}\u0026#34;) The sum of 1 and 2 is 3 The Importance of Whitespace Here\u0026rsquo;s an error that you\u0026rsquo;ll become very familiar with during your career as a Pythonista, the IndentationError. Whitespace is important for defining function scope in python, so missing or extra indentations or spaces will cause the runtime to throw this error. Let\u0026rsquo;s redefine our add_numbers function, but we\u0026rsquo;ll forget to indent the second line, return x + y. Notice that the second line is directly under (at the same indentation level) as the def:\n\u0026gt;\u0026gt;\u0026gt; def add_numbers(x, y): ... return x + y File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 2 return x + y ^ IndentationError: expected an indented block Notice how the runtime tells us the line that failed (line 2), gives you a copy of the line with an arrow pointing to the offending error (return x + y), and then tells you the error (IndentationError) with additional information (expected an indented block).\nFunction Scope As we saw earlier, scoping in Python happens with whitespace. Let\u0026rsquo;s see this in action:\n\u0026gt;\u0026gt;\u0026gt; x = 1 \u0026gt;\u0026gt;\u0026gt; y = 2 \u0026gt;\u0026gt;\u0026gt; def add_numbers(x, y): ... print(f\u0026#34;Inside the function, x = {x} and y = {y}\u0026#34;) ... return x + y ... \u0026gt;\u0026gt;\u0026gt; print(f\u0026#34;Outside the function, x = {x} and y = {y}\u0026#34;) \u0026gt;\u0026gt;\u0026gt; print(f\u0026#34;The sum of 5 and 6 is {add_numbers(5, 6)}\u0026#34;) Here\u0026#39;s what you should have seen in your REPL: \u0026gt;\u0026gt;\u0026gt; x = 1 \u0026gt;\u0026gt;\u0026gt; y = 2 \u0026gt;\u0026gt;\u0026gt; def add_numbers(x, y): ... print(f\u0026#34;Inside the function, x = {x} and y = {y}\u0026#34;) ... return x + y ... \u0026gt;\u0026gt;\u0026gt; print(f\u0026#34;Outside the function, x = {x} and y = {y}\u0026#34;) Outside the function, x = 1 and y = 2 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; print(f\u0026#34;The sum of 5 and 6 is {add_numbers(5, 6)}\u0026#34;) Inside the function, x = 5 and y = 6 The sum of 5 and 6 is 11 Positional Arguments vs Keyword Arguments The x and y arguments for our add_numbers() function are called positional arguments. Python also lets us declare keyword arguments. Keyword arguments are great for setting default values, because passing them is optional. Just remember that keyword arguments must come after any positional arguments. Let\u0026rsquo;s make a more generic function for doing math:\n\u0026gt;\u0026gt;\u0026gt; def calculate_numbers(x, y, operation=\u0026#34;add\u0026#34;): ... if operation == \u0026#34;add\u0026#34;: ... return x + y ... elif operation == \u0026#34;subtract\u0026#34;: ... return x - y ... # Let\u0026#39;s try our new function. Remember, if we don\u0026#39;t pass the operation keyword argument, the default is \u0026#34;add\u0026#34; \u0026gt;\u0026gt;\u0026gt; calculate_numbers(2, 3) # You can pass a keyword argument as a normal positional argument \u0026gt;\u0026gt;\u0026gt; calculate_numbers(2, 3, \u0026#34;subtract\u0026#34;) # You can also use the argument\u0026#39;s keyword. This helps with readability \u0026gt;\u0026gt;\u0026gt; calculate_numbers(2, 3, operation=\u0026#34;subtract\u0026#34;) Here\u0026#39;s what you should have seen in your REPL: \u0026gt;\u0026gt;\u0026gt; def calculate_numbers(x, y, operation=\u0026#34;add\u0026#34;): ... if operation == \u0026#34;add\u0026#34;: ... return x + y ... elif operation == \u0026#34;subtract\u0026#34;: ... return x - y ... # Let\u0026#39;s try our new function. Remember, if we don\u0026#39;t pass the operation keyword argument, the default is \u0026#34;add\u0026#34; \u0026gt;\u0026gt;\u0026gt; calculate_numbers(2, 3) 5 # You can pass a keyword argument as a normal positional argument \u0026gt;\u0026gt;\u0026gt; calculate_numbers(2, 3, \u0026#34;subtract\u0026#34;) -1 # You can also use the argument\u0026#39;s keyword. This helps with readability \u0026gt;\u0026gt;\u0026gt; calculate_numbers(2, 3, operation=\u0026#34;subtract\u0026#34;) -1 "
},
{
	"uri": "https://pythonianrocketship.github.io/en/02-introduction-to-python/080-advanced-datatypes/50-sets/",
	"title": "Sets",
	"tags": [],
	"description": "",
	"content": "Sets are a datatype that allows you to store other immutable types in an unsorted way. An item can only be contained in a set once. There are no duplicates allowed. The benefits of a set are: very fast membership testing along with being able to use powerful set operations, like union, difference, and intersection.\nset cheat sheet type set use Used for storing immutable data types uniquely. Easy to compare the items in sets. creation set() for an empty set ({} makes an empty dict) and {1, 2, 3} for a set with items in it search methods item in my_set search speed Searching for an item in a large set is very fast. common methods my_set.add(item), my_set.discard(item) to remove the item if it\u0026rsquo;s present, my_set.update(other_set) order preserved? No. Items can\u0026rsquo;t be accessed by index. mutable? Yes. Can add to or remove from sets. in-place sortable? No, because items aren\u0026rsquo;t ordered. Examples Empty sets Let\u0026rsquo;s create our first few sets.\nThe first thing we might try to do is create an empty set with {}, but we\u0026rsquo;ll come across a hurdle.\n\u0026gt;\u0026gt;\u0026gt; my_new_set = {} \u0026gt;\u0026gt;\u0026gt; type(my_new_set) \u0026lt;class \u0026#39;dict\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt; my_set = set() \u0026gt;\u0026gt;\u0026gt; type(my_set) \u0026lt;class \u0026#39;set\u0026#39;\u0026gt; You can\u0026rsquo;t create an empty set with {}. That creates a dict. Create an empty set with set() instead.\nWhile you\u0026rsquo;re learning Python, it\u0026rsquo;s useful to use type(), dir() and help() as often as possible.\nsets with items Now, let\u0026rsquo;s make a new set with some items in it, and test out important set concepts.\nsets can\u0026rsquo;t contain duplicate values \u0026gt;\u0026gt;\u0026gt; names = {\u0026#34;Nina\u0026#34;, \u0026#34;Max\u0026#34;, \u0026#34;Nina\u0026#34;} \u0026gt;\u0026gt;\u0026gt; names {\u0026#39;Max\u0026#39;, \u0026#39;Nina\u0026#39;} \u0026gt;\u0026gt;\u0026gt; len(names) 2 sets can\u0026rsquo;t contain mutable types The way that sets allow you to quickly check if an item is contained in them or not is with an algorithm called a hash. I won\u0026rsquo;t cover the details, but an algorithm is a way of representing an immutable data type with a unique numerical representation. In Python, there\u0026rsquo;s a built-in hash() function.\nThe hash() function only works on immutable data types. That means, data types where the contents can\u0026rsquo;t be changed after creation.\n\u0026gt;\u0026gt;\u0026gt; hash(\u0026#34;Nina\u0026#34;) 3509074130763756174 \u0026gt;\u0026gt;\u0026gt; hash([]) Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; TypeError: unhashable type: \u0026#39;list\u0026#39; You\u0026rsquo;ll see a TypeError: unhashable type: 'list' if you try to add a mutable data type (like a list) to a set.\nIf you try to add a mutable data type (like a list) to a set, you\u0026rsquo;ll see the same TypeError, complaining about an unhashable type.\n\u0026gt;\u0026gt;\u0026gt; {\u0026#34;Nina\u0026#34;} {\u0026#39;Nina\u0026#39;} \u0026gt;\u0026gt;\u0026gt; {[]} Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; TypeError: unhashable type: \u0026#39;list\u0026#39; sets can be used to de-duplicate the items in a list Tip: If you don\u0026rsquo;t care about order, you can quickly de-duplicate the items in a list by passing the list into the set constructor.\n\u0026gt;\u0026gt;\u0026gt; colors = [\u0026#34;Red\u0026#34;, \u0026#34;Yellow\u0026#34;, \u0026#34;Red\u0026#34;, \u0026#34;Green\u0026#34;, \u0026#34;Green\u0026#34;, \u0026#34;Green\u0026#34;] \u0026gt;\u0026gt;\u0026gt; set(colors) {\u0026#39;Red\u0026#39;, \u0026#39;Green\u0026#39;, \u0026#39;Yellow\u0026#39;} sets don\u0026rsquo;t have an order Sets don\u0026rsquo;t have an order. That means that when you print them, the items won\u0026rsquo;t be displayed in the order they were entered in the list.\n\u0026gt;\u0026gt;\u0026gt; my_set = {1, \u0026#34;a\u0026#34;, 2, \u0026#34;b\u0026#34;, \u0026#34;cat\u0026#34;} \u0026gt;\u0026gt;\u0026gt; my_set {1, 2, \u0026#39;cat\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;} It also means that you can\u0026rsquo;t access items in the set by position in subscript [] notation.\n\u0026gt;\u0026gt;\u0026gt; my_set = {\u0026#34;Red\u0026#34;, \u0026#34;Green\u0026#34;, \u0026#34;Blue\u0026#34;} \u0026gt;\u0026gt;\u0026gt; my_set[0] Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; TypeError: \u0026#39;set\u0026#39; object does not support indexing You\u0026rsquo;ll see TypeError: 'set' object does not support indexing if you try to access the items in a set by index with my_set[pos]\nTip: If your set contains items of the same type, and you want to sort the items, you\u0026rsquo;ll need to convert the set to a list first. Or, you can use the built-in sorted(sequence) method, which will do the conversion for you.\n\u0026gt;\u0026gt;\u0026gt; my_set = {\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;cat\u0026#34;, \u0026#34;dog\u0026#34;, \u0026#34;red\u0026#34;} \u0026gt;\u0026gt;\u0026gt; my_set {\u0026#39;b\u0026#39;, \u0026#39;red\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;cat\u0026#39;, \u0026#39;dog\u0026#39;} \u0026gt;\u0026gt;\u0026gt; sorted(my_set) [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;cat\u0026#39;, \u0026#39;dog\u0026#39;, \u0026#39;red\u0026#39;] adding to and removing from sets Since a set has no order, we can\u0026rsquo;t add or remove items to it by index. We need to call the operations with the item itself.\nAdd items to a set with my_set.add(item). \u0026gt;\u0026gt;\u0026gt; colors = {\u0026#34;Red\u0026#34;, \u0026#34;Green\u0026#34;, \u0026#34;Blue\u0026#34;} \u0026gt;\u0026gt;\u0026gt; colors.add(\u0026#34;Orange\u0026#34;) \u0026gt;\u0026gt;\u0026gt; colors {\u0026#39;Orange\u0026#39;, \u0026#39;Green\u0026#39;, \u0026#39;Blue\u0026#39;, \u0026#39;Red\u0026#39;} Remove items with my_set.discard(item) You can remove an item from a set if it\u0026rsquo;s present with my_set.discard(item). If the set doesn\u0026rsquo;t contain the item, no error occurs.\n\u0026gt;\u0026gt;\u0026gt; colors = {\u0026#34;Red\u0026#34;, \u0026#34;Green\u0026#34;, \u0026#34;Blue\u0026#34;} \u0026gt;\u0026gt;\u0026gt; colors.discard(\u0026#34;Green\u0026#34;) \u0026gt;\u0026gt;\u0026gt; colors {\u0026#39;Blue\u0026#39;, \u0026#39;Red\u0026#39;} \u0026gt;\u0026gt;\u0026gt; colors.discard(\u0026#34;Green\u0026#34;) \u0026gt;\u0026gt;\u0026gt; colors {\u0026#39;Blue\u0026#39;, \u0026#39;Red\u0026#39;} You can also remove items from a set with my_set.remove(item), which will raise a KeyError if the item doesn\u0026rsquo;t exist.\nUpdate a set with another sequence using my_set.update(sequence) You can update a set by passing in another sequence, meaning another set, list, or tuple.\n\u0026gt;\u0026gt;\u0026gt; colors = {\u0026#34;Red\u0026#34;, \u0026#34;Green\u0026#34;} \u0026gt;\u0026gt;\u0026gt; numbers = {1, 3, 5} \u0026gt;\u0026gt;\u0026gt; colors.update(numbers) \u0026gt;\u0026gt;\u0026gt; colors {1, 3, \u0026#39;Red\u0026#39;, 5, \u0026#39;Green\u0026#39;} Be careful passing in a string to my_set.update(sequence). That\u0026rsquo;s because a string is also a sequence. It\u0026rsquo;s a sequence of characters.\n\u0026gt;\u0026gt;\u0026gt; numbers = {1, 3, 5} \u0026gt;\u0026gt;\u0026gt; numbers.update(\u0026#34;hello\u0026#34;) \u0026gt;\u0026gt;\u0026gt; numbers {1, 3, \u0026#39;h\u0026#39;, 5, \u0026#39;o\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;l\u0026#39;} Your set will update with each character of the string, which was probably not your intended result.\nset operations sets allow quick and easy operations to compare items between two sets.\nset operations cheat sheet method operation symbol operation result s.union(t) s | t creates a new set with all the items from both s and t s.intersection(t) s \u0026amp; t creates a new set containing only items that are both in s and in t s.difference(t) s ^ t creates a new set containing items that are not in both s and in t examples Let\u0026rsquo;s see it in action.\nWe have two sets, rainbow_colors, which contain the colors of the rainbow, and favorite_colors, which contain my favorite colors.\n\u0026gt;\u0026gt;\u0026gt; rainbow_colors = {\u0026#34;Red\u0026#34;, \u0026#34;Orange\u0026#34;, \u0026#34;Yellow\u0026#34;, \u0026#34;Green\u0026#34;, \u0026#34;Blue\u0026#34;, \u0026#34;Violet\u0026#34;} \u0026gt;\u0026gt;\u0026gt; favorite_colors = {\u0026#34;Blue\u0026#34;, \u0026#34;Pink\u0026#34;, \u0026#34;Black\u0026#34;} First, let\u0026rsquo;s combine the sets and create a new set that contains all of the items from rainbow_colors and favorite_colors using the union operation. You can use the my_set.union(other_set) method, or you can just use the symbol for union |= from the table above.\n\u0026gt;\u0026gt;\u0026gt; rainbow_colors | favorite_colors {\u0026#39;Orange\u0026#39;, \u0026#39;Red\u0026#39;, \u0026#39;Yellow\u0026#39;, \u0026#39;Green\u0026#39;, \u0026#39;Violet\u0026#39;, \u0026#39;Blue\u0026#39;, \u0026#39;Black\u0026#39;, \u0026#39;Pink\u0026#39;} Next, let\u0026rsquo;s find the intersection. We\u0026rsquo;ll create a new set with only the items in both sets.\n\u0026gt;\u0026gt;\u0026gt; rainbow_colors \u0026amp; favorite_colors {\u0026#39;Blue\u0026#39;} Lastly, We can also find the difference. Create a new set with the items that are in in one, but not the other. We\u0026rsquo;ll see that \u0026quot;Blue\u0026quot; is missing from the list.\n\u0026gt;\u0026gt;\u0026gt; rainbow_colors ^ favorite_colors {\u0026#39;Orange\u0026#39;, \u0026#39;Red\u0026#39;, \u0026#39;Yellow\u0026#39;, \u0026#39;Green\u0026#39;, \u0026#39;Violet\u0026#39;, \u0026#39;Black\u0026#39;, \u0026#39;Pink\u0026#39;} There are other useful operations available on sets, such as checking if one set is a subset, a superset, and more, but I don\u0026rsquo;t have time to cover them all. Python also has a frozenset type, if you need the functionality of a set in an immutable package (meaning that the contents can\u0026rsquo;t be changed after creation).\nFind out more by reading the documentation, or calling help() on set.\n"
},
{
	"uri": "https://pythonianrocketship.github.io/en/02-introduction-to-python/175-running-code/50-exceptions/",
	"title": "Exceptions and Tracebacks",
	"tags": [],
	"description": "",
	"content": "We talked about how to read the traceback you see if an error occurs in a Python program earlier in the day, but let\u0026rsquo;s talk about what we can do about it.\nUncaught Exceptions Exit Our Program Let\u0026rsquo;s make a file called exceptions.py:\n# this will throw an exception! int(\u0026#34;a\u0026#34;) print(\u0026#34;End of the program.\u0026#34;) And run it:\n(env) $ python exceptions.py Traceback (most recent call last): File \u0026#34;/Users/nina/projects/2019-fem-python/python/content/02-introduction-to-python/175-running-code/code/exceptions.py\u0026#34;, line 2, in \u0026lt;module\u0026gt; int(\u0026#34;a\u0026#34;) ValueError: invalid literal for int() with base 10: \u0026#39;a\u0026#39; We\u0026rsquo;ll see that \u0026ldquo;Reached end of the program\u0026rdquo; was never printed out.\nIf we\u0026rsquo;re running our Python code from a file, an uncaught exception will quit the program.\nUsing try and except to catch Exceptions In order to prevent our program from exiting, we\u0026rsquo;ll need to catch the Exception with a try except block. The anatomy of a try except block:\ntry: \u0026lt;code to try\u0026gt; except ExceptionClass: \u0026lt;code to run if an exception happens\u0026gt; In order to write a try except block, we\u0026rsquo;ll need to know the class name of the Exception we\u0026rsquo;d like to catch. Luckily, the name is printed right there, in the traceback!\nLet\u0026rsquo;s update exceptions.py\ntry: int(\u0026#34;a\u0026#34;) except ValueError: print(\u0026#34;Oops, couldn\u0026#39;t convert that value into an int!\u0026#34;) print(\u0026#34;Reached end of the program.\u0026#34;) And the output:\n(env) $ python exceptions.py Oops, couldn\u0026#39;t convert that value into an int! Reached end of the program. You want to catch Exceptions that are as specific as possible.\nUsing as to Access The Exception You can optionally assign a label to the exception, and the exception will be assigned to the variable you specified, so you can look at it\u0026rsquo;s message, or examine it in other ways with except \u0026lt;ExceptionClass\u0026gt; as \u0026lt;variable_name\u0026gt;.\nUsing this syntax, variable_name can be anything. In this case, I picked error, but you\u0026rsquo;ll commonly see e used for this purpose in Python programs.\nLet\u0026rsquo;s update exceptions.py one more time:\ntry: int(\u0026#34;a\u0026#34;) except ValueError as error: print(f\u0026#34;Something went wrong. Message: {error}\u0026#34;) print(\u0026#34;Reached end of the program.\u0026#34;) If we run this code, we\u0026rsquo;ll see:\n(env) $ python exceptions.py Something went wrong. Message: invalid literal for int() with base 10: \u0026#39;a\u0026#39; Reached end of the program. This example just scratches the surface. We\u0026rsquo;ll cover Exceptions in much more detail in Day 2.\nAnatomy of a Traceback When running our code from Python files, we\u0026rsquo;ll need to look at your tracebacks a little more carefully.\nRemember, to understand tracebacks, read them from bottom to top.\nWhen we ran our first example, we saw:\nTraceback (most recent call last): File \u0026#34;/Users/nina/projects/2019-fem-python/python/content/02-introduction-to-python/175-running-code/code/exceptions.py\u0026#34;, line 2, in \u0026lt;module\u0026gt; int(\u0026#34;a\u0026#34;) ValueError: invalid literal for int() with base 10: \u0026#39;a\u0026#39; If we start reading from the bottom up, we\u0026rsquo;ll notice a lot of useful information.\nFirst, we\u0026rsquo;ll see the exception that was thrown, along with its class ValueError. Next, we\u0026rsquo;ll see the code that caused the Exception. One line up from that, we\u0026rsquo;ll see the path and the file the exception originated in, as well as the line number to look on. "
},
{
	"uri": "https://pythonianrocketship.github.io/en/01-introduction/02-requirements/05-vs-code/",
	"title": "Setting Up VS Code",
	"tags": [],
	"description": "",
	"content": "\nVisual Studio Code Visual Studio Code (or VS Code) is a free and open source graphical code editor. VS Code offers plenty of extensions to customize your experience. We\u0026rsquo;ll be using the powerful Python extension to edit our code because it\u0026rsquo;s jam-packed with helpful features.\n"
},
{
	"uri": "https://pythonianrocketship.github.io/en/03-intermediate-python/60-command-line-tools/",
	"title": "Writing Command Line Tools",
	"tags": [],
	"description": "",
	"content": "Chapter 6 Command Line Tools Learn how to write command line tool scripts in Python that accept input from a user.\n"
},
{
	"uri": "https://pythonianrocketship.github.io/en/02-introduction-to-python/080-advanced-datatypes/60-dictionaries/",
	"title": "Dictionaries",
	"tags": [],
	"description": "",
	"content": "Dictionaries are a useful type that allow us to store our data in key, value pairs. Dictionaries themselves are mutable, but, dictionary keys can only be immutable types.\nWe use dictionaries when we want to be able to quickly access additional data associated with a particular key. A great practical application for dictionaries is memoization. Let\u0026rsquo;s say you want to save computing power, and store the result for a function called with particular arguments. The arguments could be the key, with the result stored as the value. Next time someone calls your function, you can check your dictionary to see if the answer is pre-computed.\nLooking for a key in a large dictionary is extremely fast. Unlike lists, we don\u0026rsquo;t have to check every item for a match.\ndictionary cheat sheet type dict use Use for storing data in key, value pairs. Keys used must be immutable data types. creation {} or dict() for an empty dict. {1: \u0026quot;one\u0026quot;, 2: \u0026quot;two\u0026quot;} for a dict with items. search methods key in my_dict search speed Searching for a key in a large dictionary is fast. common methods my_dict[key] to get the value by key, and throw a KeyError if key is not in the dictionary. Use my_dict.get(key) to fail silently if key is not in my_dict. my_dict.items() for all key, value pairs, my_dict.keys() for all keys, and my_dict.values() for all values. order preserved? Sort of. As of Python 3.6 a dict is sorted by insertion order. Items can\u0026rsquo;t be accessed by index, only by key. mutable? Yes. Can add or remove keys from dicts. in-place sortable? No. dicts don\u0026rsquo;t have an index, only keys. Examples Empty dicts We already learned one of the methods of creating an empty dict when we tried (and failed) to create an empty set with {}. The other way is to use the dict() method.\n\u0026gt;\u0026gt;\u0026gt; my_dict = {} \u0026gt;\u0026gt;\u0026gt; type(my_dict) \u0026lt;class \u0026#39;dict\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt; my_dict = dict() \u0026gt;\u0026gt;\u0026gt; type(my_dict) \u0026lt;class \u0026#39;dict\u0026#39;\u0026gt; Creating dicts with items If we want to create dicts with items in them, we need to pass in key, value pairs. A dict is declared with curly braces {}, followed by a key and a value, separated with a colon :. Multiple key and value pairs are separated with commas ,.\nWe can call familiar methods on our dictionary, like finding out how many key / value pairs it contains with the built-in len(my_dict) method.\n\u0026gt;\u0026gt;\u0026gt; nums = {1: \u0026#34;one\u0026#34;, 2: \u0026#34;two\u0026#34;, 3: \u0026#34;three\u0026#34;} \u0026gt;\u0026gt;\u0026gt; len(nums) 3 Side note: What can be used as keys? Any type of object, mutable or immutable, can be used as a value but just like sets, dictionaries can only use immutable types as keys. That means you can use int, str, or even tuple as a key, but not a set, list, or other dictionary.\nThe follow is OK:\n\u0026gt;\u0026gt;\u0026gt; my_dict = {1: 1} \u0026gt;\u0026gt;\u0026gt; my_dict = {1: []} You\u0026rsquo;ll see a TypeError: unhashable type: 'list' if you try to use a mutable type, like a list as a dictionary key.\n\u0026gt;\u0026gt;\u0026gt; my_dict = {[]: 1} Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; TypeError: unhashable type: \u0026#39;list\u0026#39; Accessing Our dict contains key, value pairs. Because a dictionary isn\u0026rsquo;t ordered, we can\u0026rsquo;t access the items in it by position. Instead, to access the items in it, we use square-bracket my_dict[key] notation, similar to how we access items in a list with square bracket notation containing the position.\n\u0026gt;\u0026gt;\u0026gt; nums = {1: \u0026#34;one\u0026#34;, 2: \u0026#34;two\u0026#34;, 3: \u0026#34;three\u0026#34;} \u0026gt;\u0026gt;\u0026gt; nums[1] \u0026#39;one\u0026#39; \u0026gt;\u0026gt;\u0026gt; nums[2] \u0026#39;two\u0026#39; Q: What happens when we try to access a key in a dictionary with square bracket notation, but the key isn\u0026rsquo;t present?\nWe\u0026rsquo;ll get a KeyError: key if we try to access my_dict[key] with square bracket notation, but key isn\u0026rsquo;t in the dictionary.\n\u0026gt;\u0026gt;\u0026gt; nums = {1: \u0026#34;one\u0026#34;, 2: \u0026#34;two\u0026#34;, 3: \u0026#34;three\u0026#34;} \u0026gt;\u0026gt;\u0026gt; nums[4] Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; KeyError: 4 One way to get around this is to use the my_dict.get(key) method. Using this method, if the key isn\u0026rsquo;t present, no error is thrown, and no value (aka the None type) is returned.\n\u0026gt;\u0026gt;\u0026gt; nums = {1: \u0026#34;one\u0026#34;, 2: \u0026#34;two\u0026#34;, 3: \u0026#34;three\u0026#34;} \u0026gt;\u0026gt;\u0026gt; nums.get(4) \u0026gt;\u0026gt;\u0026gt; result = nums.get(4) \u0026gt;\u0026gt;\u0026gt; type(result) \u0026lt;class \u0026#39;NoneType\u0026#39;\u0026gt; If we want to provide a default value if the key is missing, we also pass an optional argument to the my_dict.get(key) method like so: my_dict.get(key, default_val)\n\u0026gt;\u0026gt;\u0026gt; nums = {1: \u0026#34;one\u0026#34;, 2: \u0026#34;two\u0026#34;, 3: \u0026#34;three\u0026#34;} \u0026gt;\u0026gt;\u0026gt; nums.get(4, \u0026#34;default\u0026#34;) \u0026#39;default\u0026#39; Adding, Removing To add a new key value pair to the dictionary, you\u0026rsquo;ll use square-bracket notation.\nIf you try to put a key into a dictionary that\u0026rsquo;s already there, you\u0026rsquo;ll just end up replacing it. To avoid subtle bugs, you can check if a particular key is in a dictionary with the in keyword. We\u0026rsquo;ll cover that technique in Chapter 6 - Control Statements and Looping.\n\u0026gt;\u0026gt;\u0026gt; nums = {1: \u0026#34;one\u0026#34;, 2: \u0026#34;two\u0026#34;, 3: \u0026#34;three\u0026#34;} \u0026gt;\u0026gt;\u0026gt; nums[8] = \u0026#34;eight\u0026#34; \u0026gt;\u0026gt;\u0026gt; nums {1: \u0026#39;one\u0026#39;, 2: \u0026#39;two\u0026#39;, 3: \u0026#39;three\u0026#39;, 8: \u0026#39;eight\u0026#39;} \u0026gt;\u0026gt;\u0026gt; nums[8] = \u0026#34;oops, overwritten\u0026#34; \u0026gt;\u0026gt;\u0026gt; nums {1: \u0026#39;one\u0026#39;, 2: \u0026#39;two\u0026#39;, 3: \u0026#39;three\u0026#39;, 8: \u0026#39;oops, overwritten\u0026#39;} \u0026gt;\u0026gt;\u0026gt; 8 in nums True Updating Just like with lists an sets, you can update the items in a dictionary with the items from another dictionary.\n\u0026gt;\u0026gt;\u0026gt; colors = {\u0026#34;r\u0026#34;: \u0026#34;Red\u0026#34;, \u0026#34;g\u0026#34;: \u0026#34;Green\u0026#34;} \u0026gt;\u0026gt;\u0026gt; numbers = {1: \u0026#34;one\u0026#34;, 2: \u0026#34;two\u0026#34;} \u0026gt;\u0026gt;\u0026gt; colors.update(numbers) \u0026gt;\u0026gt;\u0026gt; colors {\u0026#39;r\u0026#39;: \u0026#39;Red\u0026#39;, \u0026#39;g\u0026#39;: \u0026#39;Green\u0026#39;, 1: \u0026#39;one\u0026#39;, 2: \u0026#39;two\u0026#39;} Complex Dictionaries One incredibly useful scenario for dictionaries is storing the values in a list or other sequence. Going into too much detail is outside of the scope of the class, but I\u0026rsquo;ll show you a quick example:\n\u0026gt;\u0026gt;\u0026gt; colors = {\u0026#34;Green\u0026#34;: [\u0026#34;Spinach\u0026#34;]} \u0026gt;\u0026gt;\u0026gt; colors {\u0026#39;Green\u0026#39;: [\u0026#39;Spinach\u0026#39;]} \u0026gt;\u0026gt;\u0026gt; colors[\u0026#34;Green\u0026#34;].append(\u0026#34;Apples\u0026#34;) \u0026gt;\u0026gt;\u0026gt; colors {\u0026#39;Green\u0026#39;: [\u0026#39;Spinach\u0026#39;, \u0026#39;Apples\u0026#39;]} Working with items, keys, and values There are three useful methods you need to remember about dictionary access:\nmy_dict.keys() my_dict.values() my_dict.items() 1. my_dict.keys() Getting all the keys in a dictionary \u0026gt;\u0026gt;\u0026gt; nums = {1: \u0026#39;one\u0026#39;, 2: \u0026#39;two\u0026#39;, 3: \u0026#39;three\u0026#39;, 8: \u0026#39;eight\u0026#39;} \u0026gt;\u0026gt;\u0026gt; nums.keys() dict_keys([1, 2, 3, 8]) 2. my_dict.values() Getting all the values in a dictionary. \u0026gt;\u0026gt;\u0026gt; nums = {1: \u0026#39;one\u0026#39;, 2: \u0026#39;two\u0026#39;, 3: \u0026#39;three\u0026#39;, 8: \u0026#39;eight\u0026#39;} \u0026gt;\u0026gt;\u0026gt; nums.values() dict_values([\u0026#39;one\u0026#39;, \u0026#39;two\u0026#39;, \u0026#39;three\u0026#39;, \u0026#39;eight\u0026#39;]) 3. my_dict.items() Getting all the items (key, value pairs) in a dictionary Notice that my_dict.items() returns a type that looks like a list. It contains two-item tuples containing the key, value pairs.\n\u0026gt;\u0026gt;\u0026gt; nums = {1: \u0026#39;one\u0026#39;, 2: \u0026#39;two\u0026#39;, 3: \u0026#39;three\u0026#39;, 8: \u0026#39;eight\u0026#39;} \u0026gt;\u0026gt;\u0026gt; nums.items() dict_items([(1, \u0026#39;one\u0026#39;), (2, \u0026#39;two\u0026#39;), (3, \u0026#39;three\u0026#39;), (8, \u0026#39;eight\u0026#39;)]) "
},
{
	"uri": "https://pythonianrocketship.github.io/en/02-introduction-to-python/175-running-code/60-working-with-files/",
	"title": "Working With Files",
	"tags": [],
	"description": "",
	"content": "Python provides a built-in function for opening files, cleverly titled open(). The open() method will return an object that you can read() to get the data. By default, open() will open a file in read-only mode, however you can change this by passing a mode parameter. The list of optional modes is here:\nCharacter Meaning \u0026lsquo;r\u0026rsquo; open for reading (default) \u0026lsquo;w\u0026rsquo; open for writing, truncating the file first \u0026lsquo;x\u0026rsquo; open for exclusive creation, failing if the file already exists \u0026lsquo;a\u0026rsquo; open for writing, appending to the end of the file if it exists \u0026lsquo;b\u0026rsquo; binary mode \u0026rsquo;t' text mode (default) \u0026lsquo;+\u0026rsquo; open a disk file for updating (reading and writing) Opening a file would look something like this:\n# Open a file for reading \u0026gt;\u0026gt;\u0026gt; my_file = open(\u0026#34;my_file.txt\u0026#34;) # Open a file for reading or writing # This will replace any existing file \u0026gt;\u0026gt;\u0026gt; my_file = open(\u0026#34;my_file.txt\u0026#34;, \u0026#34;w\u0026#34;) # Open a file for reading or writing # This will append to the end of any existing file \u0026gt;\u0026gt;\u0026gt; my_file = open(\u0026#34;my_file.txt\u0026#34;, \u0026#34;a\u0026#34;) Of course, you always want to call close() on your open file object once you\u0026rsquo;re done with it, so that your program doesn\u0026rsquo;t leave open file handles dangling. But what happens if your program exits or crashes before you can close a file? Use a context manager!\nContext Managers Briefly, a Context Manager is like a wrapper around a block of code that depends on some resource. It\u0026rsquo;s a safer way of handling resources than, say, using open() and then remembering to close() later (and hoping your program doesn\u0026rsquo;t crash in between). It\u0026rsquo;s similar to using try... finally, but cleaner to look at. Context managers can contain code that auto-magically provisions a resource before your code runs, and cleans up afterward. For example, the open() function also works as a context manager, so opening a file looks like this:\n\u0026gt;\u0026gt;\u0026gt; with open(\u0026#34;my_file.text\u0026#34;) as my_file: ... contents = my_file.read() You can perform all the functions that require access to the open file within the with scope, and once you exit the with scope, the context manager will automatically close your file for you, even if your code hits an exception inside the context manager.\nWorking with Files Let\u0026rsquo;s try working with a simple json file. Download this cities.json file, which contains a listing of the top five cities in the US by population. We\u0026rsquo;ll import the json module to help us parse the data, and we\u0026rsquo;ll use a context manager to open the file.\n\u0026gt;\u0026gt;\u0026gt; import json \u0026gt;\u0026gt;\u0026gt; with open(\u0026#34;cities.json\u0026#34;) as cities_file: ... cities_data = json.load(cities_file) ... print(cities_data) ... [{\u0026#39;name\u0026#39;: \u0026#39;New York\u0026#39;, \u0026#39;pop\u0026#39;: 8550405}, {\u0026#39;name\u0026#39;: \u0026#39;Los Angeles\u0026#39;, \u0026#39;pop\u0026#39;: 3971883}, {\u0026#39;name\u0026#39;: \u0026#39;Chicago\u0026#39;, \u0026#39;pop\u0026#39;: 2720546}, {\u0026#39;name\u0026#39;: \u0026#39;Houston\u0026#39;, \u0026#39;pop\u0026#39;: 2296224}, {\u0026#39;name\u0026#39;: \u0026#39;Philadelphia\u0026#39;, \u0026#39;pop\u0026#39;: 1567442}] "
},
{
	"uri": "https://pythonianrocketship.github.io/en/02-introduction-to-python/060-functions/",
	"title": "Functions",
	"tags": [],
	"description": "",
	"content": "Chapter 3 Functions Functions help us organize our code in a way that\u0026rsquo;s reusable, and accept arguments and defaults where needed.\n"
},
{
	"uri": "https://pythonianrocketship.github.io/en/02-introduction-to-python/080-advanced-datatypes/65-mutability/",
	"title": "Mutability Cheat Sheet",
	"tags": [],
	"description": "",
	"content": "Mutability Mutability, simply put: the contents of a mutable object can be changed, while the contents of an immutable object cannot be.\nSimple Types All of the simple data types we covered first are immutable\ntype use mutable? int, float, decimal store numbers no str store strings no bool store True or False no Container Types For the mutability of the container types we covered in this chapter, check this helpful list:\ncontainer type use mutable? list ordered group of items, accessible by position yes set mutable unordered group consisting only of immutable items. useful for set operations (membership, intersection, difference, etc) yes tuple contain ordered groups of items in an immutable collection no dict contains key value pairs yes "
},
{
	"uri": "https://pythonianrocketship.github.io/en/02-introduction-to-python/175-running-code/65-libraries/",
	"title": "Working with Libraries",
	"tags": [],
	"description": "",
	"content": "Working with external libraries in Python makes use of the import keyword. While this can go anywhere in your file, it\u0026rsquo;s almost always best to import libraries at the top of each file where they\u0026rsquo;re used. For example, in the last section, we were able to call upon the built-in json library by calling import json at the top of our code.\nImporting modules with the import keyword is usually the best method, because it preserves the module\u0026rsquo;s namespace. However, you can also use the from \u0026lt;module\u0026gt; import \u0026lt;object\u0026gt; syntax to import a specific object (function, variable, subclass, etc.) from a module into your program\u0026rsquo;s namespace.\nFor example, if we wanted a random integer between 0 and 100, we could use random.randint():\n\u0026gt;\u0026gt;\u0026gt; import random \u0026gt;\u0026gt;\u0026gt; random.randint(0, 100) 42 Notice that the namespace is preserved (we needed to call random.randint()). If we use from instead:\n\u0026gt;\u0026gt;\u0026gt; from random import randint \u0026gt;\u0026gt;\u0026gt; randint(0, 100) 64 Installing the requests library with pip For the next chapter, we\u0026rsquo;ll be using an excellent 3rd part library called requests to make light work of retrieving data from web APIs. To install the requests library, run this on your command line:\n(env) $ python -m pip install requests This runs the pip module and asks it to find the requests library on PyPI.org (the Python Package Index) and install it in your local system, so that it becomes available for you to import. We\u0026rsquo;ll dive a little more into this later.\n"
},
{
	"uri": "https://pythonianrocketship.github.io/en/02-introduction-to-python/175-running-code/70-exercise/",
	"title": "Practice",
	"tags": [],
	"description": "",
	"content": "Running Code Let\u0026rsquo;s create a basic program that we can run as a file on the command line. We\u0026rsquo;ll start with a basic framework using a main() function.\ndef main(): pass if __name__ == \u0026#34;__main__\u0026#34;: main() Save your file as file_exercise.py and run it from the command line using python file_exercise.py. Note: we are concentrating on Python 3 for this class, so if you have Python 2 installed, you may need to explicitly use python3 file_exercise.py.\nWhat happened? Because you ran the file directly, the file\u0026rsquo;s __name__ variable is set to __main__, which triggers the if statement to run the main() function. This is a common pattern that you\u0026rsquo;ll see in Python programs, and it comes in handy for being able to write programs that work both on their own and when imported into other programs. The pass keyword does nothing, it\u0026rsquo;s just there to keep the empty main() function from throwing a syntax error.\nLet\u0026rsquo;s start filling in our main() function. We have a json file named cities.json which contains the top five cities in the US, sorted by population. You can download cities.json here. Let\u0026rsquo;s open the file and load in the data.\nimport json def main(): cities_file = open(\u0026#34;cities.json\u0026#34;) cities_data = json.load(cities_file) print(cities_data) if __name__ == \u0026#34;__main__\u0026#34;: main() First, we imported the built-in json library to help us decode the json file. Then, we opened the file using the open() function, and passed the open file handle to the json.load() function. The load() function read our data in and spit it out as a Python representation - in this case, a list of dictionaries. We then print this list.\nHere\u0026#39;s what you should have seen on your command line: (env) $ python file_execise.py [{\u0026#39;name\u0026#39;: \u0026#39;New York\u0026#39;, \u0026#39;pop\u0026#39;: 8550405}, {\u0026#39;name\u0026#39;: \u0026#39;Los Angeles\u0026#39;, \u0026#39;pop\u0026#39;: 3971883}, {\u0026#39;name\u0026#39;: \u0026#39;Chicago\u0026#39;, \u0026#39;pop\u0026#39;: 2720546}, {\u0026#39;name\u0026#39;: \u0026#39;Houston\u0026#39;, \u0026#39;pop\u0026#39;: 2296224}, {\u0026#39;name\u0026#39;: \u0026#39;Philadelphia\u0026#39;, \u0026#39;pop\u0026#39;: 1567442}] This list is a little hard to make sense of in its raw form, let\u0026rsquo;s print it a little nicer. Use enumerate() to go through the list and print it nicely:\nimport json def main(): cities_file = open(\u0026#34;cities.json\u0026#34;) cities_data = json.load(cities_file) print(\u0026#34;Largest cities in the US by population:\u0026#34;) for index, entry in enumerate(cities_data): print(f\u0026#34;{index + 1}: {entry[\u0026#39;name\u0026#39;]} - {entry[\u0026#39;pop\u0026#39;]}\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: main() A few new things here: first, remember that enumerate() outputs a tuple of (index, entry), so we use index and entry variables to capture those. Then, for every item in the list, we print the index (+ 1, because zero-indexed lists are sometimes hard to read), and we pull the name and population out of each entry dictionary using the dictionary [] syntax.\nHere\u0026#39;s what you should have seen on your command line: (env) $ python file_execise.py Largest cities in the US by population: 1: New York - 8550405 2: Los Angeles - 3971883 3: Chicago - 2720546 4: Houston - 2296224 5: Philadelphia - 1567442 One more thing to clean up - using the open() keyword on its own is frowned upon, because it won\u0026rsquo;t automatically close any resources you might open. Even if you call the close() keyword yourself, there\u0026rsquo;s no guarantee your program won\u0026rsquo;t crash, leaving important resources dangling. It\u0026rsquo;s safer to open files inside a context using the with keyword. Once your code exits the scope of the context, your file is automatically closed. Note: our reading and formatting code has shifted to the right because of the change in scope.\nimport json def main(): with open(\u0026#34;cities.json\u0026#34;) as cities_file: cities_data = json.load(cities_file) print(\u0026#34;Largest cities in the US by population:\u0026#34;) for index, entry in enumerate(cities_data): print(f\u0026#34;{index + 1}: {entry[\u0026#39;name\u0026#39;]} - {entry[\u0026#39;pop\u0026#39;]}\u0026#34;) print(\u0026#34;The file is now closed.\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: main() Here\u0026#39;s what you should have seen on your command line: (env) $ python file_execise.py Largest cities in the US by population: 1: New York - 8550405 2: Los Angeles - 3971883 3: Chicago - 2720546 4: Houston - 2296224 5: Philadelphia - 1567442 The file is now closed. Handling Exceptions Parsing files - especially if you didn\u0026rsquo;t create them - is often tricky, and you\u0026rsquo;re going to have to deal with less-than-perfect data. For example, go into your cities.json file and delete the last ] character. Run your program again.\nHere\u0026#39;s what you should have seen on your command line: (env) $ python file_execise.py Traceback (most recent call last): File \u0026#34;file_execise.py\u0026#34;, line 14, in \u0026lt;module\u0026gt; main() File \u0026#34;file_execise.py\u0026#34;, line 5, in main cities_data = json.load(cities_file) File \u0026#34;/usr/local/Cellar/python/3.7.2_2/Frameworks/Python.framework/Versions/3.7/lib/python3.7/json/__init__.py\u0026#34;, line 296, in load parse_constant=parse_constant, object_pairs_hook=object_pairs_hook, **kw) File \u0026#34;/usr/local/Cellar/python/3.7.2_2/Frameworks/Python.framework/Versions/3.7/lib/python3.7/json/__init__.py\u0026#34;, line 348, in loads return _default_decoder.decode(s) File \u0026#34;/usr/local/Cellar/python/3.7.2_2/Frameworks/Python.framework/Versions/3.7/lib/python3.7/json/decoder.py\u0026#34;, line 337, in decode obj, end = self.raw_decode(s, idx=_w(s, 0).end()) File \u0026#34;/usr/local/Cellar/python/3.7.2_2/Frameworks/Python.framework/Versions/3.7/lib/python3.7/json/decoder.py\u0026#34;, line 353, in raw_decode obj, end = self.scan_once(s, idx) json.decoder.JSONDecodeError: Expecting \u0026#39;,\u0026#39; delimiter: line 21 column 1 (char 234) Helpfully, the library told you (on the last line) approximately what is wrong and where. It also provides a Traceback to help you see what happened, starting with your main() function, which called json.load(cities_file), and into the functions used internally to the json library. This will become more useful once you start writing your own libraries, so practice reading and understanding your Tracebacks.\nBut let\u0026rsquo;s say we\u0026rsquo;re writing a web app or user-facing app and don\u0026rsquo;t want our users to see Tracebacks (they can be scary if you\u0026rsquo;re not a programmer, as well as risk your security by leaking information about your software). Let\u0026rsquo;s catch that JSONDecodeError and return something prettier.\nimport json def main(): with open(\u0026#34;cities.json\u0026#34;) as cities_file: try: cities_data = json.load(cities_file) print(\u0026#34;Largest cities in the US by population:\u0026#34;) for index, entry in enumerate(cities_data): print(f\u0026#34;{index + 1}: {entry[\u0026#39;name\u0026#39;]} - {entry[\u0026#39;pop\u0026#39;]}\u0026#34;) except json.decoder.JSONDecodeError as error: print(\u0026#34;Sorry, there was an error decoding that json file:\u0026#34;) print(f\u0026#34;\\t {error}\u0026#34;) print(\u0026#34;The file is now closed.\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: main() Here, we\u0026rsquo;ve wrapped our business logic in another scope - the try - except block. For the except, we reach into the json library and reference the JSONDecodeError that\u0026rsquo;s part of the decoder module. We assign it to error so that we can reference it later. We then print out the entire error, prefixed with a tab character \\t to make it a little easier to read. Voilà, we\u0026rsquo;ve caught our error and reported it to the user with (hopefully) helpful information (but not too much information).\nHere\u0026#39;s what you should have seen on your command line: (env) $ python file_execise.py Sorry, there was an error decoding that json file: Expecting \u0026#39;,\u0026#39; delimiter: line 21 column 1 (char 234) The file is now closed. "
},
{
	"uri": "https://pythonianrocketship.github.io/en/03-intermediate-python/70-tests/",
	"title": "Tests",
	"tags": [],
	"description": "",
	"content": "Chapter 7 Testing in Python Tests are a cornerstone of a solid Python program. Thankfully, because of Python\u0026rsquo;s \u0026ldquo;batteries included\u0026rdquo; philosophy, all the tools we need for unit testing are included in the standard library. Let\u0026rsquo;s learn the basics of Unit Testing.\n"
},
{
	"uri": "https://pythonianrocketship.github.io/en/02-introduction-to-python/080-advanced-datatypes/70-exercise/",
	"title": "Practice",
	"tags": [],
	"description": "",
	"content": "Lists, Dictionaries, Tuples, and Sets Lists Lists are great for storing an ordered sequence of objects. Remember that you can see the current state of your list at any time by typing the name of your list by itself. Check your list after every operation to see if it has changed.\n\u0026gt;\u0026gt;\u0026gt; my_list = [\u0026#34;h\u0026#34;, \u0026#34;e\u0026#34;, \u0026#34;l\u0026#34;, \u0026#34;l\u0026#34;, \u0026#34;o\u0026#34;] # Let\u0026#39;s look at our list: \u0026gt;\u0026gt;\u0026gt; my_list # Let\u0026#39;s add to my_list: \u0026gt;\u0026gt;\u0026gt; my_list.append(\u0026#34;!\u0026#34;) # Now let\u0026#39;s see it again: \u0026gt;\u0026gt;\u0026gt; my_list Let\u0026rsquo;s play with slices. How do we get the last two elements of our list?\n# We know the number of items in our list is 6... \u0026gt;\u0026gt;\u0026gt; len(my_list) 6 # So the last two indexes are 4 and 5. Since the first number in the slice is inclusive, and the second number is exclusive, we can ask for everything between index 4 and 6 \u0026gt;\u0026gt;\u0026gt; my_list[4:6] # We can also say \u0026#34;Give me everything after index 4 \u0026gt;\u0026gt;\u0026gt; my_list[4:] # Or, we can ask for just the last two items without caring how big the list is. This means \u0026#34;give me everything starting from two before the end\u0026#34;: \u0026gt;\u0026gt;\u0026gt; my_list[-2:] There are many other ways to interact with our lists as well:\n# Remove the first L: \u0026gt;\u0026gt;\u0026gt; my_list.remove(\u0026#34;l\u0026#34;) # Let\u0026#39;s put it back at index 2 \u0026gt;\u0026gt;\u0026gt; my_list.insert(2, \u0026#34;l\u0026#34;) # Delete any element \u0026gt;\u0026gt;\u0026gt; del my_list[0] # Remove and return the last element. Useful for queues! \u0026gt;\u0026gt;\u0026gt; last_item = my_list.pop() \u0026gt;\u0026gt;\u0026gt; last_item # We can also look at individual items my using an index: \u0026gt;\u0026gt;\u0026gt; my_list[2] # Or we can see if a certain value exists in the list: \u0026gt;\u0026gt;\u0026gt; \u0026#34;!\u0026#34; in my_list # Let\u0026#39;s sort our list in reverse order \u0026gt;\u0026gt;\u0026gt; my_list.sort(reverse=True) \u0026gt;\u0026gt;\u0026gt; my_list # Note that sort() doesn\u0026#39;t return anything, it sorts the list in-place # You can also use the sorted() function to return a new, sorted list without modifying the old one \u0026gt;\u0026gt;\u0026gt; sorted(my_list, reverse=False) \u0026gt;\u0026gt;\u0026gt; my_list Here\u0026#39;s what you should have seen in your REPL: \u0026gt;\u0026gt;\u0026gt; my_list = [\u0026#34;h\u0026#34;, \u0026#34;e\u0026#34;, \u0026#34;l\u0026#34;, \u0026#34;l\u0026#34;, \u0026#34;o\u0026#34;] \u0026gt;\u0026gt;\u0026gt; my_list [\u0026#39;h\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;o\u0026#39;] \u0026gt;\u0026gt;\u0026gt; my_list.append(\u0026#34;!\u0026#34;) \u0026gt;\u0026gt;\u0026gt; my_list [\u0026#39;h\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;!\u0026#39;] \u0026gt;\u0026gt;\u0026gt; len(my_list) 6 \u0026gt;\u0026gt;\u0026gt; my_list[4:6] [\u0026#39;o\u0026#39;, \u0026#39;!\u0026#39;] \u0026gt;\u0026gt;\u0026gt; my_list[4:] [\u0026#39;o\u0026#39;, \u0026#39;!\u0026#39;] \u0026gt;\u0026gt;\u0026gt; my_list[-2:] [\u0026#39;o\u0026#39;, \u0026#39;!\u0026#39;] \u0026gt;\u0026gt;\u0026gt; my_list.remove(\u0026#34;l\u0026#34;) \u0026gt;\u0026gt;\u0026gt; my_list.insert(2, \u0026#34;l\u0026#34;) \u0026gt;\u0026gt;\u0026gt; del my_list[0] \u0026gt;\u0026gt;\u0026gt; last_item = my_list.pop() \u0026gt;\u0026gt;\u0026gt; last_item \u0026#39;o\u0026#39; \u0026gt;\u0026gt;\u0026gt; my_list[2] \u0026#39;l\u0026#39; \u0026gt;\u0026gt;\u0026gt; \u0026#34;!\u0026#34; in my_list False \u0026gt;\u0026gt;\u0026gt; my_list.sort(reverse=True) \u0026gt;\u0026gt;\u0026gt; my_list [\u0026#39;o\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;h\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;!\u0026#39;] \u0026gt;\u0026gt;\u0026gt; sorted(my_list, reverse=False) [\u0026#39;!\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;h\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;o\u0026#39;] Sets Sets are a great data type for storing unique data - you can only have one of any given object in a set. Sets are unordered, thus you can\u0026rsquo;t access them with [] indexing syntax, but they do have some handy functions.\nLet\u0026rsquo;s play with some set operations:\n# Create an empty set \u0026gt;\u0026gt;\u0026gt; my_set = {} \u0026gt;\u0026gt;\u0026gt; type(my_set) # Gotcha: using {} actually creates an empty dictionary. To create an empty set, use set() \u0026gt;\u0026gt;\u0026gt; my_set = set() \u0026gt;\u0026gt;\u0026gt; my_set # Let\u0026#39;s create a non-empty set \u0026gt;\u0026gt;\u0026gt; my_set = {1, 2, 3} # We can add and remove items from the set \u0026gt;\u0026gt;\u0026gt; my_set.add(4) \u0026gt;\u0026gt;\u0026gt; my_set.remove(2) # We can test if an item exists in the set \u0026gt;\u0026gt;\u0026gt; 2 in my_set # Unlike lists, every item in a set must be unique \u0026gt;\u0026gt;\u0026gt; my_set \u0026gt;\u0026gt;\u0026gt; my_set.add(3) \u0026gt;\u0026gt;\u0026gt; my_set # There is still only one 3 in the set \u0026gt;\u0026gt;\u0026gt; my_set # my_set should equal {1, 3, 4} \u0026gt;\u0026gt;\u0026gt; my_other_set = {1, 2, 3} # We can combine two sets \u0026gt;\u0026gt;\u0026gt; my_set.union(my_other_set) # We can get the intersection of two sets \u0026gt;\u0026gt;\u0026gt; my_set.intersection(my_other_set) # We can get the difference of two sets \u0026gt;\u0026gt;\u0026gt; my_set.difference(my_other_set) Here\u0026#39;s what you should have seen in your REPL: \u0026gt;\u0026gt;\u0026gt; my_set = {} \u0026gt;\u0026gt;\u0026gt; type(my_set) \u0026lt;class \u0026#39;dict\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt; my_set = set() \u0026gt;\u0026gt;\u0026gt; type(my_set) \u0026lt;class \u0026#39;set\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt; my_set = {1, 2, 3} \u0026gt;\u0026gt;\u0026gt; my_set.add(4) \u0026gt;\u0026gt;\u0026gt; my_set.remove(2) \u0026gt;\u0026gt;\u0026gt; 2 in my_set False \u0026gt;\u0026gt;\u0026gt; my_set {1, 3, 4} \u0026gt;\u0026gt;\u0026gt; my_set.add(3) \u0026gt;\u0026gt;\u0026gt; my_set {1, 3, 4} \u0026gt;\u0026gt;\u0026gt; my_other_set = {1, 2, 3} \u0026gt;\u0026gt;\u0026gt; my_set.union(my_other_set) {1, 2, 3, 4} \u0026gt;\u0026gt;\u0026gt; my_set.intersection(my_other_set) {1, 3} \u0026gt;\u0026gt;\u0026gt; my_set.difference(my_other_set) {4} Tuples Tuples are a lightweight way to hold information that describes something, like a person - their name, age, and hometown. You can think about it kind of like a row in a spreadsheet. Tuples are represented inside parentheses, however parentheses are not required to create a tuple, just a sequence of objects followed by commas.\n\u0026gt;\u0026gt;\u0026gt; my_tuple = 1, \u0026gt;\u0026gt;\u0026gt; my_tuple # Let\u0026#39;s add to our tuple \u0026gt;\u0026gt;\u0026gt; my_tuple[1] = 2 Oops! Remember that tuples are immutable, so you can\u0026rsquo;t change them once they\u0026rsquo;ve been created. Tuples are great for moving data around in a lightweight way, because you can unpack them easily into multiple variables.\n\u0026gt;\u0026gt;\u0026gt; person = (\u0026#39;Jim\u0026#39;, 29, \u0026#39;Austin, TX\u0026#39;) \u0026gt;\u0026gt;\u0026gt; name, age, hometown = person \u0026gt;\u0026gt;\u0026gt; name \u0026gt;\u0026gt;\u0026gt; age \u0026gt;\u0026gt;\u0026gt; hometown Here\u0026#39;s what you should have seen in your REPL: \u0026gt;\u0026gt;\u0026gt; my_tuple = 1, \u0026gt;\u0026gt;\u0026gt; my_tuple (1,) \u0026gt;\u0026gt;\u0026gt; my_tuple[1] = 2 Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; TypeError: \u0026#39;tuple\u0026#39; object does not support item assignment \u0026gt;\u0026gt;\u0026gt; person = (\u0026#39;Jim\u0026#39;, 29, \u0026#39;Austin, TX\u0026#39;) \u0026gt;\u0026gt;\u0026gt; name, age, hometown = person \u0026gt;\u0026gt;\u0026gt; name \u0026#39;Jim\u0026#39; \u0026gt;\u0026gt;\u0026gt; age 29 \u0026gt;\u0026gt;\u0026gt; hometown \u0026#39;Austin, TX\u0026#39; Dictionaries Dictionaries are great for storing data that you can index with keys. The keys must be unique, and the dictionaries are stored in the order you inserted items, however this is only guaranteed as of Python 3.7.\n\u0026gt;\u0026gt;\u0026gt; my_dict = {\u0026#34;key\u0026#34;: \u0026#34;value\u0026#34;} # Remember, dictionaries don\u0026#39;t have numerical indexes like lists, so if you try to use an index number... # Unless 0 happens to be a key. \u0026gt;\u0026gt;\u0026gt; my_dict[0] # You\u0026#39;ll get a KeyError! # Let\u0026#39;s put some more things into our dictionary \u0026gt;\u0026gt;\u0026gt; my_dict[\u0026#34;hello\u0026#34;] = \u0026#34;world\u0026#34; \u0026gt;\u0026gt;\u0026gt; my_dict[\u0026#34;foo\u0026#34;] = \u0026#34;bar\u0026#34; \u0026gt;\u0026gt;\u0026gt; my_dict # What was the value for \u0026#34;hello\u0026#34; again? \u0026gt;\u0026gt;\u0026gt; my_dict[\u0026#34;hello\u0026#34;] # You can also use get() to get a key \u0026gt;\u0026gt;\u0026gt; my_dict.get(\u0026#34;hello\u0026#34;) # What if the key you want doesn\u0026#39;t exist? \u0026gt;\u0026gt;\u0026gt; my_dict[\u0026#34;baz\u0026#34;] # If you\u0026#39;re not sure if a key exists, you can ask: \u0026gt;\u0026gt;\u0026gt; \u0026#34;baz\u0026#34; in my_dict # Or you can use a default value. If \u0026#34;baz\u0026#34; doesn\u0026#39;t exist, return \u0026#34;boo\u0026#34;: \u0026gt;\u0026gt;\u0026gt; my_dict.get(\u0026#34;baz\u0026#34;, \u0026#34;boo\u0026#34;) # Let\u0026#39;s try separating the dictionary into lists of keys and values: \u0026gt;\u0026gt;\u0026gt; my_dict.keys() \u0026gt;\u0026gt;\u0026gt; my_dict.values() # What if we want to iterate over a dictionary\u0026#39;s items? We can use the items() function to get a list of tuples: \u0026gt;\u0026gt;\u0026gt; my_dict.items() Here\u0026#39;s what you should have seen in your REPL: \u0026gt;\u0026gt;\u0026gt; my_dict = {\u0026#34;key\u0026#34;: \u0026#34;value\u0026#34;} \u0026gt;\u0026gt;\u0026gt; my_dict[0] Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; KeyError: 0 \u0026gt;\u0026gt;\u0026gt; my_dict[\u0026#34;hello\u0026#34;] = \u0026#34;world\u0026#34; \u0026gt;\u0026gt;\u0026gt; my_dict[\u0026#34;foo\u0026#34;] = \u0026#34;bar\u0026#34; \u0026gt;\u0026gt;\u0026gt; my_dict {\u0026#39;foo\u0026#39;: \u0026#39;bar\u0026#39;, \u0026#39;hello\u0026#39;: \u0026#39;world\u0026#39;, \u0026#39;key\u0026#39;: \u0026#39;value\u0026#39;} \u0026gt;\u0026gt;\u0026gt; my_dict[\u0026#34;hello\u0026#34;] \u0026#39;world\u0026#39; \u0026gt;\u0026gt;\u0026gt; my_dict.get(\u0026#34;hello\u0026#34;) \u0026#39;world\u0026#39; \u0026gt;\u0026gt;\u0026gt; my_dict[\u0026#34;baz\u0026#34;] Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; KeyError: \u0026#39;baz\u0026#39; \u0026gt;\u0026gt;\u0026gt; \u0026#34;baz\u0026#34; in my_dict False \u0026gt;\u0026gt;\u0026gt; my_dict.get(\u0026#34;baz\u0026#34;, \u0026#34;default response\u0026#34;) \u0026#39;default response\u0026#39; \u0026gt;\u0026gt;\u0026gt; my_dict.keys() [\u0026#39;foo\u0026#39;, \u0026#39;hello\u0026#39;, \u0026#39;key\u0026#39;] \u0026gt;\u0026gt;\u0026gt; my_dict.values() [\u0026#39;bar\u0026#39;, \u0026#39;world\u0026#39;, \u0026#39;value\u0026#39;] \u0026gt;\u0026gt;\u0026gt; my_dict.items() [(\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;), (\u0026#39;hello\u0026#39;, \u0026#39;world\u0026#39;), (\u0026#39;key\u0026#39;, \u0026#39;value\u0026#39;)] Mutability Remember, in Python, some data types are immutable \u0026ndash; that means that once they\u0026rsquo;re created, their contents can\u0026rsquo;t be changed. Tuples are immutable - once you make one, you can\u0026rsquo;t alter it, you can only make a new one. Conversely, lists, dictionaries, and sets are mutable - you can change them without making new ones.\nLet\u0026rsquo;s see this in practice:\n# Lists are mutable \u0026gt;\u0026gt;\u0026gt; my_list = [1, 2, 3] \u0026gt;\u0026gt;\u0026gt; my_list[0] = \u0026#39;a\u0026#39; \u0026gt;\u0026gt;\u0026gt; my_list # Dictionaries are also mutable \u0026gt;\u0026gt;\u0026gt; my_dict = {\u0026#34;hello\u0026#34;: \u0026#34;world\u0026#34;} \u0026gt;\u0026gt;\u0026gt; my_dict[\u0026#34;foo\u0026#34;] = \u0026#34;bar\u0026#34; \u0026gt;\u0026gt;\u0026gt; my_dict # Sets are mutable, but don\u0026#39;t support indexing or item assignment, so you have to use add() and remove() \u0026gt;\u0026gt;\u0026gt; my_set = {1, 2, 3} \u0026gt;\u0026gt;\u0026gt; my_set[0] = \u0026#39;a\u0026#39; # This will throw a TypeError \u0026gt;\u0026gt;\u0026gt; my_set.add(\u0026#39;a\u0026#39;) \u0026gt;\u0026gt;\u0026gt; my_set # Tuples are immutable \u0026gt;\u0026gt;\u0026gt; my_tuple = (1, 2, 3) \u0026gt;\u0026gt;\u0026gt; my_tuple[0] = \u0026#39;a\u0026#39; # This will throw a TypeError Here\u0026#39;s what you should have seen in your REPL: \u0026gt;\u0026gt;\u0026gt; my_list = [1, 2, 3] \u0026gt;\u0026gt;\u0026gt; my_list[0] = \u0026#39;a\u0026#39; \u0026gt;\u0026gt;\u0026gt; my_list [\u0026#39;a\u0026#39;, 2, 3] \u0026gt;\u0026gt;\u0026gt; my_dict = {\u0026#34;hello\u0026#34;: \u0026#34;world\u0026#34;} \u0026gt;\u0026gt;\u0026gt; my_dict[\u0026#34;foo\u0026#34;] = \u0026#34;bar\u0026#34; \u0026gt;\u0026gt;\u0026gt; my_dict {\u0026#39;hello\u0026#39;: \u0026#39;world\u0026#39;, \u0026#39;foo\u0026#39;: \u0026#39;bar\u0026#39;} \u0026gt;\u0026gt;\u0026gt; my_set = {1, 2, 3} \u0026gt;\u0026gt;\u0026gt; my_set[0] = \u0026#39;a\u0026#39; Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; TypeError: \u0026#39;set\u0026#39; object does not support item assignment \u0026gt;\u0026gt;\u0026gt; my_set.add(\u0026#39;a\u0026#39;) \u0026gt;\u0026gt;\u0026gt; my_set {1, 2, 3, \u0026#39;a\u0026#39;} \u0026gt;\u0026gt;\u0026gt; my_tuple = (1, 2, 3) \u0026gt;\u0026gt;\u0026gt; my_tuple[0] = \u0026#39;a\u0026#39; Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; TypeError: \u0026#39;tuple\u0026#39; object does not support item assignment "
},
{
	"uri": "https://pythonianrocketship.github.io/en/03-intermediate-python/80-web-frameworks/",
	"title": "Web Frameworks",
	"tags": [],
	"description": "",
	"content": "Chapter 8 Web Frameworks In this final chapter, we\u0026rsquo;ll learn about web frameworks, and practice all our new Python knowledge by building a basic web application with unit tests using Python and the flask framework.\n"
},
{
	"uri": "https://pythonianrocketship.github.io/en/02-introduction-to-python/080-advanced-datatypes/",
	"title": "Advanced Container Types",
	"tags": [],
	"description": "",
	"content": "Chapter 4 Advanced Data Types - Containers and sequences Now that we\u0026rsquo;ve got the basics of strings and numbers down, let\u0026rsquo;s talk about the advanced data types - list, tuple, dict and set. These are container objects that let us organize other types of objects into one data structure.\n"
},
{
	"uri": "https://pythonianrocketship.github.io/en/02-introduction-to-python/090-boolean-logic/",
	"title": "Boolean Logic",
	"tags": [],
	"description": "",
	"content": "Chapter 5 Boolean Logic Boolean Logic allows you to test your assumptions.\n"
},
{
	"uri": "https://pythonianrocketship.github.io/en/02-introduction-to-python/110-control-statements-looping/",
	"title": "Loops and Control Statements",
	"tags": [],
	"description": "",
	"content": "Chapter 6 Loops and Control Statements Loops and control statements allow us to control the logical flow of our program.\n"
},
{
	"uri": "https://pythonianrocketship.github.io/en/02-introduction-to-python/175-running-code/",
	"title": "Working With Python Programs",
	"tags": [],
	"description": "",
	"content": "Chapter 7 Working With Python Programs The REPL is an incredibly useful tool to quickly learn new Python concepts and test your assumptions. Unfortunately, it\u0026rsquo;s not a great way to save or share our code. Let\u0026rsquo;s learn how to save our Python code into project files, so we can run it again and again.\n"
},
{
	"uri": "https://pythonianrocketship.github.io/en/02-introduction-to-python/190-apis/",
	"title": "APIs",
	"tags": [],
	"description": "",
	"content": "Chapter 8 Working with APIs How do we interact with APIs from Python?\n"
},
{
	"uri": "https://pythonianrocketship.github.io/en/02-introduction-to-python/190-apis/final-exercise/",
	"title": "Practice",
	"tags": [],
	"description": "",
	"content": "Let\u0026rsquo;s review what we learned today and put it all together.\nFor the final exercise of today, we\u0026rsquo;re going to write a small program that requests the top repositories from GitHub, ordered by the number of stars each repository has, then we\u0026rsquo;re going to print the results to our terminal. Create a new file called day_one.py.\nYou may need to install the requests library using python -m pip install requests. You may see pip used directly, but using python -m pip is recommended by Python.\nLet\u0026rsquo;s start with our key function, the one that gets the data from the GitHub API. Use the requests library to do a GET request on the GitHub search API URL (\u0026ldquo;https://api.github.com/search/repositories\"). Use if __name__ == \u0026quot;__main__\u0026quot; to check to make sure we\u0026rsquo;re running the file directly, and to call our function. Don\u0026rsquo;t forget to import requests\nYou should have something like this: import requests def repos_with_most_stars(): gh_api_repo_search_url = \u0026#34;https://api.github.com/search/repositories\u0026#34; response = requests.get(gh_api_repo_search_url) print(response.text) if __name__ == \u0026#34;__main__\u0026#34;: repos_with_most_stars() Here\u0026#39;s what you should have seen on your command line: (env) $ python day_one.py {\u0026#34;message\u0026#34;:\u0026#34;Validation Failed\u0026#34;,\u0026#34;errors\u0026#34;:[{\u0026#34;resource\u0026#34;:\u0026#34;Search\u0026#34;,\u0026#34;field\u0026#34;:\u0026#34;q\u0026#34;,\u0026#34;code\u0026#34;:\u0026#34;missing\u0026#34;}],\u0026#34;documentation_url\u0026#34;:\u0026#34;https://developer.github.com/v3/search\u0026#34;} Getting a Response Looks like we got a response from the GitHub API! Looks like we hit an error - we\u0026rsquo;re missing search parameter. Checking the documentation_url that GitHub helpfully provides, we can see that we\u0026rsquo;re missing the parameter q, which contains search keywords. Let\u0026rsquo;s hardcode a query string to find repos with more than 50,000 stars and try again. We\u0026rsquo;ll add our query string to the parameters dict as q, and pass it to the params argument of requests.get()\nYou should have something like this: import requests def repos_with_most_stars(): gh_api_repo_search_url = \u0026#34;https://api.github.com/search/repositories\u0026#34; parameters = {\u0026#34;q\u0026#34;: \u0026#34;stars:\u0026gt;50000\u0026#34;} response = requests.get(gh_api_repo_search_url, params=parameters) print(response.text) if __name__ == \u0026#34;__main__\u0026#34;: repos_with_most_stars() Here\u0026#39;s what you should have seen on your command line: (env) $ python day_one.py {\u0026#34;total_count\u0026#34;:33,\u0026#34;incomplete_results\u0026#34;:false,\u0026#34;items\u0026#34;:[{\u0026#34;id\u0026#34;:28457823,\u0026#34;node_id\u0026#34;:\u0026#34;MDEwOlJlcG9zaXRvcnkyODQ1NzgyMw==\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;freeCodeCamp\u0026#34;... Response Parsing Woah, we got a huge response from GitHub, including metadata for 33 repos. Let\u0026rsquo;s parse it out so we can make better sense of what we have - use response.json() to get the returned data in json format. We see that GitHub returns a list called items in our response, so let\u0026rsquo;s return that. Then, in your main function, loop through it and print out the important bits.\nYou should have something like this: import requests def repos_with_most_stars(): gh_api_repo_search_url = \u0026#34;https://api.github.com/search/repositories\u0026#34; parameters = {\u0026#34;q\u0026#34;: \u0026#34;stars:\u0026gt;50000\u0026#34;} response = requests.get(gh_api_repo_search_url, params=parameters) response_json = response.json() return response_json[\u0026#34;items\u0026#34;] if __name__ == \u0026#34;__main__\u0026#34;: results = repos_with_most_stars() for result in results: language = result[\u0026#34;language\u0026#34;] stars = result[\u0026#34;stargazers_count\u0026#34;] name = result[\u0026#34;name\u0026#34;] print(f\u0026#34;-\u0026gt; {name} is a {language} repo with {stars} stars.\u0026#34;) Here\u0026#39;s what you should have seen on your command line: (env) $ python day_one.py -\u0026gt; freeCodeCamp is a JavaScript repo with 298059 stars. -\u0026gt; bootstrap is a JavaScript repo with 131410 stars. -\u0026gt; vue is a JavaScript repo with 130168 stars. -\u0026gt; react is a JavaScript repo with 124029 stars. -\u0026gt; tensorflow is a C++ repo with 122328 stars. -\u0026gt; free-programming-books is a None repo with 118241 stars. -\u0026gt; awesome is a None repo with 103392 stars. -\u0026gt; You-Dont-Know-JS is a None repo with 97587 stars. ... Narrowing it Down We should now have a much more readable list of 33 or so repos, along with their number of stars. Let\u0026rsquo;s narrow down our search a bit. To use multiple search keywords, we\u0026rsquo;ll have to programatically construct our query string. Using the GitHub API documentation, let\u0026rsquo;s make a new function to construct a query string for the repository search endpoint that searches for any number of languages, and limits our query to repos with more than 50,000 stars:\nYou should have something like this: def create_query(languages, min_stars=50000): # An example search query looks like: # stars:\u0026gt;50000 language:python language:javascript query = f\u0026#34;stars:\u0026gt;{min_stars} \u0026#34; for language in languages: query += f\u0026#34;language:{language} \u0026#34; return query Now, let\u0026rsquo;s call our new create_query() function from repos_with_most_stars(), replacing our hardcoded query string. Add a languages argument so that we can pass in a list of languages to use to create our query. Also add sort and order parameters, which we\u0026rsquo;ll hardcode to \u0026ldquo;stars\u0026rdquo; and \u0026ldquo;desc\u0026rdquo; for now.\nYou should have something like this: def repos_with_most_stars(languages): gh_api_repo_search_url = \u0026#34;https://api.github.com/search/repositories\u0026#34; query = create_query(languages) sort = \u0026#34;stars\u0026#34; order = \u0026#34;desc\u0026#34; parameters = {\u0026#34;q\u0026#34;: query, \u0026#34;sort\u0026#34;: sort, \u0026#34;order\u0026#34;: order} response = requests.get(gh_api_repo_search_url, params=parameters) response_json = response.json() return response_json[\u0026#34;items\u0026#34;] Finally, let\u0026rsquo;s add a languages list to limit which languages we\u0026rsquo;re interested in, and pass it to repos_with_most_stars(). Now, when we call our repos_with_most_stars() function with [\u0026quot;python\u0026quot;, \u0026quot;javascript\u0026quot;, \u0026quot;ruby\u0026quot;] as our languages, the create_query() function will output create a query string that looks like q=stars:\u0026gt;50000+language:python+language:javascript+language:ruby+\u0026amp;sort=stars\u0026amp;order=desc. Because this is a simple GET request, this gets appended to our gh_api_repo_search_url, so our actual request URL is https://api.github.com/search/repositories?q=stars:\u0026gt;50000+language:python+language:javascript+language:ruby+\u0026amp;sort=stars\u0026amp;order=desc.\nRun your program.\nYou should have something like this: if __name__ == \u0026#34;__main__\u0026#34;: languages = [\u0026#34;python\u0026#34;, \u0026#34;javascript\u0026#34;, \u0026#34;ruby\u0026#34;] results = repos_with_most_stars(languages) for result in results: language = result[\u0026#34;language\u0026#34;] stars = result[\u0026#34;stargazers_count\u0026#34;] name = result[\u0026#34;name\u0026#34;] print(f\u0026#34;-\u0026gt; {name} is a {language} repo with {stars} stars.\u0026#34;) Here\u0026#39;s what you should have seen on your command line: (env) $ python day_one.py -\u0026gt; freeCodeCamp is a JavaScript repo with 298059 stars. -\u0026gt; bootstrap is a JavaScript repo with 131410 stars. -\u0026gt; vue is a JavaScript repo with 130169 stars. -\u0026gt; react is a JavaScript repo with 124029 stars. -\u0026gt; d3 is a JavaScript repo with 82945 stars. -\u0026gt; javascript is a JavaScript repo with 82531 stars. -\u0026gt; react-native is a JavaScript repo with 74828 stars. -\u0026gt; create-react-app is a JavaScript repo with 64748 stars. -\u0026gt; awesome-python is a Python repo with 63734 stars. -\u0026gt; angular.js is a JavaScript repo with 59413 stars. -\u0026gt; Font-Awesome is a JavaScript repo with 59051 stars. -\u0026gt; system-design-primer is a Python repo with 58972 stars. -\u0026gt; node is a JavaScript repo with 58863 stars. -\u0026gt; axios is a JavaScript repo with 56121 stars. -\u0026gt; public-apis is a Python repo with 53212 stars. -\u0026gt; jquery is a JavaScript repo with 51040 stars. Cleaning Up and Handling Errors Looking good, we now have a sorted list of the top python, javascript, and ruby repos. Let\u0026rsquo;s do a little bit of clean up and error handling. We might not always want to sort by \u0026ldquo;stars\u0026rdquo; or order by \u0026ldquo;desc\u0026rdquo;, so move those to keyword arguments. That way, they\u0026rsquo;ll be good defaults, but if someone calling our repos_with_most_stars function wants to override them, they can.\nYou should have something like this: def repos_with_most_stars(languages, sort=\u0026#34;stars\u0026#34;, order=\u0026#34;desc\u0026#34;): gh_api_repo_search_url = \u0026#34;https://api.github.com/search/repositories\u0026#34; query = create_query(languages) parameters = {\u0026#34;q\u0026#34;: query, \u0026#34;sort\u0026#34;: sort, \u0026#34;order\u0026#34;: order} response = requests.get(gh_api_repo_search_url, params=parameters) response_json = response.json() return response_json[\u0026#34;items\u0026#34;] Next, we should handle any errors we might run into with the API. Maybe you\u0026rsquo;ve gotten one already. Let\u0026rsquo;s add some basic error handling on the response\u0026rsquo;s HTTP status code. We\u0026rsquo;ll check for a 403, a common error that GitHub uses to tell you that you\u0026rsquo;re hitting their API too quickly, and raise and error. We\u0026rsquo;ll also raise an error if the status code is anything but 200 (success).\nYou should have something like this: def repos_with_most_stars(languages, sort=\u0026#34;stars\u0026#34;, order=\u0026#34;desc\u0026#34;): gh_api_repo_search_url = \u0026#34;https://api.github.com/search/repositories\u0026#34; query = create_query(languages) # Define the parameters we want to be part of our URL parameters = {\u0026#34;q\u0026#34;: query, \u0026#34;sort\u0026#34;: sort, \u0026#34;order\u0026#34;: order} # Pass in the query and the parameters as part of the request. response = requests.get(\u0026#34;https://api.github.com/search/repositories\u0026#34;, params=parameters) status_code = response.status_code # Check if the rate limit was hit. Applies only for students running this code # in the in-person course. if status_code == 403: raise RuntimeError(\u0026#34;Rate limit reached. Please wait a minute and try again.\u0026#34;) if status_code != 200: raise RuntimeError(f\u0026#34;An error occurred. HTTP Status Code was: {status_code}.\u0026#34;) else: response_json = response.json() records = response_json[\u0026#34;items\u0026#34;] return records There, your code should do the same thing, but should handle errors much better.\nThe final code, with additional comments, can be found here: \u0026#34;\u0026#34;\u0026#34; A small Python program that uses the GitHub search API to list the top projects by language, based on stars. GitHub Search API documentation: https://developer.github.com/v3/search/ Additional parameters for searching repos can be found here: https://help.github.com/en/articles/searching-for-repositories#search-by-number-of-stars Note: The API will return results found before a timeout occurs, so results may not be the same across requests, even with the same query. Requests to this endpoint are rate limited to 10 requests per minute per IP address. \u0026#34;\u0026#34;\u0026#34; import requests def create_query(languages, min_stars=50000): \u0026#34;\u0026#34;\u0026#34; Create the query string for the GitHub search API, based on the minimum amount of stars for a project, and the provided programming languages. An example search query looks like: stars:\u0026gt;50000 language:python language:javascript \u0026#34;\u0026#34;\u0026#34; query = f\u0026#34;stars:\u0026gt;{min_stars} \u0026#34; for language in languages: query += f\u0026#34;language:{language} \u0026#34; return query def repos_with_most_stars(languages, sort=\u0026#34;stars\u0026#34;, order=\u0026#34;desc\u0026#34;): gh_api_repo_search_url = \u0026#34;https://api.github.com/search/repositories\u0026#34; query = create_query(languages) # Define the parameters we want to be part of our URL parameters = {\u0026#34;q\u0026#34;: query, \u0026#34;sort\u0026#34;: sort, \u0026#34;order\u0026#34;: order} # Pass in the query and the parameters as part of the request. response = requests.get(gh_api_repo_search_url, params=parameters) status_code = response.status_code # Check if the rate limit was hit. Applies only for students running this code # in the in-person course. if status_code == 403: raise RuntimeError(\u0026#34;Rate limit reached. Please wait a minute and try again.\u0026#34;) if status_code != 200: raise RuntimeError(f\u0026#34;An error occurred. HTTP Status Code was: {status_code}.\u0026#34;) else: response_json = response.json() records = response_json[\u0026#34;items\u0026#34;] return records if __name__ == \u0026#34;__main__\u0026#34;: languages = [\u0026#34;python\u0026#34;, \u0026#34;javascript\u0026#34;, \u0026#34;ruby\u0026#34;] results = repos_with_most_stars(languages) for result in results: language = result[\u0026#34;language\u0026#34;] stars = result[\u0026#34;stargazers_count\u0026#34;] name = result[\u0026#34;name\u0026#34;] print(f\u0026#34;-\u0026gt; {name} is a {language} repo with {stars} stars.\u0026#34;) "
},
{
	"uri": "https://pythonianrocketship.github.io/en/03-intermediate-python/60-command-line-tools/90-exercise/",
	"title": "Practice",
	"tags": [],
	"description": "",
	"content": "Accepting User Input with Args To accept basic arguments from the command line, we can use sys.argv. Start a new Python file called cli_exercise.py and enter the following.\nimport sys args = sys.argv print(args) Then, run it from the command line:\n(env) $ python cli_exercise.py Here\u0026#39;s what you should have seen on your command line: (env) $ python cli_exercise.py [\u0026#39;cli_exercise.py\u0026#39;] You should see a list with one item: the name of your program. Pass in additional arguments by adding them after your program name on the command line, separated by spaces:\n(env) $ python cli_exercise.py argument1 argument2 \u0026#34;hello world\u0026#34; Here\u0026#39;s what you should have seen on your command line: (env) $ python cli_exercise.py argument1 argument2 \u0026#34;hello world\u0026#34; [\u0026#39;cli_exercise.py\u0026#39;, \u0026#39;argument1\u0026#39;, \u0026#39;argument2\u0026#39;, \u0026#39;hello world\u0026#39;] Note that the name of the file you\u0026rsquo;re running is rarely useful, so it\u0026rsquo;s common to see this omitted with using slices, for example sys.argv[1:]\nAccepting User Input with input You can also accept user data inside a running program by using input(). Let\u0026rsquo;s make a simple interactive command line program that asks for a user\u0026rsquo;s name and birthday. Call it cli_exercise_input.py. Use input() to get the user\u0026rsquo;s name and birthday, and greet the user (call strip() on their name to remove any extra whitespace).\nYou should have written something like this: name = input(\u0026#34;Hello, what is your name? \u0026#34;) birthday_string = input(f\u0026#34;Hello {name.strip()}. Please enter your birthday in MM/DD/YYYY format: \u0026#34;) print(f\u0026#34;Hello {name}. Your birthday is on {birthday_string}.\u0026#34;) Here\u0026#39;s what you should have seen on your command line: (env) $ python cli_exercise_input.py Hello, what is your name? Floyd Hello Nina. Please enter your birthday in MM/DD/YYYY format: 01/20/1990 Hello Floyd. Your birthday is on 01/20/1990. Optional Advanced Exercise If you thought this exercise was a breeze, try this optional advanced exercises.\nRefactor the final exercise from Intro to Python, using custom exceptions and a class to store the information about a GitHub Repo. Accept the list of languages as user input.\nYou can see an example implementation in the repo for this course at git.io/python3\n"
},
{
	"uri": "https://pythonianrocketship.github.io/en/03-intermediate-python/80-web-frameworks/final-exercise/",
	"title": "Practice",
	"tags": [],
	"description": "",
	"content": "Installing Requirements Our web application has two required external libraries, flask, and requests. As our list of dependencies becomes more complicated, we want to list them in a file called requirements.txt and include it with our project. That way, our code can be reused by others.\nOpen and look at the requirements.txt file. The name of each dependency is on a new line.\nAs you advance in your Python journey, you can use the more advanced pipenv tool to handle complicated dependencies.\nTo install all the dependencies from our requirements file, pass the -r flag to pip, and the name of the file (in this case, it\u0026rsquo;s requirements.txt):\n(env)$ python -m pip install -r requirements.txt Review Let\u0026rsquo;s review what we learned over the last two days and put it all together.\nFor our final exercise today, we\u0026rsquo;re going to build on yesterday\u0026rsquo;s final exercise, where we wrote a program to query the GitHub API for a list of repos for certain programming languages, sorted by number of stars. We\u0026rsquo;ll be turning yesterday\u0026rsquo;s exercise into a Flask webapp. Flask is a simple and popular framework for creating basic web apps in Python.\nFirst, create a new folder for this exercise, called day_two_final. You\u0026rsquo;ll need two folders of static content - CSS and HTML files - to make this work. You can download them here. Unzip your static_files.zip file and copy your static and template folders to your day_two_final folder.\nNext, create a folder called repos. This is where we\u0026rsquo;ll create our custom module. Inside this folder we\u0026rsquo;ll create three files: exceptions.py, models.py, and api.py.\nIn exceptions.py, we\u0026rsquo;ll create a custom exception class to handle errors with the GitHub API. In models.py, we\u0026rsquo;ll create a GitHubRepo class to more easily represent the results from the GitHub API search. And api.py will hold our functions for querying the GitHub API.\nFinally, we\u0026rsquo;ll add an app.py file in the root level, to run our Flask app. Your folder should look like this:\nday_two_final ├── app.py ├── repos │ ├── exceptions.py │ ├── models.py │ └── api.py ├── static │ ├── favicon.png │ └── style.css └── templates ├── error.html └── index.html exceptions.py Let\u0026rsquo;s start with building a custom exception to handle API errors. Remember that is response.status_code is anything but 200, you can consider that an error. Create a GitHubApiException class that subclasses Exception. Have it accept a status_code argument, and use that to create a custom message (you can copy the error strings we used yesterday). Pass the message to Exception\nYou should have something like this: class GitHubApiException(Exception): def __init__(self, status_code): if status_code == 403: message = \u0026#34;Rate limit reached. Please wait a minute and try again.\u0026#34; else: message = f\u0026#34;HTTP Status Code was: {status_code}.\u0026#34; super().__init__(\u0026#34;A GitHub API Error Occurred: \u0026#34; + message) models.py Next, let\u0026rsquo;s build our \u0026ldquo;model\u0026rdquo;, the GitHubRepo class. For this, we want to accept three arguments (name, language, and num_stars) and store them as instance variables (using self). To have a user-friend way to print our repo information, add a __str__() method that prints a message with the three repo parameters. For completeness, see if you can add a __repr__() method that returns the Python code needed to recreate this object.\nYou should have something like this: class GitHubRepo: def __init__(self, name, language, num_stars): self.name = name self.language = language self.num_stars = num_stars def __str__(self): return f\u0026#34;-\u0026gt; {self.name} is a {self.language} repo with {self.num_stars} stars.\u0026#34; def __repr__(self): return f\u0026#39;GitHubRepo({self.name}, {self.language}, {self.num_stars})\u0026#39; api.py In our api.py file, we\u0026rsquo;re going to copy in our create_query() function and the repos_with_most_stars() function from yesterday.\nIn create_query(), see if you can clean up the code a little by replacing the for loop with a string join that accepts a list comprehension.\nClean up your repos_with_most_stars() function by using raise to throw your GitHubAPIException if the status_code does not equal 200. Then, instead of returning items directly from the response json, see if you can use a list comprehension to create and return a list of GitHubRepo objects.\nDon\u0026rsquo;t forget to import your GitHubApiException, your GitHubRepo class, and the requests module.\nYou should have something like this: from repos.exceptions import GitHubApiException from repos.models import GitHubRepo import requests GITHUB_API_URL = \u0026#34;https://api.github.com/search/repositories\u0026#34; def create_query(languages, min_stars): \u0026#34;\u0026#34;\u0026#34; Create the query string for the GitHub search API, based on the minimum amount of stars for a project, and the provided programming languages. \u0026#34;\u0026#34;\u0026#34; # Notice we are calling .strip() on each language, to clear it of leading # and trailing whitespace query = \u0026#34; \u0026#34;.join(f\u0026#34;language:{language.strip()}\u0026#34; for language in languages) query = query + f\u0026#34; stars:\u0026gt;{min_stars}\u0026#34; return query def repos_with_most_stars(languages, min_stars=40000, sort=\u0026#34;stars\u0026#34;, order=\u0026#34;desc\u0026#34;): query = create_query(languages, min_stars) parameters = {\u0026#34;q\u0026#34;: query, \u0026#34;sort\u0026#34;: sort, \u0026#34;order\u0026#34;: order} print(parameters) response = requests.get(GITHUB_API_URL, params=parameters) if response.status_code != 200: raise GitHubApiException(response.status_code) response_json = response.json() items = response_json[\u0026#34;items\u0026#34;] return [GitHubRepo(item[\u0026#34;name\u0026#34;], item[\u0026#34;language\u0026#34;], item[\u0026#34;stargazers_count\u0026#34;]) for item in items] app.py Finally, let\u0026rsquo;s tie it all together with our app.py file. We\u0026rsquo;ll start off with some boilerplate - we\u0026rsquo;ll need to import a few things from flask, as well as our GitHubApiException and our repos_with_most_stars() function:\nfrom flask import Flask, render_template, request from repos.exceptions import GitHubApiException from repos.api import repos_with_most_stars Next, we\u0026rsquo;ll create the flask app object. We\u0026rsquo;ll also create a list of all the available languages that the user of our web app can choose from. It will help us keep track of if they\u0026rsquo;re selected or not.\napp = Flask(__name__) available_languages = [\u0026#34;Python\u0026#34;, \u0026#34;JavaScript\u0026#34;, \u0026#34;Ruby\u0026#34;, \u0026#34;Java\u0026#34;] Next, we\u0026rsquo;ll need a function that gets called when the root url for our website, or / is requested by the user\n. We\u0026rsquo;ll start with the @app.route() decorator - we didn\u0026rsquo;t cover decorators in this class, but just know that this signals to Flask that this index() function should be called to handle any GET or POST requests to the URL /.\n@app.route(\u0026#39;/\u0026#39;, methods=[\u0026#39;POST\u0026#39;, \u0026#39;GET\u0026#39;]) def index(): if request.method == \u0026#39;GET\u0026#39;: # code for a GET pass elif request.method == \u0026#39;POST\u0026#39;: # code for a POST pass We need to figure out which languages we have selected to determine which repos to display.\nWe\u0026rsquo;ll check the request.method variable to determine what kind of request it was - if it was a GET request, we\u0026rsquo;ll just display whichever repos were selected last (or all of them if this is the first request).\nIf it\u0026rsquo;s a POST, we\u0026rsquo;ll grab the languages variable from the request form and use it to populate our selected_languages list:\nif request.method == \u0026#39;GET\u0026#39;: # Use the list of all languages selected_languages = available_languages elif request.method == \u0026#39;POST\u0026#39;: # Use the languages we selected in the request form selected_languages = request.form.getlist(\u0026#34;languages\u0026#34;) Now, we just need to get our results and render our website. Call the repos_with_most_stars() function in api.py and pass it our selected_languages.\nThen, we\u0026rsquo;ll return our flask render_template() function and pass it our list of selected languages, available languages, and our results.\nresults = repos_with_most_stars(selected_languages) return render_template( \u0026#39;index.html\u0026#39;, selected_languages=selected_languages, available_languages=available_languages, results=results) Finally, we\u0026rsquo;ll add a custom error handler renders a special website (error.html) if we receive a GitHubApiException:\n@app.errorhandler(GitHubApiException) def handle_api_error(error): return render_template(\u0026#39;error.html\u0026#39;, message=error) Phew. Here\u0026#39;s the final `app.py` file that you should have: from flask import Flask, render_template, request from repos.api import repos_with_most_stars from repos.exceptions import GitHubApiException app = Flask(__name__) available_languages = [\u0026#34;Python\u0026#34;, \u0026#34;JavaScript\u0026#34;, \u0026#34;Ruby\u0026#34;, \u0026#34;Java\u0026#34;] @app.route(\u0026#39;/\u0026#39;, methods=[\u0026#39;POST\u0026#39;, \u0026#39;GET\u0026#39;]) def index(): if request.method == \u0026#39;GET\u0026#39;: # Use the list of all languages selected_languages = available_languages elif request.method == \u0026#39;POST\u0026#39;: # Use the languages we selected in the request form selected_languages = request.form.getlist(\u0026#34;languages\u0026#34;) results = repos_with_most_stars(selected_languages) return render_template( \u0026#39;index.html\u0026#39;, selected_languages=selected_languages, available_languages=available_languages, results=results) @app.errorhandler(GitHubApiException) def handle_api_error(error): return render_template(\u0026#39;error.html\u0026#39;, message=error) Run your Webapp At last, make sure you\u0026rsquo;re in your root day_two_final directory $ cd day_two_final and start your webapp with debug mode.\n(env) $ export FLASK_ENV=development; python3 -m flask run * Environment: development * Debug mode: on * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit) * Restarting with stat * Debugger is active! * Debugger PIN: 165-366-879 Point your web browser to the given URL (http://127.0.0.1:5000/ in this case) and you should see your list of repos sorted by number of stars. Play with the check boxes and the submit button on the left and see how the repo list changes. Congrats, you wrote a webapp in Python!\nBonus: Unit Tests Let\u0026rsquo;s add some quick unit tests to our code, to make sure we don\u0026rsquo;t introduce any regressions later on. Create a file called test.py in your day_two_final folder. Your folder should look like this:\nday_two_final ├── app.py ├── test.py ├── repos │ ├── exceptions.py │ ├── models.py │ └── api.py ├── static │ ├── favicon.png │ └── style.css └── templates ├── error.html └── index.html Create a new unittest.TestCase called TestCreateQuery. Inside, make a method called test_create_query(). In this method, create a list of language names and an int representing the a minimum number of stars. By looking at the create_query() function, see if you can figure out what the correct query string should be. Call the create_query() function with your test variables and use self.assertEqual() to make sure they match. Don\u0026rsquo;t forget to import repos.api and add your unittest.main() invocation.\nYou should have something like this: import repos.api import unittest class TestCreateQuery(unittest.TestCase): def test_create_query(self): test_languages = [\u0026#34;Python\u0026#34;, \u0026#34;Ruby\u0026#34;, \u0026#34;Java\u0026#34;] test_min_stars = 10000 expected = \u0026#34;language:Python language:Ruby language:Java stars:\u0026gt;10000\u0026#34; result = repos.api.create_query(test_languages, test_min_stars) self.assertEqual(result, expected, \u0026#34;Unexpected result from create_query\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: unittest.main() Run your test:\nHere\u0026#39;s what you should have seen on your command line: $ python test.py --verbose test_create_query (__main__.TestCreateQuery) ... ok ---------------------------------------------------------------------- Ran 1 test in 0.000s OK Let\u0026rsquo;s make two more quick tests of our GitHubApiException. Make a new TestCase with two test functions. Name the class and functions using the same naming convention we\u0026rsquo;ve been using. For the first, we\u0026rsquo;ll use a fake status_code of 403. Create a GitHubApiException object and pass it the status_code. Check to see if the string \u0026ldquo;Rate limit\u0026rdquo; exists in the string representation of your exception (hint: use str()).\nFor the second test, we\u0026rsquo;ll do the same thing with a status_code of 500. This time, we\u0026rsquo;ll check to see if \u0026ldquo;500\u0026rdquo; exists in the exception string.\nYou should have something like this: import repos.api import repos.exceptions import unittest class TestCreateQuery(unittest.TestCase): def test_create_query(self): test_languages = [\u0026#34;Python\u0026#34;, \u0026#34;Ruby\u0026#34;, \u0026#34;Java\u0026#34;] test_min_stars = 10000 expected = \u0026#34;language:Python language:Ruby language:Java stars:\u0026gt;10000\u0026#34; result = repos.api.create_query(test_languages, test_min_stars) self.assertEqual(result, expected, \u0026#34;Unexpected result from create_query\u0026#34;) class TestGitHubApiException(unittest.TestCase): def test_exception_403(self): status_code = 403 exception = repos.exceptions.GitHubApiException(status_code) self.assertTrue(\u0026#34;Rate limit\u0026#34; in str(exception), \u0026#34;\u0026#39;Rate limit\u0026#39; not found\u0026#34;) def test_exception_500(self): status_code = 500 exception = repos.exceptions.GitHubApiException(status_code) self.assertTrue(str(status_code) in str(exception)) if __name__ == \u0026#34;__main__\u0026#34;: unittest.main() Here\u0026#39;s what you should have seen on your command line: $ python test.py --verbose test_create_query (__main__.TestCreateQuery) ... ok test_exception_403 (__main__.TestGitHubApiException) ... ok test_exception_500 (__main__.TestGitHubApiException) ... ok ---------------------------------------------------------------------- Ran 3 tests in 0.001s OK "
},
{
	"uri": "https://pythonianrocketship.github.io/en/02-introduction-to-python/200-conclusion/00-wrapping-up/",
	"title": "Wrapping Up",
	"tags": [],
	"description": "",
	"content": "Today you\u0026rsquo;ve gotten a whirlwind tour of the Python programming language.\nDuring Day 2, we\u0026rsquo;re going to put our knowledge to work writing real programs.\nSource Control I highly recommend that you use source control while working on your Python projects. GitHub is a popular and free option.\nSource control lets you track changes to your project. You can use that to your advantage to commit early and often and track changes to your project.\nIf you\u0026rsquo;re not familiar with how to use git or GitHub, you can watch my Git In-depth Frontend Masters class. For Python projects, make sure that you use the correct .gitignore file. GitHub provides a free template that you can use.\n"
},
{
	"uri": "https://pythonianrocketship.github.io/en/03-intermediate-python/90-conclusion/",
	"title": "Wrapping Up",
	"tags": [],
	"description": "",
	"content": "Source Control I highly recommend that you use source control while working on your Python projects. GitHub is a popular and free option.\nSource control lets you track changes to your project. You can use that to your advantage to commit early and often and track changes to your project.\nIf you\u0026rsquo;re not familiar with how to use git or GitHub, you can watch my Git In-depth Frontend Masters class. For Python projects, make sure that you use the correct .gitignore file. GitHub provides a free template that you can use.\nNext Steps Now you know the basics, just enough to get started with working with APIs in Python with the requests library. You know just enough to see how powerful Python can be. You can chain all of these requests together into a fully functioning program that does so much more.\nThe next topics to study are:\nHow to authenticate to APIs How to use the other HTTP methods, just as POST to create resources, or PUT to update them Read the requests Quick Start Guide Additional Resources Flask Mega Tutorial - For learning the A-Z of Python web apps Hitchhikers Guide to Python - free Book Watch the video for this course - Intro to Python \u0026amp; Intermediate Python "
},
{
	"uri": "https://pythonianrocketship.github.io/en/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://pythonianrocketship.github.io/en/credits/",
	"title": "Credits",
	"tags": [],
	"description": "",
	"content": "Themes Special thanks to the hugo learn theme. Tooling Hugo Other Pixel Art CSS Styles For Final Exercise Buttons Checkboxes Tables Error Page Special thanks to my ❤️ Max for moral support while I worked on this class. "
},
{
	"uri": "https://pythonianrocketship.github.io/en/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]